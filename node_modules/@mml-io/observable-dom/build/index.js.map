{
  "version": 3,
  "sources": ["../src/JSDOMRunner.ts", "../src/utils.ts", "../src/ObservableDOM.ts"],
  "sourcesContent": ["import { LogMessage, ObservableDOMRemoteEvent } from \"@mml-io/observable-dom-common\";\nimport { foreignContent } from \"parse5\";\nforeignContent.SVG_TAG_NAMES_ADJUSTMENT_MAP.set(\"fedropshadow\", \"feDropShadow\");\nimport {\n  AbortablePromise,\n  DOMWindow,\n  FetchOptions,\n  JSDOM,\n  ResourceLoader,\n  ResourceLoaderConstructorOptions,\n  VirtualConsole,\n} from \"jsdom\";\nimport * as nodeFetch from \"node-fetch\";\nimport nodeFetchFn from \"node-fetch\";\nimport vm from \"vm\";\n\nimport { DOMRunnerFactory, DOMRunnerInterface, DOMRunnerMessage } from \"./ObservableDOM\";\n\nconst ErrDOMWindowNotInitialized = \"DOMWindow not initialized\";\n\nexport const JSDOMRunnerFactory: DOMRunnerFactory = (\n  htmlPath: string,\n  htmlContents: string,\n  params: object,\n  callback: (mutationList: DOMRunnerMessage) => void,\n): DOMRunnerInterface => {\n  return new JSDOMRunner(htmlPath, htmlContents, params, callback);\n};\n\n// This is used to stop JSDOM trying to load resources\nclass RejectionResourceLoader extends ResourceLoader {\n  public fetch(url: string): AbortablePromise<Buffer> | null {\n    console.error(\"RejectionResourceLoader.fetch\", url);\n    return null;\n  }\n}\n\nexport type ResourceURL = string | RegExp;\n\n// This allows JSDOM to load resources if their URLs are specified in the urls array.\nclass AllowListResourceLoader extends ResourceLoader {\n  private urls: ResourceURL[];\n\n  constructor(urls: ResourceURL[], opts?: ResourceLoaderConstructorOptions) {\n    super(opts);\n    this.urls = urls;\n  }\n  public fetch(url: string, opts?: FetchOptions): AbortablePromise<Buffer> | null {\n    const allow = this.urls.some((allowedURL) => {\n      return typeof allowedURL === \"string\" ? allowedURL === url : allowedURL.test(url);\n    });\n\n    if (allow) {\n      return super.fetch(url, opts ?? {});\n    }\n\n    console.error(\"AllowListResourceLoader.fetch: resource not allowed\", url);\n    return null;\n  }\n}\n\nexport type JSDOMRunnerOptions = {\n  allowResourceLoading?: boolean | ResourceURL[];\n  globals?: Record<string, any>;\n};\n\n/**\n * The JSDOMRunner class is used to run HTML Documents using JSDOM and emit DOMRunnerMessages for document events such\n * as mutations.\n *\n * It handles the receiving of remote events and the dispatching of them to the underlying DOM elements.\n */\nexport class JSDOMRunner implements DOMRunnerInterface {\n  public domWindow: DOMWindow | null = null;\n  private jsdom: JSDOM;\n\n  private callback: (message: DOMRunnerMessage) => void;\n  private mutationObserver: MutationObserver | null = null;\n  private htmlPath: string;\n\n  private documentStartTime = Date.now();\n\n  private isLoaded = false;\n  private logBuffer: LogMessage[] = [];\n\n  constructor(\n    htmlPath: string,\n    htmlContents: string,\n    params: object,\n    callback: (domRunnerMessage: DOMRunnerMessage) => void,\n    { allowResourceLoading = false, globals }: JSDOMRunnerOptions = {},\n  ) {\n    this.htmlPath = htmlPath;\n    this.callback = callback;\n\n    const resources = Array.isArray(allowResourceLoading)\n      ? new AllowListResourceLoader(allowResourceLoading)\n      : allowResourceLoading\n        ? \"usable\"\n        : new RejectionResourceLoader();\n\n    this.jsdom = new JSDOM(htmlContents, {\n      runScripts: \"dangerously\",\n      resources,\n      url: this.htmlPath,\n      virtualConsole: this.createVirtualConsole(),\n      beforeParse: (window) => {\n        this.domWindow = window;\n\n        this.domWindow.fetch = nodeFetchFn as unknown as typeof fetch;\n        this.domWindow.Headers = nodeFetch.Headers as unknown as typeof Headers;\n        this.domWindow.Request = nodeFetch.Request as unknown as typeof Request;\n        this.domWindow.Response = nodeFetch.Response as unknown as typeof Response;\n\n        // This is a polyfill for https://developer.mozilla.org/en-US/docs/Web/API/Document/timeline\n        const timeline = {};\n        Object.defineProperty(timeline, \"currentTime\", {\n          get: () => {\n            return this.getDocumentTime();\n          },\n        });\n        (window.document as any).timeline = timeline;\n\n        // JSON stringify and parse to avoid potential reference leaks from the params object\n        window.params = JSON.parse(JSON.stringify(params));\n\n        // Inject any provided globals onto the window\n        if (globals) {\n          for (const [key, value] of Object.entries(globals)) {\n            (window as any)[key] = value;\n          }\n        }\n\n        this.mutationObserver = new window.MutationObserver((mutationList) => {\n          this.callback({\n            mutationList,\n          });\n        });\n\n        window.addEventListener(\"load\", () => {\n          this.mutationObserver?.observe(window.document, {\n            attributes: true,\n            childList: true,\n            subtree: true,\n            characterData: true,\n          });\n\n          this.isLoaded = true;\n\n          this.callback({\n            loaded: true,\n          });\n\n          this.flushLogBuffer();\n        });\n      },\n    });\n  }\n\n  private flushLogBuffer() {\n    for (const logMessage of this.logBuffer) {\n      this.callback({\n        logMessage,\n      });\n    }\n\n    this.logBuffer = [];\n  }\n\n  private log(message: LogMessage) {\n    if (!this.isLoaded) {\n      this.logBuffer.push(message);\n      return;\n    }\n\n    this.callback({\n      logMessage: message,\n    });\n  }\n\n  public getDocument(): Document {\n    if (!this.domWindow) {\n      throw new Error(ErrDOMWindowNotInitialized);\n    }\n\n    return this.domWindow.document;\n  }\n\n  public getWindow(): any {\n    return this.domWindow;\n  }\n\n  public dispose() {\n    const records = this.mutationObserver?.takeRecords();\n    this.callback({\n      mutationList: records,\n    });\n    this.mutationObserver?.disconnect();\n    this.jsdom.window.close();\n  }\n\n  public getDocumentTime() {\n    return Date.now() - this.documentStartTime;\n  }\n\n  public dispatchRemoteEventFromConnectionId(\n    connectionId: number,\n    domNode: Element,\n    remoteEvent: ObservableDOMRemoteEvent,\n  ) {\n    if (!this.domWindow) {\n      throw new Error(ErrDOMWindowNotInitialized);\n    }\n\n    const bubbles = remoteEvent.bubbles || false;\n    const remoteEventObject = new this.domWindow.CustomEvent(remoteEvent.name, {\n      bubbles,\n      detail: { ...remoteEvent.params, connectionId },\n    });\n\n    const eventTypeLowerCase = remoteEvent.name.toLowerCase();\n\n    // TODO - check if there are other events that automatically wire up similarly to click->onclick and avoid those too\n    if (eventTypeLowerCase !== \"click\") {\n      const handlerAttributeName = \"on\" + eventTypeLowerCase;\n      const handlerAttributeValue = domNode.getAttribute(handlerAttributeName);\n      if (handlerAttributeValue) {\n        // This event is defined as an HTML event attribute.\n        const script = handlerAttributeValue;\n        const vmContext = this.jsdom.getInternalVMContext();\n        try {\n          const invoke = vm.runInContext(`(function(event){ ${script} })`, vmContext);\n          Reflect.apply(invoke, domNode, [remoteEventObject]);\n        } catch (e) {\n          console.error(\"Error running event handler:\", e);\n        }\n      }\n    }\n\n    // Dispatch the event via JavaScript.\n    domNode.dispatchEvent(remoteEventObject);\n  }\n\n  private createVirtualConsole(): VirtualConsole {\n    const virtualConsole = new VirtualConsole();\n    virtualConsole.on(\"jsdomError\", (...args) => {\n      this.log({\n        level: \"system\",\n        content: args,\n      });\n    });\n    virtualConsole.on(\"error\", (...args) => {\n      this.log({\n        level: \"error\",\n        content: args,\n      });\n    });\n    virtualConsole.on(\"warn\", (...args) => {\n      this.log({\n        level: \"warn\",\n        content: args,\n      });\n    });\n    virtualConsole.on(\"log\", (...args) => {\n      this.log({\n        level: \"log\",\n        content: args,\n      });\n    });\n    virtualConsole.on(\"info\", (...args) => {\n      this.log({\n        level: \"info\",\n        content: args,\n      });\n    });\n    return virtualConsole;\n  }\n}\n", "import { StaticVirtualDOMElement } from \"@mml-io/observable-dom-common\";\n\nimport { LiveVirtualDOMElement } from \"./ObservableDOM\";\n\nexport function virtualDOMElementToStatic(el: LiveVirtualDOMElement): StaticVirtualDOMElement {\n  return {\n    nodeId: el.nodeId,\n    tag: el.tag,\n    attributes: Object.assign({}, el.attributes), // Copy the attributes object - shallow copy is fine as the attributes are strings\n    childNodes: el.childNodes.map((child) => virtualDOMElementToStatic(child)),\n    textContent: el.textContent,\n  };\n}\n", "import {\n  LogMessage,\n  ObservableDOMInterface,\n  ObservableDOMMessage,\n  ObservableDOMParameters,\n  ObservableDOMRemoteEvent,\n  StaticVirtualDOMElement,\n  StaticVirtualDOMMutationIdsRecord,\n} from \"@mml-io/observable-dom-common\";\n\nimport { virtualDOMElementToStatic } from \"./utils\";\n\nexport type DOMRunnerMessage = {\n  loaded?: boolean;\n  mutationList?: Array<MutationRecord>;\n  logMessage?: LogMessage;\n};\n\nexport type DOMRunnerInterface = {\n  getDocument(): Document;\n  getWindow(): Window & {\n    CustomEvent: typeof CustomEvent;\n    Text: typeof Text;\n    HTMLScriptElement: typeof HTMLScriptElement;\n    Comment: typeof Comment;\n  }; // TODO - Define this without using JSDOM types\n  dispatchRemoteEventFromConnectionId(\n    connectionId: number,\n    realElement: Element,\n    remoteEvent: ObservableDOMRemoteEvent,\n  ): void;\n  dispose(): void;\n  getDocumentTime(): number;\n};\n\nexport type DOMRunnerFactory = (\n  htmlPath: string,\n  htmlContents: string,\n  params: object,\n  callback: (domRunnerMessage: DOMRunnerMessage) => void,\n) => DOMRunnerInterface;\n\nexport type LiveVirtualDOMElement = Omit<StaticVirtualDOMElement, \"childNodes\"> & {\n  realElement: Element | Text;\n  childNodes: Array<LiveVirtualDOMElement>;\n  parent: LiveVirtualDOMElement | null;\n};\n\n/**\n * The ObservableDOM class handles the running of an HTML document using a provided DOMRunnerFactory and converting the\n * mutations that are structured as references to live DOM elements into messages that refer to elements by nodeIds.\n */\nexport class ObservableDOM implements ObservableDOMInterface {\n  private nodeToNodeId = new Map<LiveVirtualDOMElement, number>();\n  private nodeIdToNode = new Map<number, LiveVirtualDOMElement>();\n  private realElementToVirtualElement = new Map<Element | Text, LiveVirtualDOMElement>();\n  private ignoreTextNodes = true;\n  private callback: (message: ObservableDOMMessage, observableDOM: ObservableDOMInterface) => void;\n  private nextNodeId = 1;\n  private htmlPath: string;\n  private domRunner: DOMRunnerInterface;\n  private loaded = false;\n  private preLoadLogMessages: Array<LogMessage> = [];\n\n  private documentTimeIntervalTimer: NodeJS.Timeout;\n\n  constructor(\n    observableDOMParameters: ObservableDOMParameters,\n    callback: (message: ObservableDOMMessage, observableDOM: ObservableDOMInterface) => void,\n    runnerFactory: DOMRunnerFactory,\n  ) {\n    this.htmlPath = observableDOMParameters.htmlPath;\n    this.ignoreTextNodes = observableDOMParameters.ignoreTextNodes;\n    this.callback = callback;\n\n    this.documentTimeIntervalTimer = setInterval(() => {\n      this.callback(\n        {\n          documentTime: this.getDocumentTime(),\n        },\n        this,\n      );\n    }, observableDOMParameters.pingIntervalMilliseconds || 5000);\n\n    this.domRunner = runnerFactory(\n      observableDOMParameters.htmlPath,\n      observableDOMParameters.htmlContents,\n      observableDOMParameters.params,\n      (domRunnerMessage: DOMRunnerMessage) => {\n        if (domRunnerMessage.loaded) {\n          this.loaded = true;\n          this.createVirtualDOMElementWithChildren(\n            this.domRunner.getDocument() as unknown as Element,\n            null,\n          );\n\n          const snapshot = virtualDOMElementToStatic(\n            this.getVirtualDOMElementForRealElementOrThrow(\n              this.domRunner.getDocument() as unknown as Element,\n            ),\n          );\n\n          this.callback(\n            {\n              snapshot,\n              documentTime: this.getDocumentTime(),\n            },\n            this,\n          );\n          for (const logMessage of this.preLoadLogMessages) {\n            this.callback(\n              {\n                logMessage,\n                documentTime: this.getDocumentTime(),\n              },\n              this,\n            );\n          }\n          this.preLoadLogMessages = [];\n        } else if (domRunnerMessage.mutationList) {\n          this.processModificationList(domRunnerMessage.mutationList);\n        } else if (domRunnerMessage.logMessage) {\n          if (!this.loaded) {\n            this.preLoadLogMessages.push(domRunnerMessage.logMessage);\n            return;\n          }\n          this.callback(\n            {\n              logMessage: domRunnerMessage.logMessage,\n              documentTime: this.getDocumentTime(),\n            },\n            this,\n          );\n        }\n      },\n    );\n  }\n\n  public addConnectedUserId(connectionId: number, connectionToken: string | null): void {\n    this.domRunner.getWindow().dispatchEvent(\n      new (this.domRunner.getWindow().CustomEvent)(\"connected\", {\n        detail: { connectionId, connectionToken },\n      }),\n    );\n  }\n\n  public removeConnectedUserId(connectionId: number): void {\n    this.domRunner.getWindow().dispatchEvent(\n      new (this.domRunner.getWindow().CustomEvent)(\"disconnected\", {\n        detail: { connectionId },\n      }),\n    );\n  }\n\n  private processModificationList(mutationList: Array<MutationRecord>): void {\n    if (mutationList.length > 1) {\n      // TODO (https://github.com/mml-io/mml/issues/100) - walk back through the records to derive the intermediate\n      //  states (e.g. if an attribute is later added to an element created in an earlier record then it should not\n      //  have that attribute when the element is added. This is important as incorrect attribute sets can affect\n      //  visibility and expected client performance.\n    }\n\n    const allMutationRecords: Array<StaticVirtualDOMMutationIdsRecord> = [];\n    for (const mutation of mutationList) {\n      const idsRecord = this.createMutationRecord(mutation);\n      if (idsRecord) {\n        allMutationRecords.push(idsRecord);\n      }\n    }\n\n    if (allMutationRecords.length > 0) {\n      this.callback(\n        {\n          mutations: allMutationRecords,\n          documentTime: this.getDocumentTime(),\n        },\n        this,\n      );\n    }\n  }\n\n  private createMutationRecord(mutation: MutationRecord): StaticVirtualDOMMutationIdsRecord | null {\n    if (this.isIgnoredElement(mutation.target as Element | Text)) {\n      return null;\n    }\n\n    if (\n      mutation.type === \"attributes\" &&\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      this.isIgnoredAttribute(mutation.target as Element | Text, mutation.attributeName!)\n    ) {\n      return null;\n    }\n\n    const targetNode = mutation.target as Element | Text;\n    const targetElement = this.realElementToVirtualElement.get(targetNode);\n    if (!targetElement) {\n      // This can happen if the target element for this mutation has been removed in a previous mutation\n      return null;\n    }\n\n    let previousSiblingElement: LiveVirtualDOMElement | null = null;\n    let insertionIndex = 0;\n    const toAdd: Array<LiveVirtualDOMElement> = [];\n    const removedNodeIds: Array<number> = [];\n\n    if (mutation.type === \"childList\") {\n      mutation.removedNodes.forEach((node: Node) => {\n        const asElementOrText = node as Element | Text;\n        if (this.isIgnoredElement(asElementOrText)) {\n          return;\n        }\n        const childDOMElement = this.realElementToVirtualElement.get(asElementOrText);\n        if (!childDOMElement) {\n          /*\n           This can happen if element was a child of a parent element, but was moved to a new parent in the same batch of mutations.\n           We can ignore this removal as the element will be in the correct place in the hierarchy already.\n          */\n          return;\n        } else {\n          const index = targetElement.childNodes.indexOf(childDOMElement);\n          if (index === -1) {\n            /*\n           This can happen if element was a child of a parent element, but was moved to a new parent in the same batch of mutations.\n           We can ignore this removal as the element will be in the correct place in the hierarchy already.\n          */\n          } else {\n            this.removeVirtualDOMElement(childDOMElement);\n            removedNodeIds.push(childDOMElement.nodeId);\n            const removal = targetElement.childNodes.splice(index, 1);\n            if (removal.length !== 1) {\n              throw new Error(\"Removal length not 1\");\n            } else {\n              if (removal[0].nodeId !== childDOMElement.nodeId) {\n                throw new Error(\"Removal node id mismatch\");\n              }\n            }\n          }\n        }\n      });\n\n      mutation.addedNodes.forEach((node: Node) => {\n        const asElementOrText = node as Element | Text;\n        if (asElementOrText.parentNode !== targetNode) {\n          // Ignore this addition - it is likely overridden by an earlier addition of this element to its eventual node in this mutation batch\n        } else {\n          if (!previousSiblingElement) {\n            /*\n             Either there is no previous element (this is the first element)\n             or the previous element has not yet been determined.\n\n             Use the current previous sibling of this added node as the first\n             choice for the previous sibling, but only use previous siblings\n             that are not ignored (are tracked as virtual elements).\n            */\n            let firstNonIgnoredPreviousSibling: Element | Text | null =\n              asElementOrText.previousSibling as Element | Text;\n            let virtualPreviousSibling: LiveVirtualDOMElement | undefined;\n            while (firstNonIgnoredPreviousSibling && !virtualPreviousSibling) {\n              virtualPreviousSibling = this.realElementToVirtualElement.get(\n                firstNonIgnoredPreviousSibling as Element | Text,\n              );\n              if (\n                virtualPreviousSibling &&\n                targetElement.childNodes.indexOf(virtualPreviousSibling) === -1\n              ) {\n                // This element is not a child of the parent element - it is not a valid previous sibling\n                virtualPreviousSibling = undefined;\n              }\n\n              firstNonIgnoredPreviousSibling = firstNonIgnoredPreviousSibling.previousSibling as\n                | Element\n                | Text\n                | null;\n            }\n\n            if (virtualPreviousSibling) {\n              previousSiblingElement = virtualPreviousSibling;\n              insertionIndex = targetElement.childNodes.indexOf(previousSiblingElement);\n              if (insertionIndex === -1) {\n                throw new Error(\"Previous sibling is not currently a child of the parent element\");\n              }\n              insertionIndex += 1;\n            }\n          }\n          const childVirtualDOMElement = this.createVirtualDOMElementWithChildren(\n            asElementOrText,\n            targetElement,\n          );\n          if (childVirtualDOMElement) {\n            toAdd.push(childVirtualDOMElement);\n          }\n        }\n      });\n      targetElement.childNodes.splice(insertionIndex, 0, ...toAdd);\n\n      if (toAdd.length === 0 && removedNodeIds.length === 0) {\n        // This is a no-op mutation\n        return null;\n      }\n      // Convert the \"real\" DOM MutationRecord into a \"virtual\" DOM MutationRecord that references the VirtualDOMElements\n      // This is done so that the same process for handling mutations can be used for both changes to a live DOM and also\n      // to diffs between DOM snapshots when reloading\n      const addedNodes: Array<StaticVirtualDOMElement> = toAdd.map(virtualDOMElementToStatic);\n      return {\n        type: \"childList\",\n        targetId: targetElement.nodeId,\n        addedNodes,\n        removedNodeIds,\n        previousSiblingId: previousSiblingElement\n          ? (previousSiblingElement as LiveVirtualDOMElement).nodeId\n          : null,\n      };\n    } else if (mutation.type === \"attributes\") {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const attributeName = mutation.attributeName!;\n      if (!this.isIgnoredAttribute(targetNode, attributeName)) {\n        const previousValue = targetElement.attributes[attributeName];\n        const attributeValue = (targetNode as Element).getAttribute(attributeName);\n        if (attributeValue === null) {\n          if (previousValue === undefined) {\n            // This is a no-op mutation\n            return null;\n          }\n          delete targetElement.attributes[attributeName];\n        } else {\n          if (attributeValue === previousValue) {\n            // This is a no-op mutation\n            return null;\n          }\n          targetElement.attributes[attributeName] = attributeValue;\n        }\n        return {\n          type: \"attributes\",\n          targetId: targetElement.nodeId,\n          attributes: {\n            [attributeName]: attributeValue,\n          },\n        };\n      }\n    } else if (mutation.type === \"characterData\") {\n      targetElement.textContent = targetNode.textContent ? targetNode.textContent : undefined;\n      return {\n        type: \"characterData\",\n        targetId: targetElement.nodeId,\n        textContent: targetElement.textContent ? targetElement.textContent : \"\",\n      };\n    }\n\n    throw new Error(\"Unknown mutation type: \" + mutation.type);\n  }\n\n  private removeVirtualDOMElement(virtualDOMElement: LiveVirtualDOMElement): void {\n    this.nodeIdToNode.delete(virtualDOMElement.nodeId);\n    this.nodeToNodeId.delete(virtualDOMElement);\n    this.realElementToVirtualElement.delete(virtualDOMElement.realElement);\n    for (const child of virtualDOMElement.childNodes) {\n      this.removeVirtualDOMElement(child);\n    }\n  }\n\n  private createVirtualDOMElementWithChildren(\n    node: Element | Text,\n    parent: LiveVirtualDOMElement | null,\n  ): LiveVirtualDOMElement | null {\n    const [virtualElement, existing] = this.createVirtualDOMElement(node, parent);\n    if (!virtualElement) {\n      return null;\n    }\n    if (existing) {\n      return null;\n    }\n    if ((node as Element).childNodes) {\n      for (let i = 0; i < (node as Element).childNodes.length; i++) {\n        const child = (node as Element).childNodes[i];\n        const childVirtualElement = this.createVirtualDOMElementWithChildren(\n          child as Element | Text,\n          virtualElement,\n        );\n        if (childVirtualElement) {\n          virtualElement.childNodes.push(childVirtualElement);\n        }\n      }\n    }\n\n    return virtualElement;\n  }\n\n  private createVirtualDOMElement(\n    node: Element | Text,\n    parent: LiveVirtualDOMElement | null,\n  ): [LiveVirtualDOMElement | null, boolean] {\n    if (this.isIgnoredElement(node)) {\n      return [null, false];\n    }\n    if (!node) {\n      throw new Error(\"Cannot assign node id to null\");\n    }\n\n    const existingValue = this.realElementToVirtualElement.get(node);\n    if (existingValue !== undefined) {\n      /*\n       This is undesirable, but the batching of mutations from MutationObserver means that\n       this node could be being added in a mutation after a mutation of a parent that when\n       handled resulting in adding this node early.\n      */\n      return [existingValue, true];\n    }\n\n    const attributes: { [key: string]: string } = {};\n    if ((node as any).attributes) {\n      const asHTMLElement = node as HTMLElement;\n      for (const key of asHTMLElement.getAttributeNames()) {\n        const value = asHTMLElement.getAttribute(key);\n        if (value === null) {\n          throw new Error(\"Null attribute value for key: \" + key);\n        }\n        if (!this.isIgnoredAttribute(node, key)) {\n          attributes[key] = value;\n        }\n      }\n    }\n\n    const nodeId = this.nextNodeId++;\n    const localNameValue = (node as Element).localName;\n    const nodeNameValue = node.nodeName;\n    let tag = localNameValue || nodeNameValue;\n    if (tag !== \"#text\") {\n      tag = tag.toUpperCase();\n    }\n\n    const virtualElement: LiveVirtualDOMElement = {\n      nodeId,\n      tag,\n      attributes,\n      childNodes: [],\n      realElement: node,\n      parent,\n    };\n    if (node instanceof this.domRunner.getWindow().Text && node.textContent) {\n      virtualElement.textContent = node.textContent;\n    }\n    this.nodeToNodeId.set(virtualElement, nodeId);\n    this.nodeIdToNode.set(nodeId, virtualElement);\n    this.realElementToVirtualElement.set(node, virtualElement);\n    return [virtualElement, false];\n  }\n\n  private getVirtualDOMElementForRealElementOrThrow(\n    realElement: Element | Text,\n  ): LiveVirtualDOMElement {\n    const virtualElement = this.realElementToVirtualElement.get(realElement);\n    if (!virtualElement) {\n      throw new Error(`Virtual element not found for real element`);\n    }\n    return virtualElement;\n  }\n\n  private isIgnoredElement(node: Element | Text): boolean {\n    if (this.ignoreTextNodes && node instanceof this.domRunner.getWindow().Text) {\n      return true;\n    } else if (node instanceof this.domRunner.getWindow().HTMLScriptElement) {\n      return true;\n    } else if (node instanceof this.domRunner.getWindow().Comment) {\n      return true;\n    }\n    return false;\n  }\n\n  private isIgnoredAttribute(node: Element | Text, attributeName: string): boolean {\n    return attributeName.startsWith(\"on\");\n  }\n\n  public dispatchRemoteEventFromConnectionId(\n    connectionId: number,\n    remoteEvent: ObservableDOMRemoteEvent,\n  ): void {\n    const domNode = this.nodeIdToNode.get(remoteEvent.nodeId);\n    if (!domNode) {\n      console.error(\"Unknown node ID in remote event: \" + remoteEvent.nodeId);\n      return;\n    }\n\n    if (domNode instanceof this.domRunner.getWindow().Text) {\n      console.warn(\"Cannot dispatch remote event to text node\");\n      return;\n    }\n\n    this.domRunner.dispatchRemoteEventFromConnectionId(\n      connectionId,\n      domNode.realElement as Element,\n      remoteEvent,\n    );\n  }\n\n  public dispose() {\n    clearInterval(this.documentTimeIntervalTimer);\n    this.domRunner.dispose();\n  }\n\n  private getDocumentTime() {\n    return this.domRunner.getDocumentTime();\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
