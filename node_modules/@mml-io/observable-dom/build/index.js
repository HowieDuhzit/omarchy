// src/JSDOMRunner.ts
import { foreignContent } from "parse5";
import {
  JSDOM,
  ResourceLoader,
  VirtualConsole
} from "jsdom";
import * as nodeFetch from "node-fetch";
import nodeFetchFn from "node-fetch";
import vm from "vm";
foreignContent.SVG_TAG_NAMES_ADJUSTMENT_MAP.set("fedropshadow", "feDropShadow");
var ErrDOMWindowNotInitialized = "DOMWindow not initialized";
var JSDOMRunnerFactory = (htmlPath, htmlContents, params, callback) => {
  return new JSDOMRunner(htmlPath, htmlContents, params, callback);
};
var RejectionResourceLoader = class extends ResourceLoader {
  fetch(url) {
    console.error("RejectionResourceLoader.fetch", url);
    return null;
  }
};
var AllowListResourceLoader = class extends ResourceLoader {
  constructor(urls, opts) {
    super(opts);
    this.urls = urls;
  }
  fetch(url, opts) {
    const allow = this.urls.some((allowedURL) => {
      return typeof allowedURL === "string" ? allowedURL === url : allowedURL.test(url);
    });
    if (allow) {
      return super.fetch(url, opts ?? {});
    }
    console.error("AllowListResourceLoader.fetch: resource not allowed", url);
    return null;
  }
};
var JSDOMRunner = class {
  constructor(htmlPath, htmlContents, params, callback, { allowResourceLoading = false, globals } = {}) {
    this.domWindow = null;
    this.mutationObserver = null;
    this.documentStartTime = Date.now();
    this.isLoaded = false;
    this.logBuffer = [];
    this.htmlPath = htmlPath;
    this.callback = callback;
    const resources = Array.isArray(allowResourceLoading) ? new AllowListResourceLoader(allowResourceLoading) : allowResourceLoading ? "usable" : new RejectionResourceLoader();
    this.jsdom = new JSDOM(htmlContents, {
      runScripts: "dangerously",
      resources,
      url: this.htmlPath,
      virtualConsole: this.createVirtualConsole(),
      beforeParse: (window) => {
        this.domWindow = window;
        this.domWindow.fetch = nodeFetchFn;
        this.domWindow.Headers = nodeFetch.Headers;
        this.domWindow.Request = nodeFetch.Request;
        this.domWindow.Response = nodeFetch.Response;
        const timeline = {};
        Object.defineProperty(timeline, "currentTime", {
          get: () => {
            return this.getDocumentTime();
          }
        });
        window.document.timeline = timeline;
        window.params = JSON.parse(JSON.stringify(params));
        if (globals) {
          for (const [key, value] of Object.entries(globals)) {
            window[key] = value;
          }
        }
        this.mutationObserver = new window.MutationObserver((mutationList) => {
          this.callback({
            mutationList
          });
        });
        window.addEventListener("load", () => {
          var _a;
          (_a = this.mutationObserver) == null ? void 0 : _a.observe(window.document, {
            attributes: true,
            childList: true,
            subtree: true,
            characterData: true
          });
          this.isLoaded = true;
          this.callback({
            loaded: true
          });
          this.flushLogBuffer();
        });
      }
    });
  }
  flushLogBuffer() {
    for (const logMessage of this.logBuffer) {
      this.callback({
        logMessage
      });
    }
    this.logBuffer = [];
  }
  log(message) {
    if (!this.isLoaded) {
      this.logBuffer.push(message);
      return;
    }
    this.callback({
      logMessage: message
    });
  }
  getDocument() {
    if (!this.domWindow) {
      throw new Error(ErrDOMWindowNotInitialized);
    }
    return this.domWindow.document;
  }
  getWindow() {
    return this.domWindow;
  }
  dispose() {
    var _a, _b;
    const records = (_a = this.mutationObserver) == null ? void 0 : _a.takeRecords();
    this.callback({
      mutationList: records
    });
    (_b = this.mutationObserver) == null ? void 0 : _b.disconnect();
    this.jsdom.window.close();
  }
  getDocumentTime() {
    return Date.now() - this.documentStartTime;
  }
  dispatchRemoteEventFromConnectionId(connectionId, domNode, remoteEvent) {
    if (!this.domWindow) {
      throw new Error(ErrDOMWindowNotInitialized);
    }
    const bubbles = remoteEvent.bubbles || false;
    const remoteEventObject = new this.domWindow.CustomEvent(remoteEvent.name, {
      bubbles,
      detail: { ...remoteEvent.params, connectionId }
    });
    const eventTypeLowerCase = remoteEvent.name.toLowerCase();
    if (eventTypeLowerCase !== "click") {
      const handlerAttributeName = "on" + eventTypeLowerCase;
      const handlerAttributeValue = domNode.getAttribute(handlerAttributeName);
      if (handlerAttributeValue) {
        const script = handlerAttributeValue;
        const vmContext = this.jsdom.getInternalVMContext();
        try {
          const invoke = vm.runInContext(`(function(event){ ${script} })`, vmContext);
          Reflect.apply(invoke, domNode, [remoteEventObject]);
        } catch (e) {
          console.error("Error running event handler:", e);
        }
      }
    }
    domNode.dispatchEvent(remoteEventObject);
  }
  createVirtualConsole() {
    const virtualConsole = new VirtualConsole();
    virtualConsole.on("jsdomError", (...args) => {
      this.log({
        level: "system",
        content: args
      });
    });
    virtualConsole.on("error", (...args) => {
      this.log({
        level: "error",
        content: args
      });
    });
    virtualConsole.on("warn", (...args) => {
      this.log({
        level: "warn",
        content: args
      });
    });
    virtualConsole.on("log", (...args) => {
      this.log({
        level: "log",
        content: args
      });
    });
    virtualConsole.on("info", (...args) => {
      this.log({
        level: "info",
        content: args
      });
    });
    return virtualConsole;
  }
};

// src/utils.ts
function virtualDOMElementToStatic(el) {
  return {
    nodeId: el.nodeId,
    tag: el.tag,
    attributes: Object.assign({}, el.attributes),
    // Copy the attributes object - shallow copy is fine as the attributes are strings
    childNodes: el.childNodes.map((child) => virtualDOMElementToStatic(child)),
    textContent: el.textContent
  };
}

// src/ObservableDOM.ts
var ObservableDOM = class {
  constructor(observableDOMParameters, callback, runnerFactory) {
    this.nodeToNodeId = /* @__PURE__ */ new Map();
    this.nodeIdToNode = /* @__PURE__ */ new Map();
    this.realElementToVirtualElement = /* @__PURE__ */ new Map();
    this.ignoreTextNodes = true;
    this.nextNodeId = 1;
    this.loaded = false;
    this.preLoadLogMessages = [];
    this.htmlPath = observableDOMParameters.htmlPath;
    this.ignoreTextNodes = observableDOMParameters.ignoreTextNodes;
    this.callback = callback;
    this.documentTimeIntervalTimer = setInterval(() => {
      this.callback(
        {
          documentTime: this.getDocumentTime()
        },
        this
      );
    }, observableDOMParameters.pingIntervalMilliseconds || 5e3);
    this.domRunner = runnerFactory(
      observableDOMParameters.htmlPath,
      observableDOMParameters.htmlContents,
      observableDOMParameters.params,
      (domRunnerMessage) => {
        if (domRunnerMessage.loaded) {
          this.loaded = true;
          this.createVirtualDOMElementWithChildren(
            this.domRunner.getDocument(),
            null
          );
          const snapshot = virtualDOMElementToStatic(
            this.getVirtualDOMElementForRealElementOrThrow(
              this.domRunner.getDocument()
            )
          );
          this.callback(
            {
              snapshot,
              documentTime: this.getDocumentTime()
            },
            this
          );
          for (const logMessage of this.preLoadLogMessages) {
            this.callback(
              {
                logMessage,
                documentTime: this.getDocumentTime()
              },
              this
            );
          }
          this.preLoadLogMessages = [];
        } else if (domRunnerMessage.mutationList) {
          this.processModificationList(domRunnerMessage.mutationList);
        } else if (domRunnerMessage.logMessage) {
          if (!this.loaded) {
            this.preLoadLogMessages.push(domRunnerMessage.logMessage);
            return;
          }
          this.callback(
            {
              logMessage: domRunnerMessage.logMessage,
              documentTime: this.getDocumentTime()
            },
            this
          );
        }
      }
    );
  }
  addConnectedUserId(connectionId, connectionToken) {
    this.domRunner.getWindow().dispatchEvent(
      new (this.domRunner.getWindow()).CustomEvent("connected", {
        detail: { connectionId, connectionToken }
      })
    );
  }
  removeConnectedUserId(connectionId) {
    this.domRunner.getWindow().dispatchEvent(
      new (this.domRunner.getWindow()).CustomEvent("disconnected", {
        detail: { connectionId }
      })
    );
  }
  processModificationList(mutationList) {
    if (mutationList.length > 1) {
    }
    const allMutationRecords = [];
    for (const mutation of mutationList) {
      const idsRecord = this.createMutationRecord(mutation);
      if (idsRecord) {
        allMutationRecords.push(idsRecord);
      }
    }
    if (allMutationRecords.length > 0) {
      this.callback(
        {
          mutations: allMutationRecords,
          documentTime: this.getDocumentTime()
        },
        this
      );
    }
  }
  createMutationRecord(mutation) {
    if (this.isIgnoredElement(mutation.target)) {
      return null;
    }
    if (mutation.type === "attributes" && // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    this.isIgnoredAttribute(mutation.target, mutation.attributeName)) {
      return null;
    }
    const targetNode = mutation.target;
    const targetElement = this.realElementToVirtualElement.get(targetNode);
    if (!targetElement) {
      return null;
    }
    let previousSiblingElement = null;
    let insertionIndex = 0;
    const toAdd = [];
    const removedNodeIds = [];
    if (mutation.type === "childList") {
      mutation.removedNodes.forEach((node) => {
        const asElementOrText = node;
        if (this.isIgnoredElement(asElementOrText)) {
          return;
        }
        const childDOMElement = this.realElementToVirtualElement.get(asElementOrText);
        if (!childDOMElement) {
          return;
        } else {
          const index = targetElement.childNodes.indexOf(childDOMElement);
          if (index === -1) {
          } else {
            this.removeVirtualDOMElement(childDOMElement);
            removedNodeIds.push(childDOMElement.nodeId);
            const removal = targetElement.childNodes.splice(index, 1);
            if (removal.length !== 1) {
              throw new Error("Removal length not 1");
            } else {
              if (removal[0].nodeId !== childDOMElement.nodeId) {
                throw new Error("Removal node id mismatch");
              }
            }
          }
        }
      });
      mutation.addedNodes.forEach((node) => {
        const asElementOrText = node;
        if (asElementOrText.parentNode !== targetNode) {
        } else {
          if (!previousSiblingElement) {
            let firstNonIgnoredPreviousSibling = asElementOrText.previousSibling;
            let virtualPreviousSibling;
            while (firstNonIgnoredPreviousSibling && !virtualPreviousSibling) {
              virtualPreviousSibling = this.realElementToVirtualElement.get(
                firstNonIgnoredPreviousSibling
              );
              if (virtualPreviousSibling && targetElement.childNodes.indexOf(virtualPreviousSibling) === -1) {
                virtualPreviousSibling = void 0;
              }
              firstNonIgnoredPreviousSibling = firstNonIgnoredPreviousSibling.previousSibling;
            }
            if (virtualPreviousSibling) {
              previousSiblingElement = virtualPreviousSibling;
              insertionIndex = targetElement.childNodes.indexOf(previousSiblingElement);
              if (insertionIndex === -1) {
                throw new Error("Previous sibling is not currently a child of the parent element");
              }
              insertionIndex += 1;
            }
          }
          const childVirtualDOMElement = this.createVirtualDOMElementWithChildren(
            asElementOrText,
            targetElement
          );
          if (childVirtualDOMElement) {
            toAdd.push(childVirtualDOMElement);
          }
        }
      });
      targetElement.childNodes.splice(insertionIndex, 0, ...toAdd);
      if (toAdd.length === 0 && removedNodeIds.length === 0) {
        return null;
      }
      const addedNodes = toAdd.map(virtualDOMElementToStatic);
      return {
        type: "childList",
        targetId: targetElement.nodeId,
        addedNodes,
        removedNodeIds,
        previousSiblingId: previousSiblingElement ? previousSiblingElement.nodeId : null
      };
    } else if (mutation.type === "attributes") {
      const attributeName = mutation.attributeName;
      if (!this.isIgnoredAttribute(targetNode, attributeName)) {
        const previousValue = targetElement.attributes[attributeName];
        const attributeValue = targetNode.getAttribute(attributeName);
        if (attributeValue === null) {
          if (previousValue === void 0) {
            return null;
          }
          delete targetElement.attributes[attributeName];
        } else {
          if (attributeValue === previousValue) {
            return null;
          }
          targetElement.attributes[attributeName] = attributeValue;
        }
        return {
          type: "attributes",
          targetId: targetElement.nodeId,
          attributes: {
            [attributeName]: attributeValue
          }
        };
      }
    } else if (mutation.type === "characterData") {
      targetElement.textContent = targetNode.textContent ? targetNode.textContent : void 0;
      return {
        type: "characterData",
        targetId: targetElement.nodeId,
        textContent: targetElement.textContent ? targetElement.textContent : ""
      };
    }
    throw new Error("Unknown mutation type: " + mutation.type);
  }
  removeVirtualDOMElement(virtualDOMElement) {
    this.nodeIdToNode.delete(virtualDOMElement.nodeId);
    this.nodeToNodeId.delete(virtualDOMElement);
    this.realElementToVirtualElement.delete(virtualDOMElement.realElement);
    for (const child of virtualDOMElement.childNodes) {
      this.removeVirtualDOMElement(child);
    }
  }
  createVirtualDOMElementWithChildren(node, parent) {
    const [virtualElement, existing] = this.createVirtualDOMElement(node, parent);
    if (!virtualElement) {
      return null;
    }
    if (existing) {
      return null;
    }
    if (node.childNodes) {
      for (let i = 0; i < node.childNodes.length; i++) {
        const child = node.childNodes[i];
        const childVirtualElement = this.createVirtualDOMElementWithChildren(
          child,
          virtualElement
        );
        if (childVirtualElement) {
          virtualElement.childNodes.push(childVirtualElement);
        }
      }
    }
    return virtualElement;
  }
  createVirtualDOMElement(node, parent) {
    if (this.isIgnoredElement(node)) {
      return [null, false];
    }
    if (!node) {
      throw new Error("Cannot assign node id to null");
    }
    const existingValue = this.realElementToVirtualElement.get(node);
    if (existingValue !== void 0) {
      return [existingValue, true];
    }
    const attributes = {};
    if (node.attributes) {
      const asHTMLElement = node;
      for (const key of asHTMLElement.getAttributeNames()) {
        const value = asHTMLElement.getAttribute(key);
        if (value === null) {
          throw new Error("Null attribute value for key: " + key);
        }
        if (!this.isIgnoredAttribute(node, key)) {
          attributes[key] = value;
        }
      }
    }
    const nodeId = this.nextNodeId++;
    const localNameValue = node.localName;
    const nodeNameValue = node.nodeName;
    let tag = localNameValue || nodeNameValue;
    if (tag !== "#text") {
      tag = tag.toUpperCase();
    }
    const virtualElement = {
      nodeId,
      tag,
      attributes,
      childNodes: [],
      realElement: node,
      parent
    };
    if (node instanceof this.domRunner.getWindow().Text && node.textContent) {
      virtualElement.textContent = node.textContent;
    }
    this.nodeToNodeId.set(virtualElement, nodeId);
    this.nodeIdToNode.set(nodeId, virtualElement);
    this.realElementToVirtualElement.set(node, virtualElement);
    return [virtualElement, false];
  }
  getVirtualDOMElementForRealElementOrThrow(realElement) {
    const virtualElement = this.realElementToVirtualElement.get(realElement);
    if (!virtualElement) {
      throw new Error(`Virtual element not found for real element`);
    }
    return virtualElement;
  }
  isIgnoredElement(node) {
    if (this.ignoreTextNodes && node instanceof this.domRunner.getWindow().Text) {
      return true;
    } else if (node instanceof this.domRunner.getWindow().HTMLScriptElement) {
      return true;
    } else if (node instanceof this.domRunner.getWindow().Comment) {
      return true;
    }
    return false;
  }
  isIgnoredAttribute(node, attributeName) {
    return attributeName.startsWith("on");
  }
  dispatchRemoteEventFromConnectionId(connectionId, remoteEvent) {
    const domNode = this.nodeIdToNode.get(remoteEvent.nodeId);
    if (!domNode) {
      console.error("Unknown node ID in remote event: " + remoteEvent.nodeId);
      return;
    }
    if (domNode instanceof this.domRunner.getWindow().Text) {
      console.warn("Cannot dispatch remote event to text node");
      return;
    }
    this.domRunner.dispatchRemoteEventFromConnectionId(
      connectionId,
      domNode.realElement,
      remoteEvent
    );
  }
  dispose() {
    clearInterval(this.documentTimeIntervalTimer);
    this.domRunner.dispose();
  }
  getDocumentTime() {
    return this.domRunner.getDocumentTime();
  }
};
export {
  JSDOMRunner,
  JSDOMRunnerFactory,
  ObservableDOM
};
//# sourceMappingURL=index.js.map
