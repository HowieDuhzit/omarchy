// src/MMLDocumentsServer.ts
import fs from "fs";
import path from "path";
import url from "url";
import { EditableNetworkedDOM, LocalObservableDOMFactory } from "@mml-io/networked-dom-server";
import { watch } from "chokidar";
import micromatch from "micromatch";
var getMmlDocumentContent = (documentPath) => {
  return fs.readFileSync(documentPath, { encoding: "utf8", flag: "r" });
};
var MMLDocumentsServer = class {
  constructor(directory, watchPattern) {
    this.directory = directory;
    this.watchPattern = watchPattern;
    this.watch();
  }
  documents = /* @__PURE__ */ new Map();
  watcher;
  watchPattern;
  dispose() {
    for (const { document } of this.documents.values()) {
      document.dispose();
    }
    this.documents.clear();
    this.watcher.close();
  }
  handle(filename, ws) {
    var _a;
    const document = (_a = this.documents.get(filename)) == null ? void 0 : _a.document;
    if (!document) {
      ws.close();
      return;
    }
    document.addWebSocket(ws);
    ws.on("close", () => {
      document.removeWebSocket(ws);
    });
  }
  watch() {
    this.watcher = watch(this.directory, {
      ignoreInitial: false,
      ignored: (checkPath, stats) => {
        if (!stats || !stats.isFile()) {
          return false;
        }
        return !micromatch.isMatch(checkPath, this.watchPattern);
      },
      persistent: true
    });
    this.watcher.on("add", (fullPath, stats) => {
      if (!stats || !stats.isFile()) {
        return;
      }
      const relativePath = path.relative(this.directory, fullPath);
      console.log(`MML Document '${relativePath}' has been added`);
      const contents = getMmlDocumentContent(fullPath);
      const document = new EditableNetworkedDOM(
        url.pathToFileURL(fullPath).toString(),
        LocalObservableDOMFactory
      );
      document.load(contents);
      const currentData = {
        documentPath: fullPath,
        document
      };
      this.documents.set(relativePath, currentData);
    }).on("change", (fullPath) => {
      const relativePath = path.relative(this.directory, fullPath);
      console.log(`MML Document '${relativePath}' has been changed`);
      const contents = getMmlDocumentContent(fullPath);
      const documentState = this.documents.get(relativePath);
      if (!documentState) {
        console.error(`MML Document '${relativePath}' not found`);
        return;
      }
      documentState.document.load(contents);
    }).on("unlink", (fullPath) => {
      const relativePath = path.relative(this.directory, fullPath);
      console.log(`MML Document '${relativePath}' has been removed`);
      const documentState = this.documents.get(relativePath);
      if (!documentState) {
        console.error(`MML Document '${relativePath}' not found`);
        return;
      }
      documentState.document.dispose();
      this.documents.delete(relativePath);
    }).on("error", (error) => {
      console.error("Error whilst watching directory", error);
    });
  }
};

// src/Networked3dWebExperienceServer.ts
import {
  UserNetworkingServer
} from "@mml-io/3d-web-user-networking";
import cors from "cors";
import express from "express";

// src/websocketDirectoryChangeListener.ts
import { watch as watch2 } from "chokidar";
function websocketDirectoryChangeListener(app, options) {
  const listeningClients = /* @__PURE__ */ new Set();
  watch2(options.directory).on("all", () => {
    for (const client of listeningClients) {
      client.send("change");
    }
  });
  app.ws(options.websocketPath, (ws) => {
    listeningClients.add(ws);
    ws.on("close", () => {
      listeningClients.delete(ws);
    });
  });
}

// src/Networked3dWebExperienceServer.ts
var defaultSessionTokenPlaceholder = "SESSION.TOKEN.PLACEHOLDER";
var Networked3dWebExperienceServer = class {
  constructor(config) {
    this.config = config;
    if (this.config.mmlServing) {
      const { documentsWatchPath, documentsDirectoryRoot } = this.config.mmlServing;
      this.mmlDocumentsServer = new MMLDocumentsServer(documentsDirectoryRoot, documentsWatchPath);
    }
    this.userNetworkingServer = new UserNetworkingServer({
      legacyAdapterEnabled: true,
      onClientConnect: (clientId, sessionToken, userIdentityPresentedOnConnection) => {
        return this.config.userAuthenticator.onClientConnect(
          clientId,
          sessionToken,
          userIdentityPresentedOnConnection
        );
      },
      onClientUserIdentityUpdate: (clientId, userIdentity) => {
        return this.config.userAuthenticator.onClientUserIdentityUpdate(clientId, userIdentity);
      },
      onClientDisconnect: (clientId) => {
        this.config.userAuthenticator.onClientDisconnect(clientId);
      }
    });
  }
  userNetworkingServer;
  mmlDocumentsServer;
  updateUserCharacter(clientId, userData) {
    console.log(`Initiate server-side update of client ${clientId}`);
    this.userNetworkingServer.updateUserCharacter(clientId, userData);
  }
  dispose(error) {
    this.userNetworkingServer.dispose(error);
    if (this.mmlDocumentsServer) {
      this.mmlDocumentsServer.dispose();
    }
  }
  registerExpressRoutes(app) {
    app.ws(this.config.networkPath, (ws) => {
      this.userNetworkingServer.connectClient(ws);
    });
    const webClientServing = this.config.webClientServing;
    if (webClientServing) {
      app.get(webClientServing.indexUrl, async (req, res) => {
        const token = await this.config.userAuthenticator.generateAuthorizedSessionToken(req);
        if (!token) {
          res.send("Error: Could not generate token");
          return;
        }
        const authorizedDemoIndexContent = webClientServing.indexContent.replace(
          webClientServing.sessionTokenPlaceholder || defaultSessionTokenPlaceholder,
          token
        );
        res.send(authorizedDemoIndexContent);
      });
      app.use(webClientServing.clientUrl, express.static(webClientServing.clientBuildDir));
      if (webClientServing.clientWatchWebsocketPath) {
        websocketDirectoryChangeListener(app, {
          directory: webClientServing.clientBuildDir,
          websocketPath: webClientServing.clientWatchWebsocketPath
        });
      }
    }
    const mmlDocumentsServer = this.mmlDocumentsServer;
    const mmlServing = this.config.mmlServing;
    if (mmlServing && mmlDocumentsServer) {
      app.ws(`${mmlServing.documentsUrl}*`, (ws, req) => {
        const path2 = req.params[0];
        console.log("document requested", { path: path2 });
        mmlDocumentsServer.handle(path2, ws);
      });
    }
    if (this.config.assetServing) {
      app.use(
        this.config.assetServing.assetsUrl,
        cors(),
        express.static(this.config.assetServing.assetsDir)
      );
    }
  }
};
export {
  MMLDocumentsServer,
  Networked3dWebExperienceServer,
  defaultSessionTokenPlaceholder,
  websocketDirectoryChangeListener
};
//# sourceMappingURL=index.js.map
