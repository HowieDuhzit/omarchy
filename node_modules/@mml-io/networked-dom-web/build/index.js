// src/DOMSanitizer.ts
var DOMSanitizer = class _DOMSanitizer {
  static sanitise(node, options = {}) {
    if (node.getAttributeNames) {
      for (const attr of node.getAttributeNames()) {
        if (!_DOMSanitizer.IsValidAttributeName(attr)) {
          node.removeAttribute(attr);
        }
      }
    }
    if (node instanceof HTMLElement) {
      if (options.tagPrefix) {
        const tag = node.nodeName.toLowerCase();
        if (!tag.startsWith(options.tagPrefix.toLowerCase())) {
          node = _DOMSanitizer.replaceNodeTagName(
            node,
            options.replacementTagPrefix ? options.replacementTagPrefix + tag : `x-${tag}`
          );
        }
      }
    }
    if (node.nodeName === "SCRIPT" || node.nodeName === "OBJECT" || node.nodeName === "IFRAME") {
      node.innerHTML = "";
      _DOMSanitizer.stripAllAttributes(node);
    } else {
      if (node.getAttributeNames) {
        for (const attr of node.getAttributeNames()) {
          if (!_DOMSanitizer.shouldAcceptAttribute(attr)) {
            node.removeAttribute(attr);
          }
        }
      }
      for (let i = 0; i < node.childNodes.length; i++) {
        _DOMSanitizer.sanitise(node.childNodes[i], options);
      }
    }
    return node;
  }
  static replaceNodeTagName(node, newTagName) {
    var _a;
    const replacementNode = document.createElement(newTagName);
    let index;
    while (node.firstChild) {
      replacementNode.appendChild(node.firstChild);
    }
    for (index = node.attributes.length - 1; index >= 0; --index) {
      replacementNode.setAttribute(node.attributes[index].name, node.attributes[index].value);
    }
    (_a = node.parentNode) == null ? void 0 : _a.replaceChild(replacementNode, node);
    return replacementNode;
  }
  static stripAllAttributes(node) {
    if (node.getAttributeNames) {
      for (const attr of node.getAttributeNames()) {
        node.removeAttribute(attr);
      }
    }
  }
  static IsASCIIDigit(c) {
    return c >= "0" && c <= "9";
  }
  static IsASCIIAlpha(c) {
    return c >= "a" && c <= "z" || c >= "A" && c <= "Z";
  }
  static IsValidAttributeName(characters) {
    const c = characters[0];
    if (!(_DOMSanitizer.IsASCIIAlpha(c) || c === ":" || c === "_")) {
      return false;
    }
    for (let i = 1; i < characters.length; i++) {
      const c2 = characters[i];
      if (!(_DOMSanitizer.IsASCIIDigit(c2) || _DOMSanitizer.IsASCIIAlpha(c2) || c2 === ":" || c2 === "_" || c2 === "-" || c2 === ".")) {
        return false;
      }
    }
    return true;
  }
  static shouldAcceptAttribute(attribute) {
    if (!_DOMSanitizer.IsValidAttributeName(attribute)) {
      console.warn("Invalid attribute name", attribute);
      return false;
    }
    return !attribute.startsWith("on");
  }
};

// src/NetworkedDOMWebsocket.ts
import {
  isNetworkedDOMProtocolSubProtocol_v0_2,
  networkedDOMProtocolSubProtocol_v0_1,
  networkedDOMProtocolSubProtocol_v0_2_SubVersionsList
} from "@mml-io/networked-dom-protocol";

// src/ElementUtils.ts
var ALWAYS_DISALLOWED_TAGS = /* @__PURE__ */ new Set(["foreignobject", "iframe", "script"]);
var SVG_TAG_NAMES_ADJUSTMENT_MAP = new Map(
  [
    "svg",
    "defs",
    "g",
    "text",
    "filter",
    "stop",
    "path",
    "rect",
    "line",
    "circle",
    "animate",
    "altGlyph",
    "altGlyphDef",
    "altGlyphItem",
    "animateColor",
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feDropShadow",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDistantLight",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "glyphRef",
    "linearGradient",
    "radialGradient",
    "textPath"
    // `foreignObject` is explicitly disallowed because it allows injecting arbitrary HTML
    // "foreignObject",
  ].map((tn) => [tn.toLowerCase(), tn])
);
var SVG_ATTRS_ADJUSTMENT_MAP = new Map(
  [
    "attributeName",
    "attributeType",
    "baseFrequency",
    "baseProfile",
    "calcMode",
    "clipPathUnits",
    "diffuseConstant",
    "edgeMode",
    "filterUnits",
    "glyphRef",
    "gradientTransform",
    "gradientUnits",
    "kernelMatrix",
    "kernelUnitLength",
    "keyPoints",
    "keySplines",
    "keyTimes",
    "lengthAdjust",
    "limitingConeAngle",
    "markerHeight",
    "markerUnits",
    "markerWidth",
    "maskContentUnits",
    "maskUnits",
    "numOctaves",
    "pathLength",
    "patternContentUnits",
    "patternTransform",
    "patternUnits",
    "pointsAtX",
    "pointsAtY",
    "pointsAtZ",
    "preserveAlpha",
    "preserveAspectRatio",
    "primitiveUnits",
    "refX",
    "refY",
    "repeatCount",
    "repeatDur",
    "requiredExtensions",
    "requiredFeatures",
    "specularConstant",
    "specularExponent",
    "spreadMethod",
    "startOffset",
    "stdDeviation",
    "stitchTiles",
    "surfaceScale",
    "systemLanguage",
    "tableValues",
    "targetX",
    "targetY",
    "textLength",
    "viewBox",
    "viewTarget",
    "xChannelSelector",
    "yChannelSelector",
    "zoomAndPan"
  ].map((attr) => [attr.toLowerCase(), attr])
);
function remapAttributeName(attrName) {
  const remapped = SVG_ATTRS_ADJUSTMENT_MAP.get(attrName.toLowerCase());
  if (remapped) {
    return remapped;
  }
  return attrName;
}
function createElementWithSVGSupport(tag, options = {}) {
  let filteredTag = tag.toLowerCase();
  if (ALWAYS_DISALLOWED_TAGS.has(filteredTag.toLowerCase())) {
    console.error("Disallowing tag", filteredTag);
    filteredTag = options.replacementTagPrefix ? options.replacementTagPrefix + tag : `x-${tag}`;
  }
  let svgTagMapping;
  if (options.allowSVGElements) {
    svgTagMapping = SVG_TAG_NAMES_ADJUSTMENT_MAP.get(filteredTag);
  }
  if (svgTagMapping) {
    filteredTag = svgTagMapping;
    const xmlns = "http://www.w3.org/2000/svg";
    return document.createElementNS(xmlns, filteredTag);
  } else {
    if (options.tagPrefix) {
      if (!tag.toLowerCase().startsWith(options.tagPrefix.toLowerCase())) {
        filteredTag = options.replacementTagPrefix ? options.replacementTagPrefix + tag : `x-${tag}`;
      }
    }
    return document.createElement(filteredTag);
  }
}
function setElementAttribute(element, key, value) {
  if (DOMSanitizer.shouldAcceptAttribute(key)) {
    const remappedKey = remapAttributeName(key);
    element.setAttribute(remappedKey, value);
  }
}
function getChildrenTarget(parent) {
  let targetForChildren = parent;
  if (parent.getPortalElement) {
    targetForChildren = parent.getPortalElement();
  }
  return targetForChildren;
}
function getRemovalTarget(parent) {
  let targetForRemoval = parent;
  if (parent.getPortalElement) {
    targetForRemoval = parent.getPortalElement();
  }
  return targetForRemoval;
}

// src/NetworkedDOMWebsocketV01Adapter.ts
var NetworkedDOMWebsocketV01Adapter = class {
  constructor(websocket, parentElement, connectedCallback, timeCallback, options = {}) {
    this.websocket = websocket;
    this.parentElement = parentElement;
    this.connectedCallback = connectedCallback;
    this.timeCallback = timeCallback;
    this.options = options;
    this.idToElement = /* @__PURE__ */ new Map();
    this.elementToId = /* @__PURE__ */ new Map();
    this.currentRoot = null;
    this.websocket.binaryType = "arraybuffer";
  }
  handleEvent(element, event) {
    const nodeId = this.elementToId.get(element);
    if (nodeId === void 0 || nodeId === null) {
      throw new Error("Element not found");
    }
    const detailWithoutElement = {
      ...event.detail
    };
    delete detailWithoutElement.element;
    const remoteEvent = {
      type: "event",
      nodeId,
      name: event.type,
      bubbles: event.bubbles,
      params: detailWithoutElement
    };
    this.send(remoteEvent);
  }
  send(fromClientMessage) {
    this.websocket.send(JSON.stringify(fromClientMessage));
  }
  clearContents() {
    this.idToElement.clear();
    this.elementToId.clear();
    if (this.currentRoot) {
      this.currentRoot.remove();
      this.currentRoot = null;
      return true;
    }
    return false;
  }
  receiveMessage(event) {
    try {
      const messages = JSON.parse(event.data);
      for (const message of messages) {
        switch (message.type) {
          case "error":
            console.error("Error from server", message);
            break;
          case "warning":
            console.warn("Warning from server", message);
            break;
          default: {
            if (message.documentTime) {
              if (this.timeCallback) {
                this.timeCallback(message.documentTime);
              }
            }
            switch (message.type) {
              case "snapshot":
                this.handleSnapshot(message);
                this.connectedCallback();
                break;
              case "attributeChange":
                this.handleAttributeChange(message);
                break;
              case "childrenChanged":
                this.handleChildrenChanged(message);
                break;
              case "textChanged":
                this.handleTextChanged(message);
                break;
              case "ping":
                this.send({
                  type: "pong",
                  pong: message.ping
                });
                break;
              default:
                console.warn("unknown message type", message);
                break;
            }
          }
        }
      }
    } catch (e) {
      console.error("Error handling websocket message", e);
      this.websocket.close(1011, "Error handling websocket message");
      throw e;
    }
  }
  handleTextChanged(message) {
    const { nodeId, text } = message;
    if (nodeId === void 0 || nodeId === null) {
      console.warn("No nodeId in textChanged message");
      return;
    }
    const node = this.idToElement.get(nodeId);
    if (!node) {
      throw new Error("No node found for textChanged message");
    }
    if (!isText(node, this.parentElement)) {
      throw new Error("Node for textChanged message is not a Text node");
    }
    node.textContent = text;
  }
  handleChildrenChanged(message) {
    const { nodeId, addedNodes, removedNodes, previousNodeId } = message;
    if (nodeId === void 0 || nodeId === null) {
      console.warn("No nodeId in childrenChanged message");
      return;
    }
    const parent = this.idToElement.get(nodeId);
    if (!parent) {
      throw new Error("No parent found for childrenChanged message");
    }
    if (!isHTMLElement(parent, this.parentElement)) {
      throw new Error("Parent is not an HTMLElement (that supports children)");
    }
    const targetForChildren = getChildrenTarget(parent);
    let nextElement = null;
    let previousElement = null;
    if (previousNodeId) {
      previousElement = this.idToElement.get(previousNodeId);
      if (!previousElement) {
        throw new Error("No previous element found for childrenChanged message");
      }
      nextElement = previousElement.nextSibling;
    }
    const elementsToAdd = [];
    for (const addedNode of addedNodes) {
      const childElement = this.handleNewElement(addedNode);
      if (childElement) {
        elementsToAdd.push(childElement);
      }
    }
    if (elementsToAdd.length) {
      if (previousElement) {
        if (nextElement) {
          const docFrag = new DocumentFragment();
          docFrag.append(...elementsToAdd);
          targetForChildren.insertBefore(docFrag, nextElement);
        } else {
          targetForChildren.append(...elementsToAdd);
        }
      } else {
        targetForChildren.prepend(...elementsToAdd);
      }
    }
    for (const removedNode of removedNodes) {
      const childElement = this.idToElement.get(removedNode);
      if (!childElement) {
        throw new Error(`Child element not found: ${removedNode}`);
      }
      this.elementToId.delete(childElement);
      this.idToElement.delete(removedNode);
      const targetForRemoval = getRemovalTarget(parent);
      targetForRemoval.removeChild(childElement);
      if (isHTMLElement(childElement, this.parentElement)) {
        this.removeChildElementIds(childElement);
      }
    }
  }
  removeChildElementIds(parent) {
    const portal = getChildrenTarget(parent);
    if (portal !== parent) {
      this.removeChildElementIds(portal);
    }
    for (let i = 0; i < parent.childNodes.length; i++) {
      const child = parent.childNodes[i];
      const childId = this.elementToId.get(child);
      if (!childId) {
        console.error("Inner child of removed element had no id", child);
      } else {
        this.elementToId.delete(child);
        this.idToElement.delete(childId);
      }
      this.removeChildElementIds(child);
    }
  }
  handleSnapshot(message) {
    if (this.currentRoot) {
      this.currentRoot.remove();
      this.currentRoot = null;
      this.elementToId.clear();
      this.idToElement.clear();
    }
    const element = this.handleNewElement(message.snapshot);
    if (!element) {
      throw new Error("Snapshot element not created");
    }
    if (!isHTMLElement(element, this.parentElement)) {
      throw new Error("Snapshot element is not an HTMLElement");
    }
    this.currentRoot = element;
    this.parentElement.append(element);
  }
  handleAttributeChange(message) {
    const { nodeId, attribute, newValue } = message;
    if (nodeId === void 0 || nodeId === null) {
      console.warn("No nodeId in attributeChange message");
      return;
    }
    const element = this.idToElement.get(nodeId);
    if (element) {
      if (isHTMLElement(element, this.parentElement)) {
        if (newValue === null) {
          element.removeAttribute(attribute);
        } else {
          setElementAttribute(element, attribute, newValue);
        }
      } else {
        console.error("Element is not an HTMLElement and cannot support attributes", element);
      }
    } else {
      console.error("No element found for attributeChange message");
    }
  }
  handleNewElement(message) {
    if (message.type === "text") {
      const { nodeId: nodeId2, text: text2 } = message;
      const textNode = document.createTextNode("");
      textNode.textContent = text2;
      this.idToElement.set(nodeId2, textNode);
      this.elementToId.set(textNode, nodeId2);
      return textNode;
    }
    const { tag, nodeId, attributes, children, text } = message;
    if (nodeId === void 0 || nodeId === null) {
      console.warn("No nodeId in handleNewElement message", message);
      return null;
    }
    if (this.idToElement.has(nodeId)) {
      console.error(
        "Received nodeId to add that is already present",
        nodeId,
        this.idToElement.get(nodeId)
      );
    }
    if (tag === "#text") {
      const textNode = document.createTextNode("");
      textNode.textContent = text || null;
      this.idToElement.set(nodeId, textNode);
      this.elementToId.set(textNode, nodeId);
      return textNode;
    }
    let element;
    try {
      element = createElementWithSVGSupport(tag, this.options);
    } catch (e) {
      console.error(`Error creating element: (${tag})`, e);
      element = document.createElement("x-div");
    }
    this.idToElement.set(nodeId, element);
    this.elementToId.set(element, nodeId);
    for (const key in attributes) {
      const value = attributes[key];
      setElementAttribute(element, key, value);
    }
    if (children) {
      for (const child of children) {
        const childElement = this.handleNewElement(child);
        if (childElement) {
          element.append(childElement);
        }
      }
    }
    return element;
  }
};

// src/NetworkedDOMWebsocketV02Adapter.ts
import {
  BufferReader,
  BufferWriter,
  decodeServerMessages,
  encodeClientMessage,
  getNetworkedDOMProtocolSubProtocol_v0_2SubversionOrThrow
} from "@mml-io/networked-dom-protocol";
var connectionId = 1;
var hiddenTag = "x-hidden";
var NetworkedDOMWebsocketV02Adapter = class {
  constructor(websocket, parentElement, connectedCallback, timeCallback, options = {}) {
    this.websocket = websocket;
    this.parentElement = parentElement;
    this.connectedCallback = connectedCallback;
    this.timeCallback = timeCallback;
    this.options = options;
    this.idToElement = /* @__PURE__ */ new Map();
    this.elementToId = /* @__PURE__ */ new Map();
    this.placeholderToId = /* @__PURE__ */ new Map();
    this.hiddenPlaceholderElements = /* @__PURE__ */ new Map();
    this.currentRoot = null;
    this.batchMode = false;
    this.batchMessages = [];
    this.websocket.binaryType = "arraybuffer";
    this.protocolSubversion = getNetworkedDOMProtocolSubProtocol_v0_2SubversionOrThrow(
      websocket.protocol
    );
    this.send({
      type: "connectUsers",
      connectionIds: [connectionId],
      connectionTokens: [this.options.connectionToken ?? null]
    });
  }
  handleEvent(element, event) {
    const nodeId = this.elementToId.get(element);
    if (nodeId === void 0 || nodeId === null) {
      console.error("Element not found for event", { nodeId, element, event });
      return;
    }
    const detailWithoutElement = {
      ...event.detail
    };
    delete detailWithoutElement.element;
    const remoteEvent = {
      type: "event",
      nodeId,
      connectionId,
      name: event.type,
      bubbles: event.bubbles,
      params: detailWithoutElement
    };
    this.send(remoteEvent);
  }
  send(message) {
    const writer = new BufferWriter(256);
    encodeClientMessage(message, writer, this.protocolSubversion);
    this.websocket.send(writer.getBuffer());
  }
  clearContents() {
    this.idToElement.clear();
    this.elementToId.clear();
    if (this.currentRoot) {
      this.currentRoot.remove();
      this.currentRoot = null;
      return true;
    }
    return false;
  }
  receiveMessage(event) {
    try {
      const reader = new BufferReader(new Uint8Array(event.data));
      const messages = decodeServerMessages(reader);
      for (const message of messages) {
        if (message.type === "batchStart") {
          this.batchMode = true;
        } else if (message.type === "batchEnd") {
          this.batchMode = false;
          for (const batchedMessage of this.batchMessages) {
            this.applyMessage(batchedMessage);
          }
          this.batchMessages = [];
        } else {
          if (this.batchMode) {
            this.batchMessages.push(message);
          } else {
            this.applyMessage(message);
          }
        }
      }
    } catch (e) {
      console.error("Error handling websocket message", e);
      this.websocket.close(1011, "Error handling websocket message");
      throw e;
    }
  }
  applyMessage(message) {
    switch (message.type) {
      case "error":
        console.error("Error from server", message);
        break;
      case "warning":
        console.warn("Warning from server", message);
        break;
      case "snapshot":
        this.handleSnapshot(message);
        this.connectedCallback();
        break;
      case "attributesChanged":
        this.handleAttributeChange(message);
        break;
      case "documentTime":
        this.handleDocumentTime(message);
        break;
      case "childrenAdded":
        this.handleChildrenAdded(message);
        break;
      case "changeHiddenFrom":
        this.handleChangeHiddenFrom(message);
        break;
      case "changeVisibleTo":
        break;
      case "childrenRemoved":
        this.handleChildrenRemoved(message);
        break;
      case "textChanged":
        this.handleTextChanged(message);
        break;
      case "ping":
        this.handlePing(message);
        break;
      default:
        console.warn("unknown message type", message);
        break;
    }
  }
  handleTextChanged(message) {
    const { nodeId, text } = message;
    if (nodeId === void 0 || nodeId === null) {
      console.warn("No nodeId in textChanged message");
      return;
    }
    const node = this.idToElement.get(nodeId);
    if (!node) {
      throw new Error("No node found for textChanged message");
    }
    if (!isText(node, this.parentElement)) {
      throw new Error("Node for textChanged message is not a Text node");
    }
    node.textContent = text;
  }
  handleChangeHiddenFrom(message) {
    const { nodeId, addHiddenFrom, removeHiddenFrom } = message;
    const node = this.idToElement.get(nodeId);
    const hiddenElement = this.hiddenPlaceholderElements.get(nodeId);
    if (addHiddenFrom.length > 0 && addHiddenFrom.indexOf(connectionId) !== -1) {
      if (hiddenElement) {
        return;
      }
      if (!node) {
        throw new Error("No node found for changeHiddenFrom message");
      }
      const parent = node.parentElement;
      if (!parent) {
        throw new Error("Node has no parent");
      }
      const placeholder = document.createElement(hiddenTag);
      parent.replaceChild(placeholder, node);
      this.hiddenPlaceholderElements.set(nodeId, { placeholder, element: node });
      this.placeholderToId.set(placeholder, nodeId);
    } else if (removeHiddenFrom.length > 0 && removeHiddenFrom.indexOf(connectionId) !== -1) {
      if (!hiddenElement) {
        return;
      }
      const { placeholder, element } = hiddenElement;
      const parent = placeholder.parentElement;
      if (!parent) {
        throw new Error("Placeholder has no parent");
      }
      parent.replaceChild(element, placeholder);
      this.hiddenPlaceholderElements.delete(nodeId);
      this.placeholderToId.delete(placeholder);
    }
  }
  handleChildrenAdded(message) {
    const { nodeId, addedNodes, previousNodeId } = message;
    if (nodeId === void 0 || nodeId === null) {
      console.warn("No nodeId in childrenChanged message");
      return;
    }
    let parent = this.idToElement.get(nodeId);
    if (!parent) {
      throw new Error("No parent found for childrenChanged message");
    }
    const hiddenParent = this.hiddenPlaceholderElements.get(nodeId);
    if (hiddenParent) {
      parent = hiddenParent.element;
    }
    if (!isHTMLElement(parent, this.parentElement)) {
      throw new Error("Parent is not an HTMLElement (that supports children)");
    }
    const targetForChildren = getChildrenTarget(parent);
    let nextElement = null;
    let previousElement = null;
    if (previousNodeId) {
      previousElement = this.idToElement.get(previousNodeId);
      if (!previousElement) {
        throw new Error("No previous element found for childrenChanged message");
      }
      nextElement = previousElement.nextSibling;
    }
    const elementsToAdd = [];
    for (const addedNode of addedNodes) {
      const childElement = this.handleNewElement(addedNode);
      if (childElement) {
        elementsToAdd.push(childElement);
      }
    }
    if (elementsToAdd.length) {
      if (previousElement) {
        if (nextElement) {
          const docFrag = new DocumentFragment();
          docFrag.append(...elementsToAdd);
          targetForChildren.insertBefore(docFrag, nextElement);
        } else {
          targetForChildren.append(...elementsToAdd);
        }
      } else {
        targetForChildren.prepend(...elementsToAdd);
      }
    }
  }
  handleChildrenRemoved(message) {
    const { nodeId, removedNodes } = message;
    if (nodeId === void 0 || nodeId === null) {
      console.warn("No nodeId in childrenChanged message");
      return;
    }
    const parent = this.idToElement.get(nodeId);
    if (!parent) {
      throw new Error("No parent found for childrenChanged message");
    }
    if (!isHTMLElement(parent, this.parentElement)) {
      throw new Error("Parent is not an HTMLElement (that supports children)");
    }
    for (const removedNode of removedNodes) {
      const childElement = this.idToElement.get(removedNode);
      if (!childElement) {
        throw new Error(`Child element not found: ${removedNode}`);
      }
      this.elementToId.delete(childElement);
      this.idToElement.delete(removedNode);
      const targetForRemoval = getRemovalTarget(parent);
      const hiddenElement = this.hiddenPlaceholderElements.get(removedNode);
      if (hiddenElement) {
        const placeholder = hiddenElement.placeholder;
        try {
          targetForRemoval.removeChild(placeholder);
        } catch (e) {
          console.error("error removing placeholder child", e);
        }
        this.hiddenPlaceholderElements.delete(removedNode);
        this.placeholderToId.delete(placeholder);
        if (isHTMLElement(childElement, this.parentElement)) {
          this.removeChildElementIds(childElement);
        }
      } else {
        try {
          targetForRemoval.removeChild(childElement);
        } catch (e) {
          console.error("error removing child", e);
        }
        if (isHTMLElement(childElement, this.parentElement)) {
          this.removeChildElementIds(childElement);
        }
      }
    }
  }
  removeChildElementIds(parent) {
    const portal = getChildrenTarget(parent);
    if (portal !== parent) {
      this.removeChildElementIds(portal);
    }
    const childNodes = parent.childNodes;
    for (let i = 0; i < childNodes.length; i++) {
      const child = childNodes[i];
      const childId = this.elementToId.get(child);
      if (!childId) {
        const placeholderId = this.placeholderToId.get(child);
        if (placeholderId) {
          const childElement = this.idToElement.get(placeholderId);
          if (childElement) {
            this.elementToId.delete(childElement);
          } else {
            console.error(
              "Inner child of removed placeholder element not found by id",
              placeholderId
            );
          }
          this.idToElement.delete(placeholderId);
          this.placeholderToId.delete(child);
          this.hiddenPlaceholderElements.delete(placeholderId);
          this.removeChildElementIds(childElement);
        } else {
          console.error(
            "Inner child of removed element had no id",
            child.outerHTML
          );
        }
      } else {
        this.elementToId.delete(child);
        this.idToElement.delete(childId);
        this.removeChildElementIds(child);
      }
    }
  }
  handleSnapshot(message) {
    var _a;
    if (this.currentRoot) {
      this.currentRoot.remove();
      this.currentRoot = null;
      this.elementToId.clear();
      this.idToElement.clear();
    }
    (_a = this.timeCallback) == null ? void 0 : _a.call(this, message.documentTime);
    const element = this.handleNewElement(message.snapshot);
    if (!element) {
      throw new Error("Snapshot element not created");
    }
    if (!isHTMLElement(element, this.parentElement)) {
      throw new Error("Snapshot element is not an HTMLElement");
    }
    this.currentRoot = element;
    this.parentElement.append(element);
  }
  handleDocumentTime(message) {
    var _a;
    (_a = this.timeCallback) == null ? void 0 : _a.call(this, message.documentTime);
  }
  handleAttributeChange(message) {
    const { nodeId, attributes } = message;
    if (nodeId === void 0 || nodeId === null) {
      console.warn("No nodeId in attributeChange message");
      return;
    }
    let element = this.idToElement.get(nodeId);
    const hiddenElement = this.hiddenPlaceholderElements.get(nodeId);
    if (hiddenElement) {
      element = hiddenElement.element;
    }
    if (element) {
      if (isHTMLElement(element, this.parentElement)) {
        for (const [key, newValue] of attributes) {
          if (newValue === null) {
            element.removeAttribute(key);
          } else {
            setElementAttribute(element, key, newValue);
          }
        }
      } else {
        console.error("Element is not an HTMLElement and cannot support attributes", element);
      }
    } else {
      console.error("No element found for attributeChange message");
    }
  }
  handleNewElement(message) {
    if (message.type === "text") {
      const { nodeId: nodeId2, text: text2 } = message;
      const textNode = document.createTextNode("");
      textNode.textContent = text2;
      this.idToElement.set(nodeId2, textNode);
      this.elementToId.set(textNode, nodeId2);
      return textNode;
    }
    const { tag, nodeId, attributes, children, text, hiddenFrom } = message;
    if (this.idToElement.has(nodeId)) {
      console.error(
        "Received nodeId to add that is already present",
        nodeId,
        this.idToElement.get(nodeId)
      );
      throw new Error("Received nodeId to add that is already present: " + nodeId);
    }
    if (tag === "#text") {
      const textNode = document.createTextNode("");
      textNode.textContent = text || null;
      this.idToElement.set(nodeId, textNode);
      this.elementToId.set(textNode, nodeId);
      return textNode;
    }
    let element;
    try {
      element = createElementWithSVGSupport(tag, this.options);
    } catch (e) {
      console.error(`Error creating element: (${tag})`, e);
      element = document.createElement("x-div");
    }
    for (const [key, value] of attributes) {
      if (value !== null) {
        setElementAttribute(element, key, value);
      }
    }
    if (children) {
      for (const child of children) {
        const childElement = this.handleNewElement(child);
        if (childElement) {
          element.append(childElement);
        }
      }
    }
    if (hiddenFrom && hiddenFrom.length > 0 && hiddenFrom.indexOf(connectionId) !== -1) {
      const placeholder = document.createElement(hiddenTag);
      this.hiddenPlaceholderElements.set(nodeId, { placeholder, element });
      this.placeholderToId.set(placeholder, nodeId);
      this.idToElement.set(nodeId, element);
      this.elementToId.set(element, nodeId);
      return placeholder;
    } else {
      this.idToElement.set(nodeId, element);
      this.elementToId.set(element, nodeId);
      return element;
    }
  }
  handlePing(message) {
    var _a;
    (_a = this.timeCallback) == null ? void 0 : _a.call(this, message.documentTime);
    this.send({
      type: "pong",
      pong: message.ping
    });
  }
};

// src/NetworkedDOMWebsocket.ts
var startingBackoffTimeMilliseconds = 100;
var maximumBackoffTimeMilliseconds = 1e4;
var maximumWebsocketConnectionTimeout = 5e3;
var NetworkedDOMWebsocketStatus = /* @__PURE__ */ ((NetworkedDOMWebsocketStatus2) => {
  NetworkedDOMWebsocketStatus2[NetworkedDOMWebsocketStatus2["Connecting"] = 0] = "Connecting";
  NetworkedDOMWebsocketStatus2[NetworkedDOMWebsocketStatus2["ConnectionOpen"] = 1] = "ConnectionOpen";
  NetworkedDOMWebsocketStatus2[NetworkedDOMWebsocketStatus2["Connected"] = 2] = "Connected";
  NetworkedDOMWebsocketStatus2[NetworkedDOMWebsocketStatus2["Reconnecting"] = 3] = "Reconnecting";
  NetworkedDOMWebsocketStatus2[NetworkedDOMWebsocketStatus2["Disconnected"] = 4] = "Disconnected";
  return NetworkedDOMWebsocketStatus2;
})(NetworkedDOMWebsocketStatus || {});
function NetworkedDOMWebsocketStatusToString(status) {
  switch (status) {
    case 0 /* Connecting */:
      return "Connecting...";
    case 1 /* ConnectionOpen */:
      return "Connection Open";
    case 2 /* Connected */:
      return "Connected";
    case 3 /* Reconnecting */:
      return "Reconnecting...";
    case 4 /* Disconnected */:
      return "Disconnected";
    default:
      return "Unknown";
  }
}
var NetworkedDOMWebsocket = class {
  constructor(url, websocketFactory, parentElement, timeCallback, statusUpdateCallback, options = {}) {
    this.url = url;
    this.websocketFactory = websocketFactory;
    this.parentElement = parentElement;
    this.timeCallback = timeCallback;
    this.statusUpdateCallback = statusUpdateCallback;
    this.options = options;
    this.websocket = null;
    this.websocketAdapter = null;
    this.stopped = false;
    this.backoffTime = startingBackoffTimeMilliseconds;
    this.status = null;
    this.setStatus(0 /* Connecting */);
    this.startWebSocketConnectionAttempt();
  }
  static createWebSocket(url) {
    return new WebSocket(url, [
      ...networkedDOMProtocolSubProtocol_v0_2_SubVersionsList,
      networkedDOMProtocolSubProtocol_v0_1
    ]);
  }
  setStatus(status) {
    if (this.status !== status) {
      this.status = status;
      if (this.statusUpdateCallback) {
        this.statusUpdateCallback(status);
      }
    }
  }
  createWebsocketWithTimeout(timeout) {
    return new Promise((resolve, reject) => {
      const websocket = this.websocketFactory(this.url);
      const timeoutId = setTimeout(() => {
        reject(new Error("websocket connection timed out"));
        websocket.close();
      }, timeout);
      websocket.binaryType = "arraybuffer";
      websocket.addEventListener("open", () => {
        clearTimeout(timeoutId);
        this.websocket = websocket;
        const isV02 = isNetworkedDOMProtocolSubProtocol_v0_2(websocket.protocol);
        let websocketAdapter;
        if (isV02) {
          websocketAdapter = new NetworkedDOMWebsocketV02Adapter(
            websocket,
            this.parentElement,
            () => {
              this.backoffTime = startingBackoffTimeMilliseconds;
              this.setStatus(2 /* Connected */);
            },
            this.timeCallback,
            this.options
          );
        } else {
          websocketAdapter = new NetworkedDOMWebsocketV01Adapter(
            websocket,
            this.parentElement,
            () => {
              this.backoffTime = startingBackoffTimeMilliseconds;
              this.setStatus(2 /* Connected */);
            },
            this.timeCallback,
            this.options
          );
        }
        this.websocketAdapter = websocketAdapter;
        websocket.addEventListener("message", (event) => {
          if (websocket !== this.websocket) {
            console.log("Ignoring websocket message event because it is no longer current");
            websocket.close();
            return;
          }
          websocketAdapter.receiveMessage(event);
        });
        const onWebsocketClose = async () => {
          let hadContents = false;
          if (this.websocketAdapter) {
            hadContents = this.websocketAdapter.clearContents();
          }
          if (this.stopped) {
            this.setStatus(4 /* Disconnected */);
            return;
          }
          if (!hadContents) {
            await this.waitBackoffTime();
          }
          this.setStatus(3 /* Reconnecting */);
          this.startWebSocketConnectionAttempt();
        };
        websocket.addEventListener("close", () => {
          if (websocket !== this.websocket) {
            console.warn("Ignoring websocket close event because it is no longer current");
            return;
          }
          onWebsocketClose();
        });
        websocket.addEventListener("error", (e) => {
          if (websocket !== this.websocket) {
            console.log("Ignoring websocket error event because it is no longer current");
            return;
          }
          console.error("NetworkedDOMWebsocket error", e);
          onWebsocketClose();
        });
        this.setStatus(1 /* ConnectionOpen */);
        resolve(websocket);
      });
      websocket.addEventListener("error", (e) => {
        clearTimeout(timeoutId);
        reject(e);
      });
    });
  }
  async waitBackoffTime() {
    console.warn(`Websocket connection to '${this.url}' failed: retrying in ${this.backoffTime}ms`);
    await new Promise((resolve) => setTimeout(resolve, this.backoffTime));
    this.backoffTime = Math.min(
      // Introduce a small amount of randomness to prevent clients from retrying in lockstep
      this.backoffTime * (1.5 + Math.random() * 0.5),
      maximumBackoffTimeMilliseconds
    );
  }
  async startWebSocketConnectionAttempt() {
    if (this.stopped) {
      return;
    }
    while (true) {
      if (this.stopped) {
        return;
      }
      try {
        await this.createWebsocketWithTimeout(maximumWebsocketConnectionTimeout);
        break;
      } catch (e) {
        console.error("Websocket connection failed", e);
        this.setStatus(3 /* Reconnecting */);
        await this.waitBackoffTime();
      }
    }
  }
  stop() {
    this.stopped = true;
    if (this.websocket !== null) {
      this.websocket.close();
      this.websocket = null;
    }
  }
  handleEvent(element, event) {
    if (this.websocketAdapter) {
      this.websocketAdapter.handleEvent(element, event);
    }
  }
};
function isHTMLElement(node, rootNode) {
  if (node instanceof HTMLElement || node instanceof Element) {
    return true;
  }
  if (!rootNode.ownerDocument.defaultView) {
    return false;
  }
  return node instanceof rootNode.ownerDocument.defaultView.HTMLElement;
}
function isText(node, rootNode) {
  if (node instanceof Text) {
    return true;
  }
  if (!rootNode.ownerDocument.defaultView) {
    return false;
  }
  return node instanceof rootNode.ownerDocument.defaultView.Text;
}
export {
  DOMSanitizer,
  NetworkedDOMWebsocket,
  NetworkedDOMWebsocketStatus,
  NetworkedDOMWebsocketStatusToString,
  isHTMLElement,
  isText
};
//# sourceMappingURL=index.js.map
