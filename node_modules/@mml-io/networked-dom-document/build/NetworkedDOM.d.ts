import { NetworkedDOMV02Diff } from "@mml-io/networked-dom-protocol";
import { LogMessage, ObservableDOMInterface, ObservableDOMMessage, ObservableDOMParameters, ObservableDOMRemoteEvent, StaticVirtualDOMElement } from "@mml-io/observable-dom-common";
import { VirtualDOMDiffStruct } from "./diffing/calculateStaticVirtualDOMDiff";
import { NetworkedDOMV01Connection } from "./NetworkedDOMV01Connection";
import { NetworkedDOMV02Connection } from "./NetworkedDOMV02Connection";
export type ObservableDOMFactory = (observableDOMParameters: ObservableDOMParameters, callback: (message: ObservableDOMMessage, observableDOM: ObservableDOMInterface) => void) => ObservableDOMInterface;
/**
 * NetworkedDOM is the main class for the networked-dom-document package. It is responsible for managing the state of
 * the document and the connections to the clients.
 *
 * It is constructed with an ObservableDOMFactory, which is responsible for creating the ObservableDOMInterface
 * implementation that is used to run the document.
 */
export declare class NetworkedDOM {
    private visibilityManager;
    private nodeManager;
    private currentConnectionId;
    private connectionIdToNetworkedDOMConnection;
    private networkedDOMV01Connections;
    private networkedDOMV02Connections;
    private webSocketToNetworkedDOMConnection;
    private initialLoad;
    private readonly htmlPath;
    private ignoreTextNodes;
    private documentRoot;
    private observableDOM;
    private documentEffectiveStartTime;
    private latestDocumentTime;
    private pingCounter;
    private logCallback?;
    private disposed;
    constructor(observableDOMFactory: ObservableDOMFactory, htmlPath: string, htmlContents: string, oldInstanceDocumentRoot: StaticVirtualDOMElement | null, onLoad: (domDiff: VirtualDOMDiffStruct | null, networkedDOM: NetworkedDOM) => void, params?: {}, ignoreTextNodes?: boolean, logCallback?: (message: LogMessage) => void);
    static handleWebsocketSubprotocol(protocols: Set<string> | Array<string>): string | false;
    addWebSocket(webSocket: WebSocket): void;
    removeWebSocket(webSocket: WebSocket): void;
    hasWebSocket(webSocket: WebSocket): boolean;
    addExistingNetworkedDOMConnections(networkedDOMConnections: Set<NetworkedDOMV01Connection | NetworkedDOMV02Connection>, domDiff: VirtualDOMDiffStruct | null): void;
    addNetworkedDOMConnection(networkedDOMConnection: NetworkedDOMV01Connection | NetworkedDOMV02Connection): void;
    removeNetworkedDOMConnection(networkedDOMConnection: NetworkedDOMV01Connection | NetworkedDOMV02Connection): void;
    connectUsers(networkedDOMConnection: NetworkedDOMV01Connection | NetworkedDOMV02Connection, addedExternalUserIds: Set<number>): Map<number, number>;
    announceConnectedUsers(userIds: Map<number, string | null>): void;
    disconnectUsers(networkedDOMConnection: NetworkedDOMV02Connection, removedExternalToInternalUserIds: Map<number, number>): Array<NetworkedDOMV02Diff>;
    private defaultLogCallback;
    private sendPings;
    private getInitialV01Snapshot;
    private getInitialV02Snapshot;
    getDocumentTime(): number;
    dispatchRemoteEvent(networkedDOMConnection: NetworkedDOMV01Connection | NetworkedDOMV02Connection, internalConnectionId: number, externalConnectionId: number, remoteEvent: ObservableDOMRemoteEvent): void;
    getSnapshot(): StaticVirtualDOMElement;
    dispose(): void;
    private handleAddedNodes;
    private handleRemovedNodes;
    private handleAttributeMutation;
    private handleAttributeChange;
    private handleVisibleToChange;
    private handleHiddenFromChange;
    private handleCharacterData;
    private calculatePreVisibilityChangeRecords;
    private applyVisibilityAfterChanges;
    private reprojectStaticVirtualDOMElementWithMappings;
    private reprojectMutationWithMappings;
    private handleMutation;
    private removeNodeAndChildren;
}
//# sourceMappingURL=NetworkedDOM.d.ts.map