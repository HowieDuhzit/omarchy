// src/createNetworkedDOMConnectionForWebsocket.ts
import {
  isNetworkedDOMProtocolSubProtocol_v0_2 as isNetworkedDOMProtocolSubProtocol_v0_22,
  networkedDOMProtocolSubProtocol_v0_1,
  networkedDOMProtocolSubProtocol_v0_2_SubVersionsList
} from "@mml-io/networked-dom-protocol";

// src/NetworkedDOMV01Connection.ts
var NetworkedDOMV01Connection = class {
  constructor(webSocket) {
    this.webSocket = webSocket;
    this.internalConnectionId = null;
    this.internalIdToExternalId = /* @__PURE__ */ new Map();
    this.networkedDOM = null;
    this.websocketListener = (messageEvent) => {
      const string = String(messageEvent.data);
      let parsed;
      try {
        parsed = JSON.parse(string);
      } catch (e) {
        console.error(`Error parsing message from websocket: ${string}`, e);
        console.trace();
        return;
      }
      switch (parsed.type) {
        case "pong":
          return;
        case "event": {
          if (!this.networkedDOM) {
            console.error("NetworkedDOM not set on connection that received event", this);
            return;
          }
          if (this.internalConnectionId === null) {
            console.error("Internal connection ID not set on connection that received event", this);
            return;
          }
          this.networkedDOM.dispatchRemoteEvent(this, this.internalConnectionId, 1, {
            nodeId: parsed.nodeId,
            name: parsed.name,
            bubbles: parsed.bubbles ?? true,
            params: parsed.params
          });
          return;
        }
        default:
          console.error("Unknown message type from client", parsed);
      }
    };
    webSocket.addEventListener("message", this.websocketListener);
  }
  setNetworkedDOM(networkedDOM) {
    this.networkedDOM = networkedDOM;
  }
  initAsNewV01Connection() {
    if (!this.networkedDOM) {
      throw new Error("NetworkedDOM not set on connection");
    }
    const internalConnectionIds = this.networkedDOM.connectUsers(this, /* @__PURE__ */ new Set([1]));
    this.internalConnectionId = internalConnectionIds.entries().next().value[0];
    this.internalIdToExternalId.set(this.internalConnectionId, 1);
    this.networkedDOM.announceConnectedUsers(
      /* @__PURE__ */ new Map([[this.internalConnectionId, null]])
    );
  }
  stringifyAndSendSingleMessage(message) {
    this.webSocket.send("[" + JSON.stringify(message) + "]");
  }
  sendStringifiedJSONArray(jsonArray) {
    this.webSocket.send(jsonArray);
  }
  dispose() {
    this.webSocket.removeEventListener("message", this.websocketListener);
  }
};

// src/NetworkedDOMV02Connection.ts
import {
  BufferReader,
  BufferWriter,
  decodeClientMessages,
  encodeBatchEnd,
  encodeBatchStart,
  encodeServerMessage,
  getNetworkedDOMProtocolSubProtocol_v0_2SubversionOrThrow,
  isNetworkedDOMProtocolSubProtocol_v0_2
} from "@mml-io/networked-dom-protocol";
var NetworkedDOMV02Connection = class {
  constructor(webSocket) {
    this.webSocket = webSocket;
    this.externalIdToInternalId = /* @__PURE__ */ new Map();
    this.internalIdToExternalId = /* @__PURE__ */ new Map();
    this.internalIdToToken = /* @__PURE__ */ new Map();
    this.batchMode = false;
    this.batchMessages = [];
    this.externalConnectionIds = /* @__PURE__ */ new Set();
    this.networkedDOM = null;
    this.messagesAwaitingNetworkedDOM = [];
    const protocol = webSocket.protocol;
    if (!isNetworkedDOMProtocolSubProtocol_v0_2(protocol)) {
      throw new Error(
        `WebSocket protocol ${protocol} is not a supported networked-dom-v0.2 sub-protocol`
      );
    }
    const protocolSubversion = getNetworkedDOMProtocolSubProtocol_v0_2SubversionOrThrow(protocol);
    this.websocketListener = (messageEvent) => {
      const buffer = new Uint8Array(messageEvent.data);
      const messages = decodeClientMessages(new BufferReader(buffer), protocolSubversion);
      for (const parsed of messages) {
        if (this.networkedDOM) {
          this.handleClientMessage(parsed);
        } else {
          this.messagesAwaitingNetworkedDOM.push(parsed);
        }
      }
    };
    webSocket.addEventListener("message", this.websocketListener);
  }
  setNetworkedDOM(networkedDOM) {
    this.networkedDOM = networkedDOM;
  }
  setBatchStart() {
    this.batchMode = true;
  }
  setBatchEnd() {
    this.batchMode = false;
    if (this.batchMessages.length === 0) {
      return;
    }
    const includeBatchStartAndEnd = this.batchMessages.length > 1;
    let toSendBytes;
    if (this.batchMessages.length === 1 && this.batchMessages[0] instanceof Uint8Array && !includeBatchStartAndEnd) {
      toSendBytes = this.batchMessages[0];
    } else {
      const bufferWriter = new BufferWriter(256);
      if (includeBatchStartAndEnd) {
        encodeBatchStart(bufferWriter);
      }
      for (const message of this.batchMessages) {
        if (message instanceof Uint8Array) {
          bufferWriter.writeBytes(message);
        } else {
          encodeServerMessage(message, bufferWriter);
        }
      }
      if (includeBatchStartAndEnd) {
        encodeBatchEnd(bufferWriter);
      }
      toSendBytes = bufferWriter.getBuffer();
    }
    this.webSocket.send(toSendBytes);
    this.batchMessages = [];
  }
  sendMessage(message) {
    this.sendEncodedBytes(encodeServerMessage(message).getBuffer());
  }
  sendMessages(messages) {
    const bufferWriter = new BufferWriter(256);
    for (const message of messages) {
      encodeServerMessage(message, bufferWriter);
    }
    const bytes = bufferWriter.getBuffer();
    this.sendEncodedBytes(bytes);
  }
  sendEncodedBytes(bytes) {
    if (this.batchMode) {
      this.batchMessages.push(bytes);
      return;
    }
    this.webSocket.send(bytes);
  }
  dispose() {
    this.webSocket.removeEventListener("message", this.websocketListener);
  }
  handleClientMessage(parsed) {
    switch (parsed.type) {
      case "connectUsers": {
        const externalIdsToToken = /* @__PURE__ */ new Map();
        const addedExternalUserIds = /* @__PURE__ */ new Set();
        for (let i = 0; i < parsed.connectionIds.length; i++) {
          const addingExternalId = parsed.connectionIds[i];
          const correspondingToken = parsed.connectionTokens[i];
          externalIdsToToken.set(addingExternalId, correspondingToken);
          if (!Number.isInteger(addingExternalId) || addingExternalId < 0) {
            this.sendMessage({
              type: "error",
              message: `Connection ID ${addingExternalId} is not a positive integer.`
            });
            console.error("Connection ID is not a positive integer", addingExternalId);
            return;
          }
          if (this.externalConnectionIds.has(addingExternalId)) {
            this.sendMessage({
              type: "error",
              message: `Connection ID ${addingExternalId} already exists.`
            });
            console.error("Connection ID already exists", addingExternalId);
            return;
          }
          this.externalConnectionIds.add(addingExternalId);
          if (addedExternalUserIds.has(addingExternalId)) {
            this.sendMessage({
              type: "error",
              message: `Connection ID ${addingExternalId} is duplicated.`
            });
            console.error("Connection ID is duplicated in connectUsers", addingExternalId);
            return;
          }
          addedExternalUserIds.add(addingExternalId);
        }
        if (this.networkedDOM !== null) {
          const connectionIdToExternalId = this.networkedDOM.connectUsers(
            this,
            addedExternalUserIds
          );
          const addingInternalIdsWithToken = /* @__PURE__ */ new Map();
          for (const [addingInternalId, addingExternalId] of connectionIdToExternalId) {
            const token = externalIdsToToken.get(addingExternalId) ?? null;
            addingInternalIdsWithToken.set(addingInternalId, token);
            this.externalIdToInternalId.set(addingExternalId, addingInternalId);
            this.internalIdToExternalId.set(addingInternalId, addingExternalId);
            this.internalIdToToken.set(addingInternalId, token);
          }
          this.networkedDOM.announceConnectedUsers(addingInternalIdsWithToken);
        }
        return;
      }
      case "disconnectUsers": {
        const removingExternalUserIds = /* @__PURE__ */ new Set();
        const removedExternalToInternalUserIds = /* @__PURE__ */ new Map();
        for (const removingExternalId of parsed.connectionIds) {
          if (!this.externalConnectionIds.has(removingExternalId)) {
            this.sendMessage({
              type: "error",
              message: `Connection ID ${removingExternalId} does not exist.`
            });
            console.error("Connection ID not found", removingExternalId);
            return;
          }
          removingExternalUserIds.add(removingExternalId);
        }
        for (const removingExternalId of removingExternalUserIds) {
          const removingInternalId = this.externalIdToInternalId.get(removingExternalId);
          if (removingInternalId === void 0) {
            this.sendMessage({
              type: "error",
              message: `Connection ID ${removingExternalId} does not exist.`
            });
            console.error(
              "Connection ID not found in externalIdToInternalId map",
              removingExternalId
            );
            return;
          }
          if (removedExternalToInternalUserIds.has(removingExternalId)) {
            this.sendMessage({
              type: "error",
              message: `Connection ID ${removingExternalId} is duplicated.`
            });
            console.error("Connection ID is duplicated in disconnectUsers", removingExternalId);
            return;
          }
          removedExternalToInternalUserIds.set(removingExternalId, removingInternalId);
        }
        if (this.networkedDOM === null) {
          for (const [removingExternalId, removingInternalId] of removedExternalToInternalUserIds) {
            this.externalConnectionIds.delete(removingExternalId);
            this.externalIdToInternalId.delete(removingExternalId);
            this.internalIdToExternalId.delete(removingInternalId);
            this.internalIdToToken.delete(removingInternalId);
          }
        } else {
          const removalDiffs = this.networkedDOM.disconnectUsers(
            this,
            removedExternalToInternalUserIds
          );
          if (removalDiffs.length > 0) {
            this.sendMessages(removalDiffs);
          }
        }
        return;
      }
      case "pong":
        return;
      case "event": {
        if (!this.networkedDOM) {
          console.error("NetworkedDOM not set on connection that received event", this);
          return;
        }
        const externalId = parsed.connectionId;
        const internalId = this.externalIdToInternalId.get(externalId);
        if (internalId === void 0) {
          this.sendMessage({
            type: "error",
            message: `Event sent with connection id ${parsed.connectionId}, but that connection id has not been connected.`
          });
          console.error(
            "Connection ID not found in externalIdToInternalId map",
            parsed.connectionId
          );
          return;
        }
        this.networkedDOM.dispatchRemoteEvent(this, internalId, externalId, {
          nodeId: parsed.nodeId,
          name: parsed.name,
          bubbles: parsed.bubbles ?? true,
          params: parsed.params
        });
        return;
      }
      default:
        console.error("Unknown message type from client", parsed);
    }
  }
  handleBufferedMessages() {
    const awaiting = this.messagesAwaitingNetworkedDOM;
    this.messagesAwaitingNetworkedDOM = [];
    for (const message of awaiting) {
      this.handleClientMessage(message);
    }
  }
};

// src/createNetworkedDOMConnectionForWebsocket.ts
var SupportedWebsocketSubProtocolsPreferenceOrder = [
  ...networkedDOMProtocolSubProtocol_v0_2_SubVersionsList,
  networkedDOMProtocolSubProtocol_v0_1
];
var defaultWebsocketSubProtocol = networkedDOMProtocolSubProtocol_v0_1;
function IsRecognizedWebsocketSubProtocol(protocol) {
  return SupportedWebsocketSubProtocolsPreferenceOrder.includes(protocol);
}
function createNetworkedDOMConnectionForWebsocket(webSocket) {
  let assumedProtocol = null;
  if (webSocket.protocol) {
    if (!IsRecognizedWebsocketSubProtocol(webSocket.protocol)) {
      const errorMessageString = `Unsupported websocket subprotocol: ${webSocket.protocol}`;
      const errorMessage = [
        {
          type: "error",
          message: errorMessageString
        }
      ];
      webSocket.send(JSON.stringify(errorMessage));
      webSocket.close();
      return null;
    } else {
      assumedProtocol = webSocket.protocol;
    }
  } else {
    const warningMessageString = `No websocket subprotocol specified. Please specify a subprotocol to ensure compatibility with networked-dom servers. Assuming subprotocol "${defaultWebsocketSubProtocol}" for this connection.`;
    const warningMessage = [
      {
        type: "warning",
        message: warningMessageString
      }
    ];
    webSocket.send(JSON.stringify(warningMessage));
    assumedProtocol = defaultWebsocketSubProtocol;
  }
  const isV02 = isNetworkedDOMProtocolSubProtocol_v0_22(assumedProtocol);
  if (isV02) {
    return new NetworkedDOMV02Connection(webSocket);
  }
  return new NetworkedDOMV01Connection(webSocket);
}

// src/NetworkedDOM.ts
import {
  BufferWriter as BufferWriter2,
  encodeAttributesChanged,
  encodeChildrenAdded,
  encodeChildrenRemoved,
  encodeDocumentTime,
  encodePing,
  encodeTextChanged
} from "@mml-io/networked-dom-protocol";

// src/rfc6902/deepEqual.ts
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return false;
    }
    return a.every((elem, index) => {
      return deepEqual(elem, b[index]);
    });
  }
  if (typeof a === "object" && typeof b === "object" && a !== null && b !== null) {
    if (Array.isArray(a) || Array.isArray(b)) {
      return false;
    }
    const keys1 = Object.keys(a);
    const keys2 = Object.keys(b);
    if (keys1.length !== keys2.length || !keys1.every((key) => keys2.includes(key))) {
      return false;
    }
    for (const key in a) {
      if (!deepEqual(a[key], b[key])) {
        return false;
      }
    }
    if (keys1.length === 0 && a instanceof Date && b instanceof Date) {
      return a.getTime() === b.getTime();
    }
    return true;
  }
  return false;
}

// src/rfc6902/pointer.ts
function unescape(token) {
  return token.replace(/~1/g, "/").replace(/~0/g, "~");
}
function escape(token) {
  return token.replace(/~/g, "~0").replace(/\//g, "~1");
}
var Pointer = class _Pointer {
  constructor(tokens = [""]) {
    this.tokens = tokens;
  }
  /**
  `path` *must* be a properly escaped string.
  */
  static fromJSON(path) {
    const tokens = path.split("/").map(unescape);
    if (tokens[0] !== "") throw new Error(`Invalid JSON Pointer: ${path}`);
    return new _Pointer(tokens);
  }
  toString() {
    return this.tokens.map(escape).join("/");
  }
  /**
  Returns an object with 'parent', 'key', and 'value' properties.
  In the special case that this Pointer's path == "",
  this object will be {parent: null, key: '', value: object}.
  Otherwise, parent and key will have the property such that parent[key] == value.
  */
  evaluate(object) {
    let parent = null;
    let key = "";
    let value = object;
    for (let i = 1, l = this.tokens.length; i < l; i++) {
      parent = value;
      key = this.tokens[i];
      if (key === "__proto__" || key === "constructor" || key === "prototype") {
        continue;
      }
      value = (parent || {})[key];
    }
    return { parent, key, value };
  }
  get(object) {
    return this.evaluate(object).value;
  }
  set(object, value) {
    let cursor = object;
    for (let i = 1, l = this.tokens.length - 1, token = this.tokens[i]; i < l; i++) {
      cursor = (cursor || {})[token];
    }
    if (cursor) {
      cursor[this.tokens[this.tokens.length - 1]] = value;
    }
  }
  push(token) {
    this.tokens.push(token);
  }
  /**
    `token` should be a String. It'll be coerced to one anyway.
  
    immutable (shallowly)
    */
  add(token) {
    const tokens = this.tokens.concat(String(token));
    return new _Pointer(tokens);
  }
};

// src/rfc6902/util.ts
var hasOwnProperty = Object.prototype.hasOwnProperty;
function objectType(object) {
  if (object === void 0) {
    return "undefined";
  }
  if (object === null) {
    return "null";
  }
  if (Array.isArray(object)) {
    return "array";
  }
  return typeof object;
}
function isNonPrimitive(value) {
  return value != null && typeof value === "object";
}
function clone(source) {
  if (!isNonPrimitive(source)) {
    return source;
  }
  if (Array.isArray(source)) {
    const length = source.length;
    const arrayTarget = new Array(length);
    for (let i = 0; i < length; i++) {
      arrayTarget[i] = clone(source[i]);
    }
    return arrayTarget;
  }
  if (source.constructor === Date) {
    const dateTarget = /* @__PURE__ */ new Date(+source);
    return dateTarget;
  }
  const objectTarget = {};
  for (const key in source) {
    if (hasOwnProperty.call(source, key)) {
      objectTarget[key] = clone(source[key]);
    }
  }
  return objectTarget;
}

// src/rfc6902/diff.ts
function wrapVoidableDiff(diff) {
  function wrappedDiff(input, output, ptr) {
    const custom_patch = diff(input, output, ptr);
    return Array.isArray(custom_patch) ? custom_patch : diffAny(input, output, ptr, wrappedDiff);
  }
  return wrappedDiff;
}
function createPatch(input, output, diff) {
  const ptr = new Pointer();
  return (diff ? wrapVoidableDiff(diff) : diffAny)(input, output, ptr);
}
function subtract(minuend, subtrahend) {
  const obj = {};
  for (const add_key in minuend) {
    if (hasOwnProperty.call(minuend, add_key) && minuend[add_key] !== void 0) {
      obj[add_key] = 1;
    }
  }
  for (const del_key in subtrahend) {
    if (hasOwnProperty.call(subtrahend, del_key) && subtrahend[del_key] !== void 0) {
      delete obj[del_key];
    }
  }
  return Object.keys(obj);
}
function intersection(objects) {
  const length = objects.length;
  const counter = {};
  for (let i = 0; i < length; i++) {
    const object = objects[i];
    for (const key in object) {
      if (hasOwnProperty.call(object, key) && object[key] !== void 0) {
        counter[key] = (counter[key] || 0) + 1;
      }
    }
  }
  for (const key in counter) {
    if (counter[key] < length) {
      delete counter[key];
    }
  }
  return Object.keys(counter);
}
function isArrayAdd(array_operation) {
  return array_operation.op === "add";
}
function isArrayRemove(array_operation) {
  return array_operation.op === "remove";
}
function buildOperations(memo, i, j) {
  let memoized = memo[i][j];
  if (!memoized) {
    throw new Error("invalid memo");
  }
  const operations = [];
  while (memoized && memoized.prev && memoized.operation) {
    operations.push(memoized.operation);
    const index = memoized.prev.split(",");
    memoized = memo[Number(index[0])][Number(index[1])];
  }
  return operations.reverse();
}
function diffArrays(input, output, ptr, diff = diffAny) {
  if (diff === void 0) {
    diff = diffAny;
  }
  const input_length = isNaN(input.length) || input.length <= 0 ? 0 : input.length;
  const output_length = isNaN(output.length) || output.length <= 0 ? 0 : output.length;
  let input_end = input_length;
  let output_end = output_length;
  while (input_end > 0 && output_end > 0) {
    if (deepEqual(input[input_end - 1], output[output_end - 1])) {
      input_end--;
      output_end--;
    } else {
      break;
    }
  }
  const memo = new Array(input_end + 1);
  for (let i = 0; i <= input_end; i++) {
    memo[i] = new Array(output_end + 1);
  }
  memo[0][0] = { prev: null, operation: null, cost: 0 };
  for (let i = 0; i <= input_end; i++) {
    for (let j = 0; j <= output_end; j++) {
      let memoized = memo[i][j];
      if (memoized) continue;
      const add_prev_key = `${i},${j - 1}`;
      const remove_prev_key = `${i - 1},${j}`;
      const replace_prev_key = `${i - 1},${j - 1}`;
      const remove_operation = {
        op: "remove",
        index: i - 1
      };
      const add_operation = {
        op: "add",
        index: i - 1,
        value: output[j - 1]
      };
      if (j === 0) {
        memoized = {
          prev: remove_prev_key,
          operation: remove_operation,
          cost: memo[i - 1][j].cost + 1
        };
      } else if (i === 0) {
        memoized = { prev: add_prev_key, operation: add_operation, cost: memo[i][j - 1].cost + 1 };
      } else {
        if (deepEqual(input[i - 1], output[j - 1])) {
          memoized = memo[i - 1][j - 1];
        } else {
          const remove_prev = memo[i - 1][j];
          const add_prev = memo[i][j - 1];
          const replace_prev = memo[i - 1][j - 1];
          const min_cost = Math.min(replace_prev.cost, add_prev.cost, remove_prev.cost);
          if (remove_prev.cost === min_cost) {
            memoized = {
              prev: remove_prev_key,
              operation: remove_operation,
              cost: memo[i - 1][j].cost + 1
            };
          } else if (add_prev.cost === min_cost) {
            memoized = {
              prev: add_prev_key,
              operation: add_operation,
              cost: memo[i][j - 1].cost + 1
            };
          } else {
            const replace_operation = {
              op: "replace",
              index: i - 1,
              original: input[i - 1],
              value: output[j - 1]
            };
            memoized = {
              prev: replace_prev_key,
              operation: replace_operation,
              cost: memo[i - 1][j - 1].cost + 1
            };
          }
        }
      }
      memo[i][j] = memoized;
    }
  }
  const array_operations = buildOperations(memo, input_end, output_end);
  const [padded_operations] = array_operations.reduce(
    ([operations, padding], array_operation) => {
      if (isArrayAdd(array_operation)) {
        const padded_index = array_operation.index + 1 + padding;
        const index_token = padded_index < input_length + padding ? String(padded_index) : "-";
        const operation = {
          op: array_operation.op,
          path: ptr.add(index_token).toString(),
          value: array_operation.value
        };
        return [operations.concat(operation), padding + 1];
      } else if (isArrayRemove(array_operation)) {
        const operation = {
          op: array_operation.op,
          path: ptr.add(String(array_operation.index + padding)).toString()
        };
        return [operations.concat(operation), padding - 1];
      } else {
        const replace_ptr = ptr.add(String(array_operation.index + padding));
        const replace_operations = diff(
          array_operation.original,
          array_operation.value,
          replace_ptr
        );
        return [operations.concat(...replace_operations), padding];
      }
    },
    [[], 0]
  );
  return padded_operations;
}
function diffObjects(input, output, ptr, diff = diffAny) {
  const operations = [];
  subtract(input, output).forEach((key) => {
    operations.push({ op: "remove", path: ptr.add(key).toString() });
  });
  subtract(output, input).forEach((key) => {
    operations.push({ op: "add", path: ptr.add(key).toString(), value: output[key] });
  });
  intersection([input, output]).forEach((key) => {
    operations.push(...diff(input[key], output[key], ptr.add(key)));
  });
  return operations;
}
function diffAny(input, output, ptr, diff = diffAny) {
  if (input === output) {
    return [];
  }
  const input_type = objectType(input);
  const output_type = objectType(output);
  if (input_type === "array" && output_type === "array") {
    return diffArrays(input, output, ptr, diff);
  }
  if (input_type === "object" && output_type === "object") {
    return diffObjects(input, output, ptr, diff);
  }
  return [{ op: "replace", path: ptr.toString(), value: output }];
}

// src/rfc6902/patch.ts
var MissingError = class extends Error {
  constructor(path) {
    super(`Value required at path: ${path}`);
    this.path = path;
    this.name = "MissingError";
  }
};
var TestError = class extends Error {
  constructor(actual, expected) {
    super(`Test failed: ${actual} != ${expected}`);
    this.actual = actual;
    this.expected = expected;
    this.name = "TestError";
  }
};
function applyPatch(object, patch) {
  return patch.map((operation) => apply(object, operation));
}
function _add(object, key, value) {
  if (Array.isArray(object)) {
    if (key === "-") {
      object.push(value);
    } else {
      const index = parseInt(key, 10);
      object.splice(index, 0, value);
    }
  } else {
    object[key] = value;
  }
}
function _remove(object, key) {
  if (Array.isArray(object)) {
    const index = parseInt(key, 10);
    object.splice(index, 1);
  } else {
    delete object[key];
  }
}
function add(object, operation) {
  const endpoint = Pointer.fromJSON(operation.path).evaluate(object);
  if (endpoint.parent === void 0) {
    return new MissingError(operation.path);
  }
  _add(endpoint.parent, endpoint.key, clone(operation.value));
  return null;
}
function remove(object, operation) {
  const endpoint = Pointer.fromJSON(operation.path).evaluate(object);
  if (endpoint.value === void 0) {
    return new MissingError(operation.path);
  }
  _remove(endpoint.parent, endpoint.key);
  return null;
}
function replace(object, operation) {
  const endpoint = Pointer.fromJSON(operation.path).evaluate(object);
  if (endpoint.parent === null) {
    return new MissingError(operation.path);
  }
  if (Array.isArray(endpoint.parent)) {
    if (parseInt(endpoint.key, 10) >= endpoint.parent.length) {
      return new MissingError(operation.path);
    }
  } else if (endpoint.value === void 0) {
    return new MissingError(operation.path);
  }
  endpoint.parent[endpoint.key] = operation.value;
  return null;
}
function move(object, operation) {
  const from_endpoint = Pointer.fromJSON(operation.from).evaluate(object);
  if (from_endpoint.value === void 0) {
    return new MissingError(operation.from);
  }
  const endpoint = Pointer.fromJSON(operation.path).evaluate(object);
  if (endpoint.parent === void 0) {
    return new MissingError(operation.path);
  }
  _remove(from_endpoint.parent, from_endpoint.key);
  _add(endpoint.parent, endpoint.key, from_endpoint.value);
  return null;
}
function copy(object, operation) {
  const from_endpoint = Pointer.fromJSON(operation.from).evaluate(object);
  if (from_endpoint.value === void 0) {
    return new MissingError(operation.from);
  }
  const endpoint = Pointer.fromJSON(operation.path).evaluate(object);
  if (endpoint.parent === void 0) {
    return new MissingError(operation.path);
  }
  _add(endpoint.parent, endpoint.key, clone(from_endpoint.value));
  return null;
}
function test(object, operation) {
  const endpoint = Pointer.fromJSON(operation.path).evaluate(object);
  if (diffAny(endpoint.value, operation.value, new Pointer()).length) {
    return new TestError(endpoint.value, operation.value);
  }
  return null;
}
var InvalidOperationError = class extends Error {
  constructor(operation) {
    super(`Invalid operation: ${operation.op}`);
    this.operation = operation;
    this.name = "InvalidOperationError";
  }
};
function apply(object, operation) {
  switch (operation.op) {
    case "add":
      return add(object, operation);
    case "remove":
      return remove(object, operation);
    case "replace":
      return replace(object, operation);
    case "move":
      return move(object, operation);
    case "copy":
      return copy(object, operation);
    case "test":
      return test(object, operation);
  }
  return new InvalidOperationError(operation);
}

// src/diffing/calculateStaticVirtualDOMDiff.ts
function calculateStaticVirtualDOMDiff(originalState, latestState) {
  const jsonPatchDiffs = createPatch(
    originalState,
    latestState,
    (a, b, ptr) => {
      if (a.tag !== b.tag) {
        return [{ op: "replace", path: ptr.toString(), value: b }];
      }
      return;
    }
  );
  const nodeIdRemappings = [];
  const virtualDOMDiffs = [];
  for (const diff of jsonPatchDiffs) {
    if (diff.op === "replace" && diff.path.endsWith("/nodeId")) {
      const pointer = Pointer.fromJSON(diff.path);
      const originalValue = pointer.get(originalState);
      nodeIdRemappings.push({
        internalNodeId: diff.value,
        clientFacingNodeId: originalValue
      });
    } else {
      virtualDOMDiffs.push(diff);
    }
  }
  return remapDuplicatedNodeIdsInOperations(
    {
      originalState,
      nodeIdRemappings,
      virtualDOMDiffs
    },
    latestState
  );
}
function getHighestNodeId(node) {
  let highest = node.nodeId;
  for (const child of node.childNodes) {
    highest = Math.max(highest, getHighestNodeId(child));
  }
  return highest;
}
function getRemovedNodeIds(before, diff) {
  const removedIds = /* @__PURE__ */ new Set();
  function addNode(node) {
    removedIds.add(node.nodeId);
    for (const child of node.childNodes) {
      addNode(child);
    }
  }
  if (diff.op === "replace" || diff.op === "remove") {
    const removedNode = Pointer.fromJSON(diff.path).get(before);
    addNode(removedNode);
  }
  return removedIds;
}
function getNodeIdsFromNodeAndChildren(node) {
  const nodeIds = /* @__PURE__ */ new Set();
  function addNode(node2) {
    nodeIds.add(node2.nodeId);
    for (const child of node2.childNodes) {
      addNode(child);
    }
  }
  addNode(node);
  return nodeIds;
}
function remapDuplicatedNodeIdsInOperations(virtualDOMDiffStruct, latestState) {
  const { originalState, nodeIdRemappings, virtualDOMDiffs } = virtualDOMDiffStruct;
  const highestNodeIdAcrossStartAndEnd = Math.max(
    getHighestNodeId(originalState),
    getHighestNodeId(latestState)
  );
  let nextNodeId = highestNodeIdAcrossStartAndEnd + 1;
  const before = JSON.parse(JSON.stringify(originalState));
  function checkAndReplaceNodeIdsIfAlreadyInUse(node, addingNodeIds, removedIds) {
    if (existingNodeIds.has(node.nodeId) && removedIds && !removedIds.has(node.nodeId)) {
      const newNodeId = nextNodeId++;
      nodeIdRemappings.push({
        internalNodeId: node.nodeId,
        clientFacingNodeId: newNodeId
      });
      node.nodeId = newNodeId;
      addingNodeIds.add(newNodeId);
    } else {
      addingNodeIds.add(node.nodeId);
    }
    for (const child of node.childNodes) {
      checkAndReplaceNodeIdsIfAlreadyInUse(child, addingNodeIds, removedIds);
    }
  }
  const existingNodeIds = getNodeIdsFromNodeAndChildren(before);
  for (const diff of virtualDOMDiffs) {
    const pointer = Pointer.fromJSON(diff.path);
    const secondLastToken = pointer.tokens[pointer.tokens.length - 2];
    if (secondLastToken !== "childNodes") {
      continue;
    }
    const removedIds = getRemovedNodeIds(before, diff);
    const addingNodeIds = /* @__PURE__ */ new Set();
    if (diff.op === "replace" || diff.op === "add") {
      checkAndReplaceNodeIdsIfAlreadyInUse(diff.value, addingNodeIds, removedIds);
    }
    removedIds.forEach((removedId) => {
      existingNodeIds.delete(removedId);
    });
    addingNodeIds.forEach((addingNodeId) => {
      existingNodeIds.add(addingNodeId);
    });
    const patchErrors = applyPatch(before, [diff]);
    if (patchErrors.length !== 1 || patchErrors[0] !== null) {
      throw new Error("Patch failed");
    }
  }
  return virtualDOMDiffStruct;
}

// src/NodeWithSubjectivity.ts
function IsVisibleToAll(s, applyV01Semantics) {
  if (applyV01Semantics) {
    return s.visibleTo.size === 0 && s.hiddenFrom.size === 0 && (s.ancestorSubjectivity == null || IsVisibleToAll(s.ancestorSubjectivity, applyV01Semantics));
  }
  return s.visibleTo.size === 0 && (s.ancestorSubjectivity == null || IsVisibleToAll(s.ancestorSubjectivity, applyV01Semantics));
}
function IsVisibleToAnyOneOfConnectionIds(s, connectionIdsMap, applyV01Semantics) {
  if (IsVisibleToAll(s, applyV01Semantics)) {
    return true;
  }
  let visibleToDirectly = false;
  if (s.visibleTo.size > 0) {
    for (const connectionId of s.visibleTo) {
      if (connectionIdsMap.has(connectionId)) {
        visibleToDirectly = true;
        break;
      }
    }
    if (!visibleToDirectly) {
      return false;
    }
  }
  if (applyV01Semantics) {
    for (const connectionId of s.hiddenFrom) {
      if (connectionIdsMap.has(connectionId)) {
        return false;
      }
    }
  }
  if (s.ancestorSubjectivity == null) {
    return true;
  }
  return IsVisibleToAnyOneOfConnectionIds(
    s.ancestorSubjectivity,
    connectionIdsMap,
    applyV01Semantics
  );
}
function applySubjectivityToChildren(node, newSubjectivity, previousSubjectivity) {
  for (const child of node.childNodes) {
    if (child.subjectivity === previousSubjectivity) {
      child.subjectivity = newSubjectivity;
      applySubjectivityToChildren(child, newSubjectivity, previousSubjectivity);
    } else {
      child.subjectivity.ancestorSubjectivity = newSubjectivity;
    }
  }
}

// src/diffing/describeNode.ts
var visibleToAttrName = "visible-to";
var hiddenFromAttrName = "hidden-from";
function filteredV01Attributes(attributes, excludedKeys) {
  const filtered = {};
  for (const key in attributes) {
    if (!excludedKeys.has(key)) {
      filtered[key] = attributes[key];
    }
  }
  return filtered;
}
function filteredV02Attributes(attributes, excludedKeys) {
  const filtered = [];
  for (const key in attributes) {
    if (!excludedKeys.has(key)) {
      filtered.push([key, attributes[key]]);
    }
  }
  return filtered;
}
var excludedAttributes = /* @__PURE__ */ new Set([visibleToAttrName, hiddenFromAttrName]);
function describeNodeWithChildrenForV01Connection(virtualDOMElement, networkedDOMConnection) {
  if (networkedDOMConnection ? !IsVisibleToAnyOneOfConnectionIds(
    virtualDOMElement.subjectivity,
    networkedDOMConnection.internalIdToExternalId,
    true
  ) : !IsVisibleToAll(virtualDOMElement.subjectivity, true)) {
    return null;
  }
  let emittedTagName = virtualDOMElement.tag;
  if (emittedTagName === "#DOCUMENT") {
    emittedTagName = "DIV";
  }
  if (emittedTagName === "#text") {
    const textNode = {
      type: "text",
      nodeId: virtualDOMElement.nodeId,
      text: virtualDOMElement.textContent || ""
    };
    return textNode;
  } else {
    const node = {
      type: "element",
      nodeId: virtualDOMElement.nodeId,
      tag: emittedTagName,
      attributes: filteredV01Attributes(virtualDOMElement.attributes, excludedAttributes),
      children: [],
      text: virtualDOMElement.textContent
    };
    for (const child of virtualDOMElement.childNodes) {
      const childNodeDescription = describeNodeWithChildrenForV01Connection(
        child,
        networkedDOMConnection
      );
      if (childNodeDescription) {
        node.children.push(childNodeDescription);
      }
    }
    return node;
  }
}
function describeNodeWithChildrenForV02Connection(virtualDOMElement, networkedDOMConnection) {
  if (networkedDOMConnection ? !IsVisibleToAnyOneOfConnectionIds(
    virtualDOMElement.subjectivity,
    networkedDOMConnection.internalIdToExternalId,
    false
  ) : !IsVisibleToAll(virtualDOMElement.subjectivity, false)) {
    return null;
  }
  let emittedTagName = virtualDOMElement.tag;
  if (emittedTagName === "#DOCUMENT") {
    emittedTagName = "DIV";
  }
  if (emittedTagName === "#text") {
    const textNode = {
      type: "text",
      nodeId: virtualDOMElement.nodeId,
      text: virtualDOMElement.textContent || ""
    };
    return textNode;
  } else {
    const visibleTo = [];
    const hiddenFrom = [];
    const hasOwnSubjectivity = virtualDOMElement.parent && virtualDOMElement.subjectivity !== virtualDOMElement.parent.subjectivity;
    if (networkedDOMConnection && hasOwnSubjectivity) {
      for (const id of virtualDOMElement.subjectivity.visibleTo) {
        const remapped = networkedDOMConnection.internalIdToExternalId.get(id);
        if (remapped !== void 0) {
          visibleTo.push(remapped);
        }
      }
      for (const id of virtualDOMElement.subjectivity.hiddenFrom) {
        const remapped = networkedDOMConnection.internalIdToExternalId.get(id);
        if (remapped !== void 0) {
          hiddenFrom.push(remapped);
        }
      }
    }
    const node = {
      type: "element",
      nodeId: virtualDOMElement.nodeId,
      tag: emittedTagName,
      attributes: filteredV02Attributes(virtualDOMElement.attributes, excludedAttributes),
      children: [],
      text: virtualDOMElement.textContent,
      visibleTo,
      hiddenFrom
    };
    for (const child of virtualDOMElement.childNodes) {
      const childNodeDescription = describeNodeWithChildrenForV02Connection(
        child,
        networkedDOMConnection
      );
      if (childNodeDescription) {
        node.children.push(childNodeDescription);
      }
    }
    return node;
  }
}

// src/diffing/listAttributeToSet.ts
function listAttributeToSet(attr) {
  if (attr === null || attr === void 0 || attr === "") {
    return /* @__PURE__ */ new Set();
  }
  let hasInvalid = false;
  const entries = attr.split(/[\s,]+/).map((x) => {
    if (/^-?[0-9]\d*$/.test(x)) {
      return parseInt(x, 10);
    }
    hasInvalid = true;
    return null;
  }).filter((x) => x !== null);
  if (entries.length === 0 && hasInvalid) {
    return /* @__PURE__ */ new Set([-1]);
  }
  return new Set(entries);
}

// src/diffing/mergeMutations.ts
function mergeMutations(mutations) {
  if (mutations.length <= 1) {
    return mutations;
  }
  const mergedMutations = [mutations[0]];
  const lastMutation = mutations[0];
  for (let i = 1; i < mutations.length; i++) {
    const currentMutation = mutations[i];
    if (currentMutation.type === "childList" && lastMutation.type === "childList" && lastMutation.targetId === currentMutation.targetId) {
      const lastAddedNodeId = lastMutation.addedNodes.length > 0 ? lastMutation.addedNodes[lastMutation.addedNodes.length - 1].nodeId : null;
      if (lastAddedNodeId !== null && currentMutation.previousSiblingId === lastAddedNodeId && currentMutation.removedNodeIds.length === 0) {
        lastMutation.addedNodes.push(...currentMutation.addedNodes);
        continue;
      }
    } else if (currentMutation.type === "attributes" && lastMutation.type === "attributes" && lastMutation.targetId === currentMutation.targetId) {
      Object.assign(lastMutation.attributes, currentMutation.attributes);
      continue;
    }
    mergedMutations.push(currentMutation);
  }
  return mergedMutations;
}

// src/diffing/virtualDOMDiffToVirtualDOMMutationRecord.ts
function virtualDOMDiffToVirtualDOMMutationRecord(virtualStructure, domDiff) {
  const pointer = Pointer.fromJSON(domDiff.path);
  const grandParentTokens = pointer.tokens.slice(0, pointer.tokens.length - 2);
  const lastToken = pointer.tokens[pointer.tokens.length - 1];
  const secondLastToken = pointer.tokens[pointer.tokens.length - 2];
  if (lastToken === "textContent") {
    const nodePointer = new Pointer(pointer.tokens.slice(0, pointer.tokens.length - 1));
    const node = nodePointer.get(virtualStructure);
    if (domDiff.op === "replace" || domDiff.op === "add") {
      return [
        {
          type: "characterData",
          targetId: node.nodeId,
          textContent: domDiff.value
        }
      ];
    } else {
      throw new Error("Unhandled character data diff type");
    }
  }
  if (secondLastToken === "attributes") {
    const nodePointer = new Pointer(grandParentTokens);
    const node = nodePointer.get(virtualStructure);
    let value;
    if (domDiff.op === "remove") {
      value = null;
    } else if (domDiff.op === "replace" || domDiff.op === "add") {
      value = domDiff.value;
    } else {
      throw new Error("Unhandled attribute diff type");
    }
    return [
      {
        type: "attributes",
        targetId: node.nodeId,
        attributes: {
          [lastToken]: value
        }
      }
    ];
  }
  if (secondLastToken === "childNodes") {
    const nodePointer = new Pointer(grandParentTokens);
    const node = nodePointer.get(virtualStructure);
    let previousSibling = null;
    if (lastToken === "-") {
      if (node.childNodes.length > 0) {
        previousSibling = node.childNodes[node.childNodes.length - 1];
      } else {
      }
    } else {
      const index = parseInt(lastToken, 10);
      if (index === 0) {
        previousSibling = null;
      } else {
        previousSibling = node.childNodes[index - 1];
      }
    }
    const addedNodes = [];
    const removedNodes = [];
    switch (domDiff.op) {
      case "add": {
        addedNodes.push(domDiff.value);
        return [
          {
            type: "childList",
            targetId: node.nodeId,
            addedNodes,
            removedNodeIds: [],
            previousSiblingId: previousSibling ? previousSibling.nodeId : null
          }
        ];
      }
      case "remove": {
        const removedNode = pointer.get(virtualStructure);
        removedNodes.push(removedNode);
        return [
          {
            type: "childList",
            targetId: node.nodeId,
            addedNodes,
            removedNodeIds: removedNodes.map((node2) => node2.nodeId),
            previousSiblingId: previousSibling ? previousSibling.nodeId : null
          }
        ];
      }
      case "replace": {
        const removedNode = pointer.get(virtualStructure);
        return [
          {
            type: "childList",
            targetId: node.nodeId,
            addedNodes: [],
            removedNodeIds: [removedNode.nodeId],
            previousSiblingId: previousSibling ? previousSibling.nodeId : null
          },
          {
            type: "childList",
            targetId: node.nodeId,
            addedNodes: [domDiff.value],
            removedNodeIds: [],
            previousSiblingId: previousSibling ? previousSibling.nodeId : null
          }
        ];
      }
    }
  }
  if (domDiff.op === "replace" && domDiff.path === "") {
    throw new Error("Not implemented - root node is not replaceable");
  }
  console.error("Unhandled JSON diff:", JSON.stringify(domDiff, null, 2));
  throw new Error("Unhandled diff type");
}

// src/NodeManager.ts
var NodeManager = class {
  constructor(visibilityManager) {
    this.visibilityManager = visibilityManager;
    this.nodeIdToNode = /* @__PURE__ */ new Map();
    this.maximumNodeId = 0;
    // Map from the node ids that the DOM uses internally to the node ids that clients refer to.
    this.internalNodeIdToClientNodeId = /* @__PURE__ */ new Map();
    // Map from the node ids that clients refer to to the node ids that the DOM uses internally.
    this.clientNodeIdToInternalNodeId = /* @__PURE__ */ new Map();
  }
  getNode(nodeId) {
    return this.nodeIdToNode.get(nodeId);
  }
  deleteNode(nodeId) {
    this.nodeIdToNode.delete(nodeId);
  }
  addNodeFromInstance(node, parentNode) {
    let hasSubjectivity = false;
    const nodeId = node.nodeId;
    if (this.nodeIdToNode.has(nodeId)) {
      throw new Error("Node already exists with id " + nodeId);
    }
    const parentSubjectivity = parentNode ? parentNode.subjectivity : {
      // Root node case
      visibleTo: /* @__PURE__ */ new Set(),
      hiddenFrom: /* @__PURE__ */ new Set(),
      ancestorSubjectivity: null
    };
    const visibleTo = listAttributeToSet(node.attributes[visibleToAttrName]);
    const hiddenFrom = listAttributeToSet(node.attributes[hiddenFromAttrName]);
    let subjectivity = parentSubjectivity;
    if (visibleTo.size > 0 || hiddenFrom.size > 0) {
      hasSubjectivity = true;
      subjectivity = {
        visibleTo,
        hiddenFrom,
        ancestorSubjectivity: parentSubjectivity
      };
      for (const connectionId of visibleTo) {
        this.visibilityManager.addSpecificallyVisibleNode(connectionId, nodeId);
      }
    }
    const attributes = { ...node.attributes };
    if (attributes[visibleToAttrName]) {
      delete attributes[visibleToAttrName];
    }
    if (attributes[hiddenFromAttrName]) {
      delete attributes[hiddenFromAttrName];
    }
    const nodeWithSubjectivity = {
      nodeId,
      tag: node.tag,
      textContent: node.textContent,
      attributes,
      childNodes: [],
      subjectivity,
      parent: parentNode
    };
    this.nodeIdToNode.set(nodeId, nodeWithSubjectivity);
    this.maximumNodeId = Math.max(this.maximumNodeId, nodeId);
    for (const childNode of node.childNodes) {
      const [addedChild, childSubjectivity] = this.addNodeFromInstance(
        childNode,
        nodeWithSubjectivity
      );
      if (childSubjectivity) {
        hasSubjectivity = true;
      }
      nodeWithSubjectivity.childNodes.push(addedChild);
    }
    return [nodeWithSubjectivity, hasSubjectivity];
  }
  addRemappedNodeId(clientFacingNodeId, internalNodeId) {
    if (this.internalNodeIdToClientNodeId.has(internalNodeId)) {
      throw new Error("Node already exists with internal node id " + internalNodeId);
    }
    if (this.clientNodeIdToInternalNodeId.has(clientFacingNodeId)) {
      throw new Error("Node already exists with client id " + clientFacingNodeId);
    }
    this.internalNodeIdToClientNodeId.set(internalNodeId, clientFacingNodeId);
    this.clientNodeIdToInternalNodeId.set(clientFacingNodeId, internalNodeId);
    this.maximumNodeId = Math.max(this.maximumNodeId, Math.max(clientFacingNodeId, internalNodeId));
  }
  hasAnyRemappings() {
    return this.internalNodeIdToClientNodeId.size > 0;
  }
  getPotentiallyRemappedNode(nodeId, createIfCollided = false) {
    const newId = this.internalNodeIdToClientNodeId.get(nodeId);
    if (newId !== void 0) {
      return newId;
    }
    if (createIfCollided) {
      if (this.nodeIdToNode.has(nodeId) || this.clientNodeIdToInternalNodeId.has(nodeId)) {
        const newId2 = ++this.maximumNodeId;
        this.addRemappedNodeId(newId2, nodeId);
        return newId2;
      }
      return nodeId;
    }
    return nodeId;
  }
  getStaticVirtualDOMElementByInternalNodeIdOrThrow(internalNodeId) {
    const node = this.nodeIdToNode.get(internalNodeId);
    if (!node) {
      throw new Error("Node not found with nodeId:" + internalNodeId);
    }
    return node;
  }
  getInternalRemappedNodeId(nodeId) {
    return this.clientNodeIdToInternalNodeId.get(nodeId);
  }
};

// src/VisibilityManager.ts
var VisibilityManager = class {
  constructor() {
    this.connectionIdToSpecificallyVisibleNodes = /* @__PURE__ */ new Map();
  }
  addSpecificallyVisibleNode(internalConnectionId, nodeId) {
    let connectionIdNodes = this.connectionIdToSpecificallyVisibleNodes.get(internalConnectionId);
    if (!connectionIdNodes) {
      connectionIdNodes = /* @__PURE__ */ new Set();
      this.connectionIdToSpecificallyVisibleNodes.set(internalConnectionId, connectionIdNodes);
    }
    connectionIdNodes.add(nodeId);
  }
  removeSpecificallyVisibleNode(internalConnectionId, nodeId) {
    const connectionIdNodes = this.connectionIdToSpecificallyVisibleNodes.get(internalConnectionId);
    if (connectionIdNodes) {
      connectionIdNodes.delete(nodeId);
      if (connectionIdNodes.size === 0) {
        this.connectionIdToSpecificallyVisibleNodes.delete(internalConnectionId);
      }
    }
  }
  getSpecificallyVisibleNodes(internalConnectionId) {
    return this.connectionIdToSpecificallyVisibleNodes.get(internalConnectionId);
  }
};

// src/NetworkedDOM.ts
var VisibleToMode = /* @__PURE__ */ Symbol("VisibleToMode");
var HiddenFromMode = /* @__PURE__ */ Symbol("HiddenFromMode");
var NetworkedDOM = class {
  constructor(observableDOMFactory, htmlPath, htmlContents, oldInstanceDocumentRoot, onLoad, params = {}, ignoreTextNodes = true, logCallback) {
    this.visibilityManager = new VisibilityManager();
    this.nodeManager = new NodeManager(this.visibilityManager);
    this.currentConnectionId = 1;
    this.connectionIdToNetworkedDOMConnection = /* @__PURE__ */ new Map();
    this.networkedDOMV01Connections = /* @__PURE__ */ new Set();
    this.networkedDOMV02Connections = /* @__PURE__ */ new Set();
    this.webSocketToNetworkedDOMConnection = /* @__PURE__ */ new Map();
    this.initialLoad = true;
    this.documentEffectiveStartTime = Date.now();
    this.latestDocumentTime = 0;
    this.pingCounter = 1;
    this.disposed = false;
    this.htmlPath = htmlPath;
    this.ignoreTextNodes = ignoreTextNodes;
    this.logCallback = logCallback || this.defaultLogCallback;
    this.observableDOM = observableDOMFactory(
      {
        htmlPath,
        htmlContents,
        params,
        ignoreTextNodes,
        pingIntervalMilliseconds: 5e3
      },
      (message, observableDOM) => {
        if (this.disposed) {
          return;
        }
        this.observableDOM = observableDOM;
        if (message.documentTime) {
          this.documentEffectiveStartTime = Date.now() - message.documentTime;
          this.latestDocumentTime = message.documentTime;
        }
        if (message.snapshot) {
          const clonedSnapshot = JSON.parse(JSON.stringify(message.snapshot));
          if (!this.initialLoad) {
            throw new Error("Received snapshot after initial load");
          }
          this.initialLoad = false;
          let domDiff = null;
          if (oldInstanceDocumentRoot) {
            domDiff = calculateStaticVirtualDOMDiff(
              JSON.parse(JSON.stringify(oldInstanceDocumentRoot)),
              clonedSnapshot
            );
            for (const remapping of domDiff.nodeIdRemappings) {
              this.nodeManager.addRemappedNodeId(
                remapping.clientFacingNodeId,
                remapping.internalNodeId
              );
            }
            const [mappedRootNode] = this.nodeManager.addNodeFromInstance(
              JSON.parse(JSON.stringify(oldInstanceDocumentRoot)),
              null
            );
            this.documentRoot = mappedRootNode;
          } else {
            const [mappedRootNode] = this.nodeManager.addNodeFromInstance(
              JSON.parse(JSON.stringify(message.snapshot)),
              null
            );
            this.documentRoot = mappedRootNode;
          }
          onLoad(domDiff, this);
        } else if (message.mutations) {
          if (this.initialLoad) {
            throw new Error("Received mutation before initial load");
          }
          const merged = mergeMutations(message.mutations);
          if (merged.length > 1) {
            for (const client of this.networkedDOMV02Connections) {
              client.setBatchStart();
            }
          }
          for (const mutation of merged) {
            this.handleMutation(mutation);
          }
          if (merged.length > 1) {
            for (const client of this.networkedDOMV02Connections) {
              client.setBatchEnd();
            }
          }
        } else if (message.logMessage) {
          if (this.logCallback) {
            this.logCallback(message.logMessage);
          }
        } else {
          if (message.documentTime) {
            this.sendPings();
            return;
          }
          console.error("Unknown message type from observableDOM", message);
        }
      }
    );
  }
  static handleWebsocketSubprotocol(protocols) {
    const protocolsSet = new Set(protocols);
    for (const protocol of SupportedWebsocketSubProtocolsPreferenceOrder) {
      if (protocolsSet.has(protocol)) {
        return protocol;
      }
    }
    return false;
  }
  addWebSocket(webSocket) {
    const networkedDOMConnection = createNetworkedDOMConnectionForWebsocket(webSocket);
    if (networkedDOMConnection === null) {
      return;
    }
    this.addNetworkedDOMConnection(networkedDOMConnection);
  }
  removeWebSocket(webSocket) {
    const networkedDOMConnection = this.webSocketToNetworkedDOMConnection.get(webSocket);
    if (networkedDOMConnection === void 0) {
      throw new Error("Unknown websocket");
    }
    this.removeNetworkedDOMConnection(networkedDOMConnection);
  }
  hasWebSocket(webSocket) {
    return this.webSocketToNetworkedDOMConnection.has(webSocket);
  }
  addExistingNetworkedDOMConnections(networkedDOMConnections, domDiff) {
    for (const networkedDOMConnection of networkedDOMConnections) {
      if (networkedDOMConnection instanceof NetworkedDOMV01Connection) {
        networkedDOMConnection.setNetworkedDOM(this);
        this.networkedDOMV01Connections.add(networkedDOMConnection);
        this.webSocketToNetworkedDOMConnection.set(
          networkedDOMConnection.webSocket,
          networkedDOMConnection
        );
      } else if (networkedDOMConnection instanceof NetworkedDOMV02Connection) {
        networkedDOMConnection.setNetworkedDOM(this);
        this.webSocketToNetworkedDOMConnection.set(
          networkedDOMConnection.webSocket,
          networkedDOMConnection
        );
        for (const connectionId of networkedDOMConnection.internalIdToExternalId.keys()) {
          this.connectionIdToNetworkedDOMConnection.set(connectionId, networkedDOMConnection);
        }
        this.networkedDOMV02Connections.add(networkedDOMConnection);
      } else {
        throw new Error("Unknown websocket subprotocol");
      }
    }
    for (const networkedDOMConnection of this.networkedDOMV02Connections) {
      for (const [connectionId, token] of networkedDOMConnection.internalIdToToken) {
        if (connectionId >= this.currentConnectionId) {
          this.currentConnectionId = connectionId + 1;
        }
        this.observableDOM.addConnectedUserId(connectionId, token);
      }
    }
    for (const networkedDOMConnection of this.networkedDOMV01Connections) {
      if (networkedDOMConnection.internalConnectionId === null) {
        networkedDOMConnection.initAsNewV01Connection();
      }
      this.observableDOM.addConnectedUserId(networkedDOMConnection.internalConnectionId, null);
    }
    for (const networkedDOMConnection of this.networkedDOMV02Connections) {
      networkedDOMConnection.handleBufferedMessages();
    }
    if (domDiff) {
      const emptyChildrenChanged = [
        {
          type: "childrenChanged",
          nodeId: this.documentRoot.nodeId,
          previousNodeId: null,
          addedNodes: [],
          removedNodes: [],
          documentTime: this.getDocumentTime()
        }
      ];
      const encoded = JSON.stringify(emptyChildrenChanged);
      for (const networkedDOMV01Connection of this.networkedDOMV01Connections) {
        networkedDOMV01Connection.sendStringifiedJSONArray(encoded);
      }
      const encodedDocumentTime = encodeDocumentTime({
        type: "documentTime",
        documentTime: this.getDocumentTime()
      }).getBuffer();
      for (const networkedDOMV02Connection of this.networkedDOMV02Connections) {
        networkedDOMV02Connection.sendEncodedBytes(encodedDocumentTime);
      }
      const virtualDOMDiff = domDiff.virtualDOMDiffs[0];
      if (domDiff.virtualDOMDiffs.length === 1 && virtualDOMDiff.op === "replace" && virtualDOMDiff.path === "" && virtualDOMDiff.value.tag === "div" && virtualDOMDiff.value.childNodes.length === 0) {
        const rootChildrenIds = this.documentRoot.childNodes.map((child) => child.nodeId);
        this.handleMutation(
          {
            type: "childList",
            targetId: this.documentRoot.nodeId,
            addedNodes: [],
            removedNodeIds: rootChildrenIds,
            previousSiblingId: null
          },
          false
        );
      } else {
        for (const virtualDOMDiff2 of domDiff.virtualDOMDiffs) {
          const mutationRecordLikes = virtualDOMDiffToVirtualDOMMutationRecord(
            domDiff.originalState,
            virtualDOMDiff2
          );
          if (virtualDOMDiff2.path === "" && virtualDOMDiff2.op === "replace") {
          } else {
            const patchResults = applyPatch(domDiff.originalState, [virtualDOMDiff2]);
            for (const patchResult of patchResults) {
              if (patchResult !== null) {
                console.error("Patching virtual dom structure resulted in error", patchResult);
                throw patchResult;
              }
            }
          }
          const merged = mergeMutations(mutationRecordLikes);
          for (const mutation of merged) {
            this.handleMutation(mutation, false);
          }
        }
      }
    } else {
      const documentVirtualDOMElement = this.documentRoot;
      if (!documentVirtualDOMElement) {
        throw new Error(`documentVirtualDOMElement not found in getInitialSnapshot`);
      }
      for (const networkedDOMConnection of this.networkedDOMV01Connections) {
        networkedDOMConnection.stringifyAndSendSingleMessage(
          this.getInitialV01Snapshot(networkedDOMConnection, documentVirtualDOMElement)
        );
      }
      for (const networkedDOMConnection of this.networkedDOMV02Connections) {
        networkedDOMConnection.sendMessage(
          this.getInitialV02Snapshot(networkedDOMConnection, documentVirtualDOMElement)
        );
      }
    }
  }
  addNetworkedDOMConnection(networkedDOMConnection) {
    if (this.initialLoad) {
      throw new Error("addWebSocket called before initial load - unsupported at this time");
    }
    if (this.disposed) {
      throw new Error("This NetworkedDOM has been disposed");
    }
    const documentVirtualDOMElement = this.documentRoot;
    if (!documentVirtualDOMElement) {
      throw new Error(`documentVirtualDOMElement not found in getInitialSnapshot`);
    }
    networkedDOMConnection.setNetworkedDOM(this);
    if (networkedDOMConnection instanceof NetworkedDOMV01Connection) {
      if (networkedDOMConnection.internalConnectionId === null) {
        networkedDOMConnection.initAsNewV01Connection();
      }
      this.networkedDOMV01Connections.add(networkedDOMConnection);
      this.webSocketToNetworkedDOMConnection.set(
        networkedDOMConnection.webSocket,
        networkedDOMConnection
      );
      networkedDOMConnection.stringifyAndSendSingleMessage(
        this.getInitialV01Snapshot(networkedDOMConnection, documentVirtualDOMElement)
      );
    } else {
      this.networkedDOMV02Connections.add(networkedDOMConnection);
      this.webSocketToNetworkedDOMConnection.set(
        networkedDOMConnection.webSocket,
        networkedDOMConnection
      );
      for (const [connectionId, token] of networkedDOMConnection.internalIdToToken) {
        this.observableDOM.addConnectedUserId(connectionId, token);
      }
      networkedDOMConnection.sendMessage(
        this.getInitialV02Snapshot(networkedDOMConnection, documentVirtualDOMElement)
      );
    }
  }
  removeNetworkedDOMConnection(networkedDOMConnection) {
    if (networkedDOMConnection instanceof NetworkedDOMV01Connection) {
      if (!this.networkedDOMV01Connections.has(networkedDOMConnection)) {
        throw new Error("Unrecognized networkedDOMConnection");
      }
      if (networkedDOMConnection.internalConnectionId !== null) {
        this.observableDOM.removeConnectedUserId(networkedDOMConnection.internalConnectionId);
        this.connectionIdToNetworkedDOMConnection.delete(
          networkedDOMConnection.internalConnectionId
        );
      }
      this.networkedDOMV01Connections.delete(networkedDOMConnection);
      this.webSocketToNetworkedDOMConnection.delete(networkedDOMConnection.webSocket);
      networkedDOMConnection.setNetworkedDOM(null);
    } else if (networkedDOMConnection instanceof NetworkedDOMV02Connection) {
      if (!this.networkedDOMV02Connections.has(networkedDOMConnection)) {
        throw new Error("Unrecognized networkedDOMConnection");
      }
      for (const [internalConnectionId] of networkedDOMConnection.internalIdToExternalId) {
        this.observableDOM.removeConnectedUserId(internalConnectionId);
        this.connectionIdToNetworkedDOMConnection.delete(internalConnectionId);
      }
      this.networkedDOMV02Connections.delete(networkedDOMConnection);
      this.webSocketToNetworkedDOMConnection.delete(networkedDOMConnection.webSocket);
      networkedDOMConnection.setNetworkedDOM(null);
    }
  }
  connectUsers(networkedDOMConnection, addedExternalUserIds) {
    const connectionIdToExternalId = /* @__PURE__ */ new Map();
    for (const externalId of addedExternalUserIds) {
      const internalId = this.currentConnectionId++;
      this.connectionIdToNetworkedDOMConnection.set(internalId, networkedDOMConnection);
      connectionIdToExternalId.set(internalId, externalId);
    }
    return connectionIdToExternalId;
  }
  // Called by the connections after storing the mapping of connected users ids
  announceConnectedUsers(userIds) {
    for (const [userId, token] of userIds) {
      this.observableDOM.addConnectedUserId(userId, token);
    }
  }
  disconnectUsers(networkedDOMConnection, removedExternalToInternalUserIds) {
    const potentiallyAffectedNodeIds = /* @__PURE__ */ new Set();
    for (const [, removingInternalId] of removedExternalToInternalUserIds) {
      const affectedNodes = this.visibilityManager.getSpecificallyVisibleNodes(removingInternalId);
      if (affectedNodes) {
        for (const nodeId of affectedNodes) {
          potentiallyAffectedNodeIds.add(nodeId);
        }
      }
    }
    for (const nodeId of potentiallyAffectedNodeIds) {
      const node = this.nodeManager.getNode(nodeId);
      if (!node) {
        console.error("node not found", nodeId);
        continue;
      }
      if (node.subjectivity != null && !IsVisibleToAnyOneOfConnectionIds(
        node.subjectivity,
        networkedDOMConnection.internalIdToExternalId,
        false
      )) {
        potentiallyAffectedNodeIds.delete(nodeId);
      }
    }
    for (const [removingExternalId, removingInternalId] of removedExternalToInternalUserIds) {
      this.observableDOM.removeConnectedUserId(removingInternalId);
      networkedDOMConnection.externalConnectionIds.delete(removingExternalId);
      networkedDOMConnection.externalIdToInternalId.delete(removingExternalId);
      networkedDOMConnection.internalIdToExternalId.delete(removingInternalId);
      networkedDOMConnection.internalIdToToken.delete(removingInternalId);
      this.connectionIdToNetworkedDOMConnection.delete(removingInternalId);
    }
    const removedMessagesByParent = /* @__PURE__ */ new Map();
    for (const nodeId of potentiallyAffectedNodeIds) {
      const node = this.nodeManager.getNode(nodeId);
      if (!node) {
        console.error("node not found", nodeId);
        continue;
      }
      if (node.subjectivity != null && !IsVisibleToAnyOneOfConnectionIds(
        node.subjectivity,
        networkedDOMConnection.internalIdToExternalId,
        false
      )) {
        if (node.parent != null && (node.parent.subjectivity == null || IsVisibleToAnyOneOfConnectionIds(
          node.parent.subjectivity,
          networkedDOMConnection.internalIdToExternalId,
          false
        ))) {
          let existingMessage = removedMessagesByParent.get(node.parent.nodeId);
          if (!existingMessage) {
            existingMessage = {
              type: "childrenRemoved",
              nodeId: node.parent.nodeId,
              removedNodes: []
            };
            removedMessagesByParent.set(node.parent.nodeId, existingMessage);
          }
          existingMessage.removedNodes.push(nodeId);
        }
      }
    }
    return Array.from(removedMessagesByParent.values());
  }
  defaultLogCallback(message) {
    const getLogFn = (level) => {
      switch (level) {
        case "system":
          return console.error;
        case "error":
          return console.error;
        case "warn":
          return console.warn;
        case "log":
          return console.log;
        case "info":
          return console.info;
        default:
          return console.log;
      }
    };
    const logFn = getLogFn(message.level);
    logFn(`${message.level.toUpperCase()} (${this.htmlPath}):`, ...message.content);
  }
  sendPings() {
    const ping = this.pingCounter++;
    if (this.pingCounter > 1e3) {
      this.pingCounter = 1;
    }
    const v01PingMessage = [
      {
        type: "ping",
        ping,
        documentTime: this.getDocumentTime()
      }
    ];
    const v01Encoded = JSON.stringify(v01PingMessage);
    const v02PingMessage = {
      type: "ping",
      ping,
      documentTime: this.getDocumentTime()
    };
    const writer = new BufferWriter2(8);
    encodePing(v02PingMessage, writer);
    const v02Encoded = writer.getBuffer();
    this.networkedDOMV01Connections.forEach((networkedDOMConnection) => {
      networkedDOMConnection.webSocket.send(v01Encoded);
    });
    this.networkedDOMV02Connections.forEach((networkedDOMConnection) => {
      networkedDOMConnection.webSocket.send(v02Encoded);
    });
  }
  getInitialV01Snapshot(networkedDOMConnection, documentVirtualDOMElement) {
    const domSnapshot = describeNodeWithChildrenForV01Connection(documentVirtualDOMElement, networkedDOMConnection);
    if (!domSnapshot) {
      throw new Error(`domSnapshot was not generated`);
    }
    return {
      type: "snapshot",
      snapshot: domSnapshot,
      documentTime: Date.now() - this.documentEffectiveStartTime
    };
  }
  getInitialV02Snapshot(networkedDOMConnection, documentVirtualDOMElement) {
    const domSnapshot = describeNodeWithChildrenForV02Connection(documentVirtualDOMElement, networkedDOMConnection);
    if (!domSnapshot) {
      throw new Error(`domSnapshot was not generated`);
    }
    return {
      type: "snapshot",
      snapshot: domSnapshot,
      documentTime: Date.now() - this.documentEffectiveStartTime
    };
  }
  getDocumentTime() {
    return this.latestDocumentTime;
  }
  dispatchRemoteEvent(networkedDOMConnection, internalConnectionId, externalConnectionId, remoteEvent) {
    if (this.disposed) {
      console.error("Cannot dispatch remote event after dispose");
      throw new Error("This NetworkedDOM has been disposed");
    }
    const node = this.nodeManager.getStaticVirtualDOMElementByInternalNodeIdOrThrow(
      remoteEvent.nodeId
    );
    if (!node || !IsVisibleToAnyOneOfConnectionIds(
      node.subjectivity,
      /* @__PURE__ */ new Map([[internalConnectionId, 1]]),
      true
    )) {
      if (networkedDOMConnection instanceof NetworkedDOMV01Connection) {
        networkedDOMConnection.stringifyAndSendSingleMessage({
          type: "warning",
          message: `Node ${remoteEvent.nodeId} not found or not visible`
        });
      } else if (networkedDOMConnection instanceof NetworkedDOMV02Connection) {
        networkedDOMConnection.sendMessage({
          type: "warning",
          message: `Node ${remoteEvent.nodeId} not found or not visible to connection ${externalConnectionId}`
        });
      } else {
        console.error("Unknown networkedDOMConnection type. Cannot send warning.");
      }
      return;
    }
    const remappedNode = this.nodeManager.getInternalRemappedNodeId(remoteEvent.nodeId);
    if (remappedNode) {
      remoteEvent.nodeId = remappedNode;
    }
    this.observableDOM.dispatchRemoteEventFromConnectionId(internalConnectionId, remoteEvent);
  }
  getSnapshot() {
    function toStaticVirtualDOMElement(node) {
      const attributes = { ...node.attributes };
      const hasOwnSubjectivity = node.parent && node.subjectivity !== node.parent.subjectivity;
      if (hasOwnSubjectivity) {
        if (node.subjectivity.visibleTo.size > 0) {
          attributes[visibleToAttrName] = Array.from(node.subjectivity.visibleTo).join(" ");
        }
        if (node.subjectivity.hiddenFrom.size > 0) {
          attributes[hiddenFromAttrName] = Array.from(node.subjectivity.hiddenFrom).join(" ");
        }
      }
      return {
        nodeId: node.nodeId,
        tag: node.tag,
        textContent: node.textContent,
        attributes,
        childNodes: node.childNodes.map(toStaticVirtualDOMElement)
      };
    }
    return toStaticVirtualDOMElement(this.documentRoot);
  }
  dispose() {
    this.disposed = true;
    for (const networkedDOMConnection of this.networkedDOMV01Connections) {
      networkedDOMConnection.setNetworkedDOM(null);
    }
    for (const networkedDOMConnection of this.networkedDOMV02Connections) {
      networkedDOMConnection.setNetworkedDOM(null);
    }
    this.observableDOM.dispose();
  }
  handleAddedNodes(targetId, previousSiblingId, addedNodes) {
    const target = this.nodeManager.getStaticVirtualDOMElementByInternalNodeIdOrThrow(targetId);
    if (!target) {
      console.error("Target node not found for mutation", targetId);
      return;
    }
    let hasSubjectiveChildren = false;
    let previousNodeIdIsSubjectiveForV01 = false;
    let previousNodeIdIsSubjectiveForV02 = false;
    const parentIsSubjectiveForV01 = target.subjectivity != null && !IsVisibleToAll(target.subjectivity, true);
    const parentIsSubjectiveForV02 = target.subjectivity != null && !IsVisibleToAll(target.subjectivity, false);
    const addedNodesWithSubjectivity = [];
    let previousNode = null;
    let previousNodeIndex = -1;
    if (previousSiblingId != null) {
      previousNode = this.nodeManager.getStaticVirtualDOMElementByInternalNodeIdOrThrow(previousSiblingId) || null;
      if (!previousNode) {
        throw new Error("previous node not found: " + previousSiblingId);
      } else {
        previousNodeIdIsSubjectiveForV01 = previousNode.subjectivity != null && !IsVisibleToAll(previousNode.subjectivity, true);
        previousNodeIdIsSubjectiveForV02 = previousNode.subjectivity != null && !IsVisibleToAll(previousNode.subjectivity, false);
        for (let i = 0; i < target.childNodes.length; i++) {
          const child = target.childNodes[i];
          if (child.nodeId === previousNode.nodeId) {
            previousNodeIndex = i;
            break;
          }
        }
      }
    }
    for (const addedNode of addedNodes) {
      const [addedNodeWithSubjectivity, addedNodeHasSubjectivity] = this.nodeManager.addNodeFromInstance(addedNode, target);
      if (addedNodeHasSubjectivity) {
        hasSubjectiveChildren = true;
      }
      if (addedNodeWithSubjectivity != null) {
        addedNodesWithSubjectivity.push(addedNodeWithSubjectivity);
      }
    }
    if (previousNode !== null) {
      let index = previousNodeIndex + 1;
      for (const childVirtualDOMElement of addedNodesWithSubjectivity) {
        target.childNodes.splice(index, 0, childVirtualDOMElement);
        index++;
      }
    } else {
      target.childNodes = addedNodesWithSubjectivity.concat(target.childNodes);
    }
    if (parentIsSubjectiveForV01 || hasSubjectiveChildren || previousNodeIdIsSubjectiveForV01) {
      for (const client of this.networkedDOMV01Connections) {
        const canSeeParent = target.subjectivity == null || IsVisibleToAnyOneOfConnectionIds(
          target.subjectivity,
          client.internalIdToExternalId,
          true
        );
        if (!canSeeParent) {
          continue;
        }
        let projectedPreviousNodeId = null;
        if (previousNode != null) {
          if (previousNodeIdIsSubjectiveForV01) {
            for (let i = previousNodeIndex; i >= 0; i--) {
              const child = target.childNodes[i];
              if (child.subjectivity == null || IsVisibleToAnyOneOfConnectionIds(
                child.subjectivity,
                client.internalIdToExternalId,
                true
              )) {
                projectedPreviousNodeId = child.nodeId;
                break;
              }
            }
          } else {
            projectedPreviousNodeId = previousNode.nodeId;
          }
        }
        const projectedChildren = [];
        for (const addedNode of addedNodesWithSubjectivity) {
          if (addedNode.subjectivity == null || IsVisibleToAnyOneOfConnectionIds(
            addedNode.subjectivity,
            client.internalIdToExternalId,
            true
          )) {
            const node = describeNodeWithChildrenForV01Connection(addedNode, client);
            if (node != null) {
              projectedChildren.push(node);
            }
          }
        }
        if (projectedChildren.length > 0) {
          client.stringifyAndSendSingleMessage({
            type: "childrenChanged",
            nodeId: target.nodeId,
            previousNodeId: projectedPreviousNodeId,
            addedNodes: projectedChildren,
            removedNodes: []
          });
        }
      }
    } else {
      if (this.networkedDOMV01Connections.size > 0) {
        const projectedChildren = [];
        for (const addedNode of addedNodesWithSubjectivity) {
          const node = describeNodeWithChildrenForV01Connection(addedNode, null);
          if (node !== null) {
            projectedChildren.push(node);
          }
        }
        const reprojectedMsg = {
          type: "childrenChanged",
          nodeId: target.nodeId,
          previousNodeId: previousNode ? previousNode.nodeId : null,
          addedNodes: projectedChildren,
          removedNodes: []
        };
        const encoded = JSON.stringify([reprojectedMsg]);
        for (const client of this.networkedDOMV01Connections) {
          client.sendStringifiedJSONArray(encoded);
        }
      }
    }
    if (parentIsSubjectiveForV02 || hasSubjectiveChildren || previousNodeIdIsSubjectiveForV02) {
      for (const client of this.networkedDOMV02Connections) {
        const canSeeParent = target.subjectivity == null || IsVisibleToAnyOneOfConnectionIds(
          target.subjectivity,
          client.internalIdToExternalId,
          false
        );
        if (!canSeeParent) {
          continue;
        }
        let projectedPreviousNodeId = null;
        if (previousNode != null) {
          if (previousNodeIdIsSubjectiveForV02) {
            for (let i = previousNodeIndex; i >= 0; i--) {
              const child = target.childNodes[i];
              if (child.subjectivity == null || IsVisibleToAnyOneOfConnectionIds(
                child.subjectivity,
                client.internalIdToExternalId,
                false
              )) {
                projectedPreviousNodeId = child.nodeId;
                break;
              }
            }
          } else {
            projectedPreviousNodeId = previousNode.nodeId;
          }
        }
        const projectedChildren = [];
        for (const addedNode of addedNodesWithSubjectivity) {
          if (addedNode.subjectivity == null || IsVisibleToAnyOneOfConnectionIds(
            addedNode.subjectivity,
            client.internalIdToExternalId,
            false
          )) {
            const node = describeNodeWithChildrenForV02Connection(addedNode, client);
            if (node != null) {
              projectedChildren.push(node);
            }
          }
        }
        if (projectedChildren.length > 0) {
          client.sendMessage({
            type: "childrenAdded",
            nodeId: target.nodeId,
            previousNodeId: projectedPreviousNodeId === null ? 0 : projectedPreviousNodeId,
            addedNodes: projectedChildren
          });
        }
      }
    } else {
      const projectedChildren = [];
      for (const addedNode of addedNodesWithSubjectivity) {
        const node = describeNodeWithChildrenForV02Connection(addedNode, null);
        if (node != null) {
          projectedChildren.push(node);
        }
      }
      const encoded = encodeChildrenAdded({
        type: "childrenAdded",
        nodeId: target.nodeId,
        previousNodeId: previousNode === null ? 0 : previousNode.nodeId,
        addedNodes: projectedChildren
      }).getBuffer();
      for (const client of this.networkedDOMV02Connections) {
        client.sendEncodedBytes(encoded);
      }
    }
  }
  handleRemovedNodes(targetId, removedNodeIds) {
    const node = this.nodeManager.getStaticVirtualDOMElementByInternalNodeIdOrThrow(targetId);
    if (!node) {
      console.error("Target node not found for mutation", targetId);
      return;
    }
    const parentIsSubjectiveForV01 = node.subjectivity != null && !IsVisibleToAll(node.subjectivity, true);
    let anyChildIsSubjectiveForV01 = false;
    const parentIsSubjectiveForV02 = node.subjectivity != null && !IsVisibleToAll(node.subjectivity, false);
    let anyChildIsSubjectiveForV02 = false;
    const removedSet = new Set(removedNodeIds);
    for (let i = 0; i < node.childNodes.length; i++) {
      const child = node.childNodes[i];
      if (removedSet.has(child.nodeId)) {
        if (child.subjectivity != null && !IsVisibleToAll(child.subjectivity, true)) {
          anyChildIsSubjectiveForV01 = true;
        }
        if (child.subjectivity != null && !IsVisibleToAll(child.subjectivity, false)) {
          anyChildIsSubjectiveForV02 = true;
        }
        node.childNodes.splice(i, 1);
        break;
      }
    }
    if (parentIsSubjectiveForV01 || anyChildIsSubjectiveForV01) {
      for (const client of this.networkedDOMV01Connections) {
        const removableChildren = [];
        for (const removedNodeId of removedNodeIds) {
          const child = this.nodeManager.getStaticVirtualDOMElementByInternalNodeIdOrThrow(removedNodeId);
          if (!child) {
            throw new Error("Child not found for removed node id: " + removedNodeId);
          }
          if (child.subjectivity == null || IsVisibleToAnyOneOfConnectionIds(
            child.subjectivity,
            client.internalIdToExternalId,
            true
          )) {
            removableChildren.push(removedNodeId);
          }
        }
        if (removableChildren.length > 0) {
          client.stringifyAndSendSingleMessage({
            type: "childrenChanged",
            nodeId: node.nodeId,
            addedNodes: [],
            previousNodeId: null,
            removedNodes: removableChildren
          });
        }
      }
    } else {
      if (this.networkedDOMV01Connections.size > 0) {
        const msg = {
          type: "childrenChanged",
          nodeId: node.nodeId,
          addedNodes: [],
          previousNodeId: null,
          removedNodes: removedNodeIds
        };
        const encoded = JSON.stringify([msg]);
        for (const client of this.networkedDOMV01Connections) {
          client.sendStringifiedJSONArray(encoded);
        }
      }
    }
    if (parentIsSubjectiveForV02 || anyChildIsSubjectiveForV02) {
      for (const client of this.networkedDOMV02Connections) {
        const removableChildren = [];
        for (const removedNodeId of removedNodeIds) {
          const child = this.nodeManager.getStaticVirtualDOMElementByInternalNodeIdOrThrow(removedNodeId);
          if (!child) {
            throw new Error("Child not found for removed node id: " + removedNodeId);
          }
          if (child.subjectivity == null || IsVisibleToAnyOneOfConnectionIds(
            child.subjectivity,
            client.internalIdToExternalId,
            false
          )) {
            removableChildren.push(removedNodeId);
          }
        }
        if (removableChildren.length > 0) {
          client.sendMessage({
            type: "childrenRemoved",
            nodeId: node.nodeId,
            removedNodes: removableChildren
          });
        }
      }
    } else {
      const msg = {
        type: "childrenRemoved",
        nodeId: node.nodeId,
        removedNodes: removedNodeIds
      };
      const encoded = encodeChildrenRemoved(msg).getBuffer();
      for (const client of this.networkedDOMV02Connections) {
        client.sendEncodedBytes(encoded);
      }
    }
    for (const removedNodeId of removedNodeIds) {
      this.removeNodeAndChildren(removedNodeId);
    }
  }
  handleAttributeMutation(targetId, attributes) {
    var _a;
    const target = this.nodeManager.getStaticVirtualDOMElementByInternalNodeIdOrThrow(targetId);
    if (!target) {
      console.error("Target node not found for mutation", targetId);
      return;
    }
    const resultAttributes = {};
    for (const [key, value] of Object.entries(attributes)) {
      if (key === visibleToAttrName) {
        const hasOwnSubjectivity = target.subjectivity !== ((_a = target.parent) == null ? void 0 : _a.subjectivity);
        const previousSet = hasOwnSubjectivity ? target.subjectivity.visibleTo : /* @__PURE__ */ new Set();
        const newVisibleTo = listAttributeToSet(value);
        const added = new Set(Array.from(newVisibleTo).filter((x) => !previousSet.has(x)));
        const removed = new Set(Array.from(previousSet).filter((x) => !newVisibleTo.has(x)));
        this.handleVisibleToChange(targetId, added, removed);
        continue;
      }
      if (key === hiddenFromAttrName) {
        const hasOwnSubjectivity = target.subjectivity !== target.parent.subjectivity;
        const previousSet = hasOwnSubjectivity ? target.subjectivity.hiddenFrom : /* @__PURE__ */ new Set();
        const newHiddenFrom = listAttributeToSet(value);
        const added = new Set(Array.from(newHiddenFrom).filter((x) => !previousSet.has(x)));
        const removed = new Set(Array.from(previousSet).filter((x) => !newHiddenFrom.has(x)));
        this.handleHiddenFromChange(targetId, added, removed);
        continue;
      }
      const existingAttribute = target.attributes[key];
      if (value !== null) {
        if (existingAttribute === value) {
          continue;
        }
      } else {
        if (existingAttribute === void 0) {
          continue;
        }
      }
      resultAttributes[key] = value;
    }
    if (Object.keys(resultAttributes).length > 0) {
      this.handleAttributeChange(targetId, resultAttributes);
    }
  }
  handleAttributeChange(targetId, attributes) {
    const node = this.nodeManager.getStaticVirtualDOMElementByInternalNodeIdOrThrow(targetId);
    if (!node) {
      console.error("Target node not found for mutation", targetId);
      return;
    }
    const nodeIsSubjectiveForV01 = node.subjectivity != null && !IsVisibleToAll(node.subjectivity, true);
    const nodeIsSubjectiveForV02 = node.subjectivity != null && !IsVisibleToAll(node.subjectivity, false);
    for (const [attributeName, value] of Object.entries(attributes)) {
      if (value !== null) {
        node.attributes[attributeName] = value;
      } else {
        delete node.attributes[attributeName];
      }
    }
    if (this.networkedDOMV01Connections.size > 0) {
      const allMessages = [];
      for (const [attributeName, value] of Object.entries(attributes)) {
        const reprojectedMsg = {
          type: "attributeChange",
          nodeId: node.nodeId,
          attribute: attributeName,
          newValue: value
        };
        allMessages.push(reprojectedMsg);
      }
      const encoded2 = JSON.stringify(allMessages);
      if (nodeIsSubjectiveForV01) {
        for (const client of this.networkedDOMV01Connections) {
          const canSee = node.subjectivity == null || IsVisibleToAnyOneOfConnectionIds(
            node.subjectivity,
            client.internalIdToExternalId,
            true
          );
          if (canSee) {
            client.sendStringifiedJSONArray(encoded2);
          }
        }
      } else {
        for (const client of this.networkedDOMV01Connections) {
          client.sendStringifiedJSONArray(encoded2);
        }
      }
    }
    const message = {
      type: "attributesChanged",
      nodeId: node.nodeId,
      attributes: Object.entries(attributes).map(([attribute, value]) => [attribute, value])
    };
    const encoded = encodeAttributesChanged(message).getBuffer();
    if (nodeIsSubjectiveForV02) {
      for (const client of this.networkedDOMV02Connections) {
        const canSee = node.subjectivity == null || IsVisibleToAnyOneOfConnectionIds(node.subjectivity, client.internalIdToExternalId, false);
        if (canSee) {
          client.sendEncodedBytes(encoded);
        }
      }
    } else {
      for (const client of this.networkedDOMV02Connections) {
        client.sendEncodedBytes(encoded);
      }
    }
  }
  handleVisibleToChange(targetId, added, removed) {
    const node = this.nodeManager.getStaticVirtualDOMElementByInternalNodeIdOrThrow(targetId);
    if (!node) {
      console.error("Target node not found for mutation", targetId);
      return;
    }
    if (node.parent == null) {
      return;
    }
    const previousSubjectivity = node.subjectivity;
    const visibilityRecords = this.calculatePreVisibilityChangeRecords(node);
    for (const internalConnectionId of removed) {
      this.visibilityManager.removeSpecificallyVisibleNode(internalConnectionId, node.nodeId);
    }
    const newVisibleTo = /* @__PURE__ */ new Set();
    for (const internalConnectionId of added) {
      newVisibleTo.add(internalConnectionId);
      this.visibilityManager.addSpecificallyVisibleNode(internalConnectionId, node.nodeId);
    }
    const hasNonInheritedSubjectivity = previousSubjectivity != null && previousSubjectivity !== node.parent.subjectivity;
    if (hasNonInheritedSubjectivity) {
      for (const connectionId of previousSubjectivity.visibleTo) {
        if (!removed.has(connectionId)) {
          newVisibleTo.add(connectionId);
        }
      }
    }
    if (hasNonInheritedSubjectivity) {
      node.subjectivity.visibleTo = newVisibleTo;
      if (newVisibleTo.size === 0 && node.subjectivity.hiddenFrom.size === 0) {
        if (!node.subjectivity.ancestorSubjectivity) {
          throw new Error("Expected ancestorSubjectivity to be set");
        }
        node.subjectivity = node.subjectivity.ancestorSubjectivity;
        applySubjectivityToChildren(node, node.subjectivity, previousSubjectivity);
      }
    } else {
      const newSubjectivity = {
        visibleTo: newVisibleTo,
        hiddenFrom: /* @__PURE__ */ new Set(),
        ancestorSubjectivity: previousSubjectivity
        // The previous subjectivity is that of the parent/ancestor
      };
      node.subjectivity = newSubjectivity;
      applySubjectivityToChildren(node, newSubjectivity, previousSubjectivity);
    }
    this.applyVisibilityAfterChanges(node, visibilityRecords, added, removed, VisibleToMode);
  }
  handleHiddenFromChange(targetId, added, removed) {
    const node = this.nodeManager.getStaticVirtualDOMElementByInternalNodeIdOrThrow(targetId);
    if (!node) {
      console.error("Target node not found for mutation", targetId);
      return;
    }
    if (node.parent == null) {
      return;
    }
    const previousSubjectivity = node.subjectivity;
    const visibilityRecords = this.calculatePreVisibilityChangeRecords(node);
    const newHiddenFrom = /* @__PURE__ */ new Set();
    for (const connectionId of added) {
      newHiddenFrom.add(connectionId);
    }
    const hasNonInheritedSubjectivity = previousSubjectivity !== null && previousSubjectivity !== node.parent.subjectivity;
    if (hasNonInheritedSubjectivity) {
      for (const connectionId of previousSubjectivity.hiddenFrom) {
        if (!removed.has(connectionId)) {
          newHiddenFrom.add(connectionId);
        }
      }
    }
    if (hasNonInheritedSubjectivity) {
      node.subjectivity.hiddenFrom = newHiddenFrom;
      if (newHiddenFrom.size === 0 && node.subjectivity.visibleTo.size === 0) {
        if (!node.subjectivity.ancestorSubjectivity) {
          throw new Error("Expected ancestorSubjectivity to be set");
        }
        node.subjectivity = node.subjectivity.ancestorSubjectivity;
        applySubjectivityToChildren(node, node.subjectivity, previousSubjectivity);
      }
    } else {
      const newSubjectivity = {
        hiddenFrom: newHiddenFrom,
        visibleTo: /* @__PURE__ */ new Set(),
        ancestorSubjectivity: previousSubjectivity
        // The previous subjectivity is that of the parent/ancestor
      };
      node.subjectivity = newSubjectivity;
      applySubjectivityToChildren(node, newSubjectivity, previousSubjectivity);
    }
    this.applyVisibilityAfterChanges(node, visibilityRecords, added, removed, HiddenFromMode);
  }
  handleCharacterData(targetId, textContent) {
    const node = this.nodeManager.getStaticVirtualDOMElementByInternalNodeIdOrThrow(targetId);
    if (!node) {
      console.error("Target node not found for mutation", targetId);
      return;
    }
    const nodeIsSubjectiveForV01 = node.subjectivity != null && !IsVisibleToAll(node.subjectivity, true);
    const nodeIsSubjectiveForV02 = node.subjectivity != null && !IsVisibleToAll(node.subjectivity, false);
    node.textContent = textContent;
    if (this.networkedDOMV01Connections.size > 0) {
      const allMessages = [
        {
          type: "textChanged",
          nodeId: node.nodeId,
          text: textContent
        }
      ];
      const encoded2 = JSON.stringify(allMessages);
      if (nodeIsSubjectiveForV01) {
        for (const client of this.networkedDOMV01Connections) {
          const canSee = node.subjectivity == null || IsVisibleToAnyOneOfConnectionIds(
            node.subjectivity,
            client.internalIdToExternalId,
            true
          );
          if (canSee) {
            client.sendStringifiedJSONArray(encoded2);
          }
        }
      } else {
        for (const client of this.networkedDOMV01Connections) {
          client.sendStringifiedJSONArray(encoded2);
        }
      }
    }
    const message = {
      type: "textChanged",
      nodeId: node.nodeId,
      text: textContent
    };
    const encoded = encodeTextChanged(message).getBuffer();
    if (nodeIsSubjectiveForV02) {
      for (const client of this.networkedDOMV02Connections) {
        const canSee = node.subjectivity == null || IsVisibleToAnyOneOfConnectionIds(node.subjectivity, client.internalIdToExternalId, false);
        if (canSee) {
          client.sendEncodedBytes(encoded);
        }
      }
    } else {
      for (const client of this.networkedDOMV02Connections) {
        client.sendEncodedBytes(encoded);
      }
    }
  }
  calculatePreVisibilityChangeRecords(node) {
    const priorVisibleToV01Connections = /* @__PURE__ */ new Set();
    const priorVisibleToV02Connections = /* @__PURE__ */ new Set();
    const previousSubjectivity = node.subjectivity;
    for (const client of this.networkedDOMV01Connections) {
      const canSee = previousSubjectivity == null || IsVisibleToAnyOneOfConnectionIds(previousSubjectivity, client.internalIdToExternalId, true);
      if (canSee) {
        priorVisibleToV01Connections.add(client);
      }
    }
    for (const client of this.networkedDOMV02Connections) {
      const canSee = previousSubjectivity == null || IsVisibleToAnyOneOfConnectionIds(
        previousSubjectivity,
        client.internalIdToExternalId,
        false
      );
      if (canSee) {
        priorVisibleToV02Connections.add(client);
      }
    }
    return {
      priorVisibleToV01Connections,
      priorVisibleToV02Connections,
      previousSubjectivity
    };
  }
  applyVisibilityAfterChanges(node, preVisibilityChangeRecords, added, removed, mode) {
    const priorVisibleToV01Connections = preVisibilityChangeRecords.priorVisibleToV01Connections;
    const priorVisibleToV02Connections = preVisibilityChangeRecords.priorVisibleToV02Connections;
    if (!node.parent) {
      throw new Error("Cannot apply visibility changes to root node");
    }
    const nodeId = node.nodeId;
    let childIndex = -1;
    for (let i = 0; i < node.parent.childNodes.length; i++) {
      const child = node.parent.childNodes[i];
      if (child.nodeId === nodeId) {
        childIndex = i;
        break;
      }
    }
    let previousNodeId = 0;
    let previousNodeIndex = null;
    let previousNodeIsSubjectiveForV01 = false;
    let previousNodeIsSubjectiveForV02 = false;
    if (childIndex > 0) {
      previousNodeIndex = childIndex - 1;
      const previousNode = node.parent.childNodes[childIndex - 1];
      previousNodeId = previousNode.nodeId;
      previousNodeIsSubjectiveForV01 = previousNode.subjectivity != null && !IsVisibleToAll(previousNode.subjectivity, true);
      previousNodeIsSubjectiveForV02 = previousNode.subjectivity != null && !IsVisibleToAll(previousNode.subjectivity, false);
    }
    if (this.networkedDOMV01Connections.size > 0) {
      const removedMessage = {
        type: "childrenChanged",
        nodeId: node.parent.nodeId,
        previousNodeId: null,
        removedNodes: [node.nodeId],
        addedNodes: []
      };
      const encodedRemoved = JSON.stringify([removedMessage]);
      for (const client of this.networkedDOMV01Connections) {
        const canSee = node.subjectivity == null || IsVisibleToAnyOneOfConnectionIds(node.subjectivity, client.internalIdToExternalId, true);
        const couldSeePreviously = priorVisibleToV01Connections.has(client);
        if (canSee && !couldSeePreviously) {
          let previousNodeIdForClient = previousNodeId;
          if (previousNodeId !== 0) {
            if (previousNodeIsSubjectiveForV01) {
              previousNodeIdForClient = 0;
              for (let i = previousNodeIndex; i >= 0; i--) {
                const child = node.parent.childNodes[i];
                if (child.subjectivity == null || IsVisibleToAnyOneOfConnectionIds(
                  child.subjectivity,
                  client.internalIdToExternalId,
                  true
                )) {
                  previousNodeIdForClient = child.nodeId;
                  break;
                }
              }
            } else {
              previousNodeIdForClient = previousNodeId;
            }
          }
          let previousNodeIdPointer = previousNodeIdForClient;
          if (previousNodeIdForClient === 0) {
            previousNodeIdPointer = null;
          }
          client.stringifyAndSendSingleMessage({
            type: "childrenChanged",
            nodeId: node.parent.nodeId,
            previousNodeId: previousNodeIdPointer,
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            addedNodes: [describeNodeWithChildrenForV01Connection(node, client)],
            removedNodes: []
          });
        } else if (!canSee && couldSeePreviously) {
          client.sendStringifiedJSONArray(encodedRemoved);
        } else if (canSee && couldSeePreviously) {
        } else if (!canSee && !couldSeePreviously) {
        }
      }
    }
    if (this.networkedDOMV02Connections.size > 0) {
      const removedMessage = {
        type: "childrenRemoved",
        nodeId: node.parent.nodeId,
        removedNodes: [node.nodeId]
      };
      const encodedRemoved = encodeChildrenRemoved(removedMessage).getBuffer();
      for (const client of this.networkedDOMV02Connections) {
        const canSee = node.subjectivity == null || IsVisibleToAnyOneOfConnectionIds(node.subjectivity, client.internalIdToExternalId, false);
        const couldSeePreviously = priorVisibleToV02Connections.has(client);
        if (canSee && !couldSeePreviously) {
          let previousNodeIdForClient = previousNodeId;
          if (previousNodeId !== 0) {
            if (previousNodeIsSubjectiveForV02) {
              previousNodeIdForClient = 0;
              for (let i = previousNodeIndex; i >= 0; i--) {
                const child = node.parent.childNodes[i];
                if (child.subjectivity == null || IsVisibleToAnyOneOfConnectionIds(
                  child.subjectivity,
                  client.internalIdToExternalId,
                  false
                )) {
                  previousNodeIdForClient = child.nodeId;
                  break;
                }
              }
            } else {
              previousNodeIdForClient = previousNodeId;
            }
          }
          client.sendMessage({
            type: "childrenAdded",
            nodeId: node.parent.nodeId,
            previousNodeId: previousNodeIdForClient,
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            addedNodes: [describeNodeWithChildrenForV02Connection(node, client)]
          });
        } else if (!canSee && couldSeePreviously) {
          client.sendEncodedBytes(encodedRemoved);
        } else if (canSee && couldSeePreviously) {
          if (mode === VisibleToMode) {
            const addVisibleTo = [];
            for (const connectionId of added) {
              const externalConnectionId = client.internalIdToExternalId.get(connectionId);
              if (externalConnectionId !== void 0) {
                addVisibleTo.push(externalConnectionId);
              }
            }
            const removeVisibleTo = [];
            for (const connectionId of removed) {
              const externalConnectionId = client.internalIdToExternalId.get(connectionId);
              if (externalConnectionId !== void 0) {
                removeVisibleTo.push(externalConnectionId);
              }
            }
            if (addVisibleTo.length > 0 || removeVisibleTo.length > 0) {
              client.sendMessage({
                type: "changeVisibleTo",
                nodeId: node.nodeId,
                addVisibleTo,
                removeVisibleTo
              });
            }
          } else if (mode === HiddenFromMode) {
            const addHiddenFrom = [];
            for (const connectionId of added) {
              const externalConnectionId = client.internalIdToExternalId.get(connectionId);
              if (externalConnectionId !== void 0) {
                addHiddenFrom.push(externalConnectionId);
              }
            }
            const removeHiddenFrom = [];
            for (const connectionId of removed) {
              const externalConnectionId = client.internalIdToExternalId.get(connectionId);
              if (externalConnectionId !== void 0) {
                removeHiddenFrom.push(externalConnectionId);
              }
            }
            if (addHiddenFrom.length > 0 || removeHiddenFrom.length > 0) {
              client.sendMessage({
                type: "changeHiddenFrom",
                nodeId: node.nodeId,
                addHiddenFrom,
                removeHiddenFrom
              });
            }
          }
        } else if (!canSee && !couldSeePreviously) {
        }
      }
    }
  }
  reprojectStaticVirtualDOMElementWithMappings(staticVirtualDOMElement, createIfCollided = false) {
    return {
      nodeId: this.nodeManager.getPotentiallyRemappedNode(
        staticVirtualDOMElement.nodeId,
        createIfCollided
      ),
      tag: staticVirtualDOMElement.tag,
      attributes: staticVirtualDOMElement.attributes,
      childNodes: staticVirtualDOMElement.childNodes.map(
        (child) => this.reprojectStaticVirtualDOMElementWithMappings(child, createIfCollided)
      ),
      textContent: staticVirtualDOMElement.textContent
    };
  }
  reprojectMutationWithMappings(mutation) {
    if (!this.nodeManager.hasAnyRemappings()) {
      return mutation;
    }
    switch (mutation.type) {
      case "attributes": {
        return {
          type: "attributes",
          targetId: this.nodeManager.getPotentiallyRemappedNode(mutation.targetId),
          attributes: mutation.attributes
        };
      }
      case "characterData": {
        return {
          type: "characterData",
          targetId: this.nodeManager.getPotentiallyRemappedNode(mutation.targetId),
          textContent: mutation.textContent
        };
      }
      case "childList": {
        return {
          type: "childList",
          targetId: this.nodeManager.getPotentiallyRemappedNode(mutation.targetId),
          addedNodes: mutation.addedNodes.map(
            (node) => this.reprojectStaticVirtualDOMElementWithMappings(node, true)
          ),
          removedNodeIds: mutation.removedNodeIds.map(
            (id) => this.nodeManager.getPotentiallyRemappedNode(id)
          ),
          previousSiblingId: mutation.previousSiblingId ? this.nodeManager.getPotentiallyRemappedNode(mutation.previousSiblingId) : null
        };
      }
    }
  }
  handleMutation(originalMutation, reproject = true) {
    const mutation = reproject ? this.reprojectMutationWithMappings(originalMutation) : originalMutation;
    if (mutation.type === "childList") {
      if (mutation.addedNodes.length === 0 && mutation.removedNodeIds.length === 0) {
        return;
      }
      if (mutation.removedNodeIds.length > 0) {
        this.handleRemovedNodes(mutation.targetId, mutation.removedNodeIds);
      }
      if (mutation.addedNodes.length > 0) {
        this.handleAddedNodes(mutation.targetId, mutation.previousSiblingId, mutation.addedNodes);
      }
    } else if (mutation.type === "attributes") {
      this.handleAttributeMutation(mutation.targetId, mutation.attributes);
    } else if (mutation.type === "characterData") {
      this.handleCharacterData(mutation.targetId, mutation.textContent);
    }
  }
  removeNodeAndChildren(nodeId) {
    const node = this.nodeManager.getStaticVirtualDOMElementByInternalNodeIdOrThrow(nodeId);
    if (node.subjectivity != null) {
      for (const connectionId of node.subjectivity.visibleTo) {
        this.visibilityManager.removeSpecificallyVisibleNode(connectionId, nodeId);
      }
    }
    this.nodeManager.deleteNode(node.nodeId);
    for (const child of node.childNodes) {
      this.removeNodeAndChildren(child.nodeId);
    }
  }
};

// src/EditableNetworkedDOM.ts
var EditableNetworkedDOM = class {
  constructor(htmlPath, observableDOMFactory, ignoreTextNodes = true, logCallback) {
    this.params = {};
    this.websockets = /* @__PURE__ */ new Map();
    this.loadedState = {
      type: 2 /* BeforeDocumentLoaded */
    };
    this.htmlPath = htmlPath;
    this.observableDOMFactory = observableDOMFactory;
    this.ignoreTextNodes = ignoreTextNodes;
    this.logCallback = logCallback;
  }
  isLoaded() {
    return this.loadedState !== null;
  }
  load(htmlContents, params) {
    if (params !== void 0) {
      this.params = params;
    }
    let oldInstanceRoot = null;
    if (this.loadedState.type === 1 /* DocumentLoaded */ || this.loadedState.type === 0 /* DocumentLoading */) {
      const oldInstance = this.loadedState.networkedDOM;
      oldInstance.dispose();
      oldInstanceRoot = oldInstance.getSnapshot();
    }
    let didLoad = false;
    let hasSetLoading = false;
    const networkedDOM = new NetworkedDOM(
      this.observableDOMFactory,
      this.htmlPath,
      htmlContents,
      oldInstanceRoot,
      (domDiff, networkedDOM2) => {
        didLoad = true;
        if (!hasSetLoading) {
          hasSetLoading = true;
          this.loadedState = {
            type: 1 /* DocumentLoaded */,
            htmlContents,
            networkedDOM: networkedDOM2
          };
        } else if (this.loadedState && this.loadedState.type === 0 /* DocumentLoading */ && this.loadedState.networkedDOM === networkedDOM2) {
          this.loadedState = {
            type: 1 /* DocumentLoaded */,
            htmlContents,
            networkedDOM: networkedDOM2
          };
        }
        networkedDOM2.addExistingNetworkedDOMConnections(new Set(this.websockets.values()), domDiff);
      },
      this.params,
      this.ignoreTextNodes,
      this.logCallback
    );
    hasSetLoading = true;
    if (!didLoad) {
      this.loadedState = {
        type: 0 /* DocumentLoading */,
        htmlContents,
        networkedDOM
      };
    }
  }
  reload() {
    if (this.loadedState && this.loadedState.type === 1 /* DocumentLoaded */) {
      this.load(this.loadedState.htmlContents, this.params);
    } else {
      console.warn("EditableNetworkedDOM.reload called whilst not loaded");
    }
  }
  dispose() {
    for (const [ws, networkedDOMConnection] of this.websockets) {
      networkedDOMConnection.dispose();
      ws.close();
    }
    this.websockets.clear();
    if (this.loadedState.type === 1 /* DocumentLoaded */ || this.loadedState.type === 0 /* DocumentLoading */) {
      this.loadedState.networkedDOM.dispose();
    }
    this.loadedState = {
      type: 2 /* BeforeDocumentLoaded */
    };
  }
  addWebSocket(webSocket) {
    const networkedDOMConnection = createNetworkedDOMConnectionForWebsocket(webSocket);
    if (networkedDOMConnection === null) {
      return;
    }
    this.websockets.set(webSocket, networkedDOMConnection);
    if (this.loadedState.type === 1 /* DocumentLoaded */) {
      this.loadedState.networkedDOM.addNetworkedDOMConnection(networkedDOMConnection);
    }
  }
  hasWebSocket(webSocket) {
    return this.websockets.has(webSocket);
  }
  removeWebSocket(webSocket) {
    const networkedDOMConnection = this.websockets.get(webSocket);
    if (networkedDOMConnection === void 0) {
      throw new Error("Unknown websocket");
    }
    networkedDOMConnection.dispose();
    this.websockets.delete(webSocket);
    if (this.loadedState.type === 1 /* DocumentLoaded */) {
      this.loadedState.networkedDOM.removeNetworkedDOMConnection(networkedDOMConnection);
    }
  }
};
export {
  EditableNetworkedDOM,
  NetworkedDOM,
  NetworkedDOMV01Connection,
  NetworkedDOMV02Connection
};
//# sourceMappingURL=index.js.map
