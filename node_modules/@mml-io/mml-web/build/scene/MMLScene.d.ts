import { DebugHelper } from "../debug-helper";
import { Animation, Audio, ChatProbe, Cube, Cylinder, Frame, Image, Interaction, Label, Light, Link, MElement, Model, Overlay, Plane, PositionProbe, Prompt, RemoteDocument, Sphere, TransformableElement, Video } from "../elements";
import { AnimationGraphics, AudioGraphics, ChatProbeGraphics, CubeGraphics, CylinderGraphics, DebugHelperGraphics, FrameGraphics, GraphicsAdapter, ImageGraphics, InteractionGraphics, LabelGraphics, LightGraphics, LinkGraphics, MElementGraphics, ModelGraphics, OverlayGraphics, PlaneGraphics, PositionProbeGraphics, PromptGraphics, RemoteDocumentGraphics, SphereGraphics, StandaloneGraphicsAdapter, TransformableGraphics, VideoGraphics } from "../graphics";
import { LoadingProgressManager } from "../loading";
export interface MMLGraphicsInterface<C extends GraphicsAdapter> {
    MMLAnimationGraphicsInterface: (element: Animation<C>) => AnimationGraphics<C>;
    MMLDebugHelperGraphicsInterface<G extends C>(debugHelper: DebugHelper<G>): DebugHelperGraphics<G>;
    RemoteDocumentGraphicsInterface: (element: RemoteDocument<C>) => RemoteDocumentGraphics<C>;
    MElementGraphicsInterface: (element: MElement<C>) => MElementGraphics<C>;
    MMLTransformableGraphicsInterface: (element: TransformableElement<C>) => TransformableGraphics<C>;
    MMLImageGraphicsInterface: (element: Image<C>, updateMeshCallback: () => void) => ImageGraphics<C>;
    MMLVideoGraphicsInterface: (element: Video<C>, updateMeshCallback: () => void) => VideoGraphics<C>;
    MMLAudioGraphicsInterface: (element: Audio<C>) => AudioGraphics<C>;
    MMLCubeGraphicsInterface: (element: Cube<C>) => CubeGraphics<C>;
    MMLLabelGraphicsInterface: (element: Label<C>) => LabelGraphics<C>;
    MMLLinkGraphicsInterface: (element: Link<C>) => LinkGraphics<C>;
    MMLOverlayGraphicsInterface: (element: Overlay<C>) => OverlayGraphics<C>;
    MMLPlaneGraphicsInterface: (element: Plane<C>) => PlaneGraphics<C>;
    MMLPromptGraphicsInterface: (element: Prompt<C>) => PromptGraphics<C>;
    MMLInteractionGraphicsInterface: (element: Interaction<C>) => InteractionGraphics<C>;
    MMLChatProbeGraphicsInterface: (element: ChatProbe<C>) => ChatProbeGraphics<C>;
    MMLPositionProbeGraphicsInterface: (element: PositionProbe<C>) => PositionProbeGraphics<C>;
    MMLSphereGraphicsInterface: (element: Sphere<C>) => SphereGraphics<C>;
    MMLCylinderGraphicsInterface: (element: Cylinder<C>) => CylinderGraphics<C>;
    MMLLightGraphicsInterface: (element: Light<C>) => LightGraphics<C>;
    MMLFrameGraphicsInterface: (element: Frame<C>) => FrameGraphics<C>;
    MMLModelGraphicsInterface: (element: Model<C>, updateMeshCallback: () => void) => ModelGraphics<C>;
}
export type PositionAndRotation = {
    position: {
        x: number;
        y: number;
        z: number;
    };
    rotation: {
        x: number;
        y: number;
        z: number;
    };
};
export type InteractionListener<G extends GraphicsAdapter = GraphicsAdapter> = {
    addInteraction(interaction: Interaction<G>): void;
    updateInteraction(interaction: Interaction<G>): void;
    removeInteraction(interaction: Interaction<G>): void;
};
export type ChatProbeListener<G extends GraphicsAdapter = GraphicsAdapter> = {
    addChatProbe(chatProbe: ChatProbe<G>): void;
    updateChatProbe(chatProbe: ChatProbe<G>): void;
    removeChatProbe(chatProbe: ChatProbe<G>): void;
};
export type PromptProps = {
    message?: string;
    placeholder?: string;
    prefill?: string;
};
export type LinkProps = {
    href: string;
    target?: string;
    popup?: boolean;
};
/**
 * The IMMLScene interface is the public interface for attaching content (E.g.
 * an MML Document) into the underlyingScene, but it can be implemented by
 * classes other than MMLScene.
 */
export type IMMLScene<G extends GraphicsAdapter = GraphicsAdapter> = {
    getGraphicsAdapter: () => G;
    hasGraphicsAdapter: () => boolean;
    addCollider?: (collider: unknown, element: MElement<G>) => void;
    updateCollider?: (collider: unknown, element: MElement<G>) => void;
    removeCollider?: (collider: unknown, element: MElement<G>) => void;
    addInteraction?: (interaction: Interaction<G>) => void;
    updateInteraction?: (interaction: Interaction<G>) => void;
    removeInteraction?: (interaction: Interaction<G>) => void;
    addChatProbe?: (chatProbe: ChatProbe<G>) => void;
    updateChatProbe?: (chatProbe: ChatProbe<G>) => void;
    removeChatProbe?: (chatProbe: ChatProbe<G>) => void;
    getOverlayElement?: () => HTMLElement | null;
    getUserPositionAndRotation(): PositionAndRotation;
    prompt: (promptProps: PromptProps, abortSignal: AbortSignal, callback: (message: string | null) => void) => void;
    link: (linkProps: LinkProps, abortSignal: AbortSignal, windowCallback: (openedWindow: Window | null) => void) => void;
    getLoadingProgressManager?: () => LoadingProgressManager | null;
};
/**
 * The MMLScene class creates a HTML Element that renders a scene and includes the various manager instances
 * for handling clicks, interaction events, and controls.
 *
 * It is the default implementation of the IMMLScene interface and presents a fly camera with drag controls.
 */
export declare class MMLScene<G extends StandaloneGraphicsAdapter> implements IMMLScene<G> {
    element: HTMLElement;
    private colliders;
    private interactions;
    private interactionListeners;
    private chatProbes;
    private chatProbeListeners;
    private resizeListener;
    private promptManager;
    private interactionManager;
    private resizeObserver;
    private loadingProgressManager;
    private graphicsAdapter;
    constructor(element: HTMLElement);
    init(graphicsAdapter: G): void;
    hasGraphicsAdapter(): boolean;
    getGraphicsAdapter(): G;
    getUserPositionAndRotation(): PositionAndRotation;
    fitContainer(): void;
    dispose(): void;
    prompt(promptProps: PromptProps, abortSignal: AbortSignal, callback: (message: string | null) => void): void;
    link(linkProps: LinkProps, abortSignal: AbortSignal, windowCallback: (openedWindow: Window | null) => void): void;
    addCollider(collider: unknown, element: MElement<G>): void;
    updateCollider(collider: unknown): void;
    removeCollider(collider: unknown): void;
    addInteraction(interaction: Interaction<G>): void;
    updateInteraction(interaction: Interaction<G>): void;
    removeInteraction(interaction: Interaction<G>): void;
    getInteractions(): Set<Interaction<G>>;
    addInteractionListener(listener: InteractionListener<G>, addExistingInteractions?: boolean): void;
    removeInteractionListener(listener: InteractionListener<G>): void;
    addChatProbe(chatProbe: ChatProbe<G>): void;
    updateChatProbe(chatProbe: ChatProbe<G>): void;
    removeChatProbe(chatProbe: ChatProbe<G>): void;
    getLoadingProgressManager(): LoadingProgressManager;
    getChatProbes(): Set<ChatProbe<G>>;
    addChatProbeListener(listener: ChatProbeListener<G>, addExistingChatProbes?: boolean): void;
    removeChatProbeListener(listener: ChatProbeListener<G>): void;
}
//# sourceMappingURL=MMLScene.d.ts.map