import { OrientedBoundingBox } from "../bounding-box";
import { GraphicsAdapter } from "../graphics";
import { TransformableElement } from "./TransformableElement";
export type MFrameProps = {
    src: string | null;
    loadRange: number | null;
    unloadRange: number;
    debug: boolean;
    minX: number | null;
    maxX: number | null;
    minY: number | null;
    maxY: number | null;
    minZ: number | null;
    maxZ: number | null;
};
export declare class Frame<G extends GraphicsAdapter = GraphicsAdapter> extends TransformableElement<G> {
    static tagName: string;
    private frameGraphics;
    private hasInitialized;
    private static attributeHandler;
    protected enable(): void;
    protected disable(): void;
    private frameContentsInstance;
    private isActivelyLoaded;
    private timer;
    private boundsUpdated;
    props: MFrameProps;
    private shouldBeLoaded;
    private syncLoadState;
    static get observedAttributes(): Array<string>;
    constructor();
    getContentBounds(): OrientedBoundingBox | null;
    parentTransformed(): void;
    isClickable(): boolean;
    private startEmitting;
    private createFrameContentsInstance;
    getDefinedBoxBounds(): [number, number, number, number, number, number] | null;
    private disposeInstance;
    attributeChangedCallback(name: string, oldValue: string | null, newValue: string): void;
    connectedCallback(): void;
    disconnectedCallback(): void;
}
//# sourceMappingURL=Frame.d.ts.map