import { GraphicsAdapter } from "../graphics";
import { LoadingProgressManager } from "../loading";
import { IMMLScene, PositionAndRotation } from "../scene";
import { MMLDocumentTimeManager } from "../time";
import type { RemoteDocument } from "./RemoteDocument";
export declare const MELEMENT_PROPERTY_NAME = "m-element-property";
export declare const consumeEventEventName = "consume-event";
export declare abstract class MElement<G extends GraphicsAdapter = GraphicsAdapter> extends HTMLElement {
    static overwriteSuperclass(newSuperclass: typeof HTMLElement): void;
    static get observedAttributes(): Array<string>;
    private mElementGraphics;
    constructor();
    readonly isMElement = true;
    static isMElement(element: object): element is MElement;
    static getMElementFromObject(object: unknown): MElement<GraphicsAdapter> | null;
    abstract isClickable(): boolean;
    abstract parentTransformed(): void;
    addSideEffectChild(child: MElement<G>): void;
    removeSideEffectChild(child: MElement<G>): void;
    attributeChangedCallback(name: string, oldValue: string | null, newValue: string): void;
    getScene(): IMMLScene<G>;
    getInitiatedRemoteDocument(): RemoteDocument<G> | null;
    contentSrcToContentAddress(src: string): string;
    private getDocumentHost;
    getDocumentTime(): number;
    getWindowTime(): number;
    getLoadingProgressManager(): LoadingProgressManager | null;
    protected getDocumentTimeManager(): MMLDocumentTimeManager | null;
    addDocumentTimeListener(cb: (documentTime: number) => void): {
        remove: () => void;
    };
    addDocumentTimeTickListener(cb: (documentTime: number) => void): {
        remove: () => void;
    };
    getContainer(): G["containerType"];
    getUserPositionAndRotation(): PositionAndRotation;
    dispatchEvent(event: Event): boolean;
    getMElementParent(): MElement<G> | null;
    connectedCallback(): void;
    disconnectedCallback(): void;
}
//# sourceMappingURL=MElement.d.ts.map