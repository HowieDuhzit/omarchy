// src/elements/ThreeJSAnimation.ts
import { Animation, Model } from "@mml-io/mml-web";
import { AnimationGraphics } from "@mml-io/mml-web";
import { LoadingInstanceManager } from "@mml-io/mml-web";
var ThreeJSAnimation = class extends AnimationGraphics {
  constructor(animation) {
    super(animation);
    this.animation = animation;
    this.loadingInstanceManager = new LoadingInstanceManager(`${Animation.tagName}.src`);
    this.latestSrcModelHandle = null;
    this.parentModel = null;
    if (animation.parentElement && Model.isModel(animation.parentElement)) {
      this.parentModel = animation.parentElement;
    }
    this.animationState = {
      animationClip: null,
      weight: animation.props.weight,
      speed: animation.props.speed,
      ratio: animation.props.ratio,
      loop: animation.props.loop,
      startTime: animation.props.startTime,
      pauseTime: animation.props.pauseTime
    };
  }
  setSrc(src) {
    var _a;
    if (((_a = this.latestSrcModelHandle) == null ? void 0 : _a.url) === src) {
      return;
    }
    if (this.latestSrcModelHandle) {
      this.latestSrcModelHandle.dispose();
      this.loadingInstanceManager.abortIfLoading();
    }
    this.latestSrcModelHandle = null;
    if (this.animationState.animationClip) {
      this.animationState.animationClip = null;
    }
    if (!src) {
      this.latestSrcModelHandle = null;
      this.loadingInstanceManager.abortIfLoading();
      return;
    }
    const contentSrc = this.animation.contentSrcToContentAddress(src);
    this.loadingInstanceManager.start(this.animation.getLoadingProgressManager(), contentSrc);
    const srcModelHandle = this.animation.getScene().getGraphicsAdapter().getResourceManager().loadModel(contentSrc);
    this.latestSrcModelHandle = srcModelHandle;
    srcModelHandle.onProgress((loaded, total) => {
      if (this.latestSrcModelHandle !== srcModelHandle) {
        return;
      }
      this.loadingInstanceManager.setProgress(loaded / total);
    });
    srcModelHandle.onLoad((result) => {
      if (result instanceof Error) {
        console.error("Error loading m-animation.src", result);
        this.latestSrcModelHandle = null;
        this.loadingInstanceManager.error(result);
        return;
      }
      if (this.latestSrcModelHandle !== srcModelHandle || !this.animation.isConnected) {
        return;
      }
      const animationClip = result.animations[0];
      this.animationState.animationClip = animationClip;
      this.updateParentAnimation();
      this.loadingInstanceManager.finish();
    });
  }
  parentModelUpdated() {
    this.updateParentAnimation();
  }
  setWeight(weight) {
    this.animationState.weight = weight;
    this.updateParentAnimation();
  }
  setSpeed(speed) {
    this.animationState.speed = speed;
    this.updateParentAnimation();
  }
  setRatio(ratio) {
    this.animationState.ratio = ratio;
    this.updateParentAnimation();
  }
  setLoop(loop) {
    this.animationState.loop = loop;
    this.updateParentAnimation();
  }
  setStartTime(startTime) {
    this.animationState.startTime = startTime;
    this.updateParentAnimation();
  }
  setPauseTime(pauseTime) {
    this.animationState.pauseTime = pauseTime;
    this.updateParentAnimation();
  }
  updateParentAnimation() {
    var _a, _b;
    if (!this.parentModel || !this.animationState.animationClip) {
      return;
    }
    if (this.parentModel.modelGraphics) {
      (_b = (_a = this.parentModel.modelGraphics).updateChildAnimation) == null ? void 0 : _b.call(_a, this.animation, this.animationState);
    } else {
      console.error("updateParentAnimation: parent model has no modelGraphics");
    }
  }
  dispose() {
    var _a, _b;
    if (this.latestSrcModelHandle) {
      this.latestSrcModelHandle.dispose();
    }
    this.latestSrcModelHandle = null;
    this.loadingInstanceManager.dispose();
    if (this.parentModel && this.parentModel.modelGraphics) {
      (_b = (_a = this.parentModel.modelGraphics).removeChildAnimation) == null ? void 0 : _b.call(_a, this.animation);
    }
    this.animationState.animationClip = null;
  }
};

// src/elements/ThreeJSAudio.ts
import { Audio } from "@mml-io/mml-web";
import { AudioGraphics } from "@mml-io/mml-web";
import { LoadingInstanceManager as LoadingInstanceManager2 } from "@mml-io/mml-web";
import * as THREE from "three";
import { PositionalAudioHelper } from "three/addons/helpers/PositionalAudioHelper.js";
var debugAudioSphereSize = 0.25;
var debugAudioGeometry = new THREE.SphereGeometry(debugAudioSphereSize, 4, 2);
var debugAudioMaterial = new THREE.MeshBasicMaterial({
  wireframe: true,
  fog: false,
  toneMapped: false,
  color: 65280
});
var audioRefDistance = 1;
var audioRolloffFactor = 1;
function extendAudioToDuration(context, buffer, seconds) {
  const updatedBuffer = context.createBuffer(
    buffer.numberOfChannels,
    Math.ceil(seconds * buffer.sampleRate),
    buffer.sampleRate
  );
  for (let channelNumber = 0; channelNumber < buffer.numberOfChannels; channelNumber++) {
    const channelData = buffer.getChannelData(channelNumber);
    const updatedChannelData = updatedBuffer.getChannelData(channelNumber);
    updatedChannelData.set(channelData, 0);
  }
  return updatedBuffer;
}
var ThreeJSAudio = class extends AudioGraphics {
  constructor(audio) {
    super(audio);
    this.audio = audio;
    this.audioDebugHelper = null;
    this.audioContextStateChangedListener = () => {
      this.syncAudioTime();
    };
    this.delayedPauseTimer = null;
    this.srcLoadingInstanceManager = new LoadingInstanceManager2(`${Audio.tagName}.src`);
    this.loadedAudioState = null;
    this.documentTimeListener = this.audio.addDocumentTimeListener(() => {
      if (this.loadedAudioState) {
        this.syncAudioTime();
      }
    });
    const audioListener = this.getAudioListener();
    this.positionalAudio = new THREE.PositionalAudio(audioListener);
    this.positionalAudio.context.addEventListener(
      "statechange",
      this.audioContextStateChangedListener
    );
    this.positionalAudio.setVolume(this.audio.props.volume);
    this.positionalAudio.setDirectionalCone(
      this.audio.props.coneFalloffAngle ?? 360,
      this.audio.props.coneAngle,
      0
    );
    this.positionalAudio.setRefDistance(audioRefDistance);
    this.positionalAudio.setRolloffFactor(audioRolloffFactor);
    this.audio.getContainer().add(this.positionalAudio);
    this.updateAudio();
    this.updateDebugVisualisation();
  }
  disable() {
  }
  enable() {
  }
  syncAudioTime() {
    const audioContext = this.positionalAudio.context;
    if (audioContext.state !== "running") {
      return;
    }
    if (this.delayedPauseTimer !== null) {
      clearTimeout(this.delayedPauseTimer);
      this.delayedPauseTimer = null;
    }
    if (!this.loadedAudioState || !this.loadedAudioState.loadedAudio || this.loadedAudioState.loadedAudio.mode !== "LOADED") {
      return;
    }
    const loadedAudio = this.loadedAudioState.loadedAudio;
    const audioBuffer = loadedAudio.buffer;
    let currentSource = loadedAudio.currentSource;
    if (!this.audio.props.enabled || this.audio.isDisabled()) {
      if (currentSource) {
        currentSource.sourceNode.stop();
        loadedAudio.currentSource = null;
      }
      return;
    }
    const documentTime = this.audio.getDocumentTime();
    if (this.audio.props.pauseTime !== null) {
      const timeUntilPause = this.audio.props.pauseTime - documentTime;
      if (timeUntilPause < 2) {
        if (currentSource) {
          currentSource.sourceNode.stop();
          loadedAudio.currentSource = null;
        }
        return;
      } else {
        const delayedPauseTimer = setTimeout(() => {
          if (this.delayedPauseTimer === delayedPauseTimer) {
            this.delayedPauseTimer = null;
          }
          this.syncAudioTime();
        }, timeUntilPause);
        this.delayedPauseTimer = delayedPauseTimer;
      }
    }
    const currentTime = (documentTime - this.audio.props.startTime) / 1e3;
    const audioDuration = audioBuffer.duration;
    let loopDurationSeconds = null;
    if (this.audio.props.loopDuration !== null && this.audio.props.loopDuration > 0) {
      loopDurationSeconds = this.audio.props.loopDuration / 1e3;
    }
    let desiredAudioTime;
    if (this.audio.props.loop) {
      if (currentTime < 0) {
        desiredAudioTime = currentTime;
      } else {
        if (loopDurationSeconds === null) {
          desiredAudioTime = currentTime % audioDuration;
        } else {
          desiredAudioTime = currentTime % loopDurationSeconds;
        }
      }
    } else {
      desiredAudioTime = currentTime;
      if (desiredAudioTime > audioDuration) {
        if (currentSource) {
          currentSource.sourceNode.stop();
          loadedAudio.currentSource = null;
        }
        return;
      }
    }
    const loopDurationLongerThanAudioDuration = loopDurationSeconds && loopDurationSeconds > audioDuration;
    const playbackLength = loopDurationSeconds ? loopDurationSeconds : audioDuration;
    if (currentSource) {
      if (currentSource.sourceNode.loop !== this.audio.props.loop) {
        currentSource.sourceNode.stop();
        loadedAudio.currentSource = null;
        currentSource = null;
      } else if (loopDurationSeconds !== null && loopDurationLongerThanAudioDuration && (!loadedAudio.paddedBuffer || loadedAudio.paddedBuffer.totalDuration < loopDurationSeconds)) {
        currentSource.sourceNode.stop();
        loadedAudio.currentSource = null;
        currentSource = null;
      } else if (loopDurationSeconds === null && currentSource.sourceNode.loopEnd !== audioBuffer.duration) {
        currentSource.sourceNode.stop();
        loadedAudio.currentSource = null;
        currentSource = null;
      } else {
        if (this.audio.props.startTime > documentTime) {
          currentSource.sourceNode.stop();
          loadedAudio.currentSource = null;
          currentSource = null;
        } else {
          const unloopedCurrentAudioPoint = (audioContext.currentTime - currentSource.contextStartTime) / currentSource.sourceNode.playbackRate.value;
          if (unloopedCurrentAudioPoint < 0) {
            currentSource.sourceNode.stop();
            loadedAudio.currentSource = null;
            currentSource = null;
          } else {
            if (loopDurationSeconds !== null && currentSource.sourceNode.loopEnd !== loopDurationSeconds) {
              currentSource.sourceNode.loopEnd = loopDurationSeconds;
            }
            const currentAudioPoint = unloopedCurrentAudioPoint % playbackLength;
            let delta = desiredAudioTime - currentAudioPoint;
            if (this.audio.props.loop) {
              const loopedDelta = delta - playbackLength;
              if (Math.abs(delta) > Math.abs(loopedDelta)) {
                delta = loopedDelta;
              }
            }
            if (Math.abs(delta) > 0.5) {
              currentSource.sourceNode.stop();
              loadedAudio.currentSource = null;
              currentSource = null;
            } else {
              if (Math.abs(delta) < 0.1) {
                currentSource.sourceNode.playbackRate.value = 1;
              } else {
                if (delta > 0) {
                  currentSource.sourceNode.playbackRate.value = 1.01;
                } else {
                  currentSource.sourceNode.playbackRate.value = 0.99;
                }
              }
              currentSource.contextStartTime = audioContext.currentTime - currentAudioPoint / currentSource.sourceNode.playbackRate.value;
            }
          }
        }
      }
    }
    if (!currentSource) {
      const currentSourceNode = this.positionalAudio.context.createBufferSource();
      let buffer = audioBuffer;
      if (loopDurationSeconds && loopDurationLongerThanAudioDuration) {
        if (loadedAudio.paddedBuffer && loadedAudio.paddedBuffer.totalDuration === loopDurationSeconds) {
          buffer = loadedAudio.paddedBuffer.buffer;
        } else {
          const paddedBuffer = extendAudioToDuration(
            this.positionalAudio.context,
            audioBuffer,
            loopDurationSeconds
          );
          loadedAudio.paddedBuffer = {
            buffer: paddedBuffer,
            totalDuration: loopDurationSeconds
          };
          buffer = paddedBuffer;
        }
      }
      currentSourceNode.buffer = buffer;
      currentSourceNode.loop = this.audio.props.loop;
      currentSourceNode.loopStart = 0;
      if (loopDurationSeconds) {
        currentSourceNode.loopEnd = loopDurationSeconds;
      } else {
        currentSourceNode.loopEnd = audioBuffer.duration;
      }
      let contextStartTime;
      if (desiredAudioTime < 0) {
        const timeFromNowToStart = -desiredAudioTime;
        contextStartTime = audioContext.currentTime + timeFromNowToStart;
        currentSourceNode.start(contextStartTime);
      } else {
        contextStartTime = audioContext.currentTime - desiredAudioTime;
        currentSourceNode.start(0, desiredAudioTime);
      }
      loadedAudio.currentSource = {
        sourceNode: currentSourceNode,
        contextStartTime
      };
      this.positionalAudio.setNodeSource(currentSourceNode);
    }
  }
  clearAudio() {
    var _a;
    if (this.loadedAudioState) {
      if (this.loadedAudioState.loadedAudio) {
        if (this.loadedAudioState.loadedAudio.mode === "LOADING") {
          this.loadedAudioState.loadedAudio.abortController.abort();
        } else {
          if ((_a = this.loadedAudioState.loadedAudio.currentSource) == null ? void 0 : _a.sourceNode) {
            this.loadedAudioState.loadedAudio.currentSource.sourceNode.stop();
          }
        }
      }
      this.loadedAudioState = null;
    }
  }
  updateAudio() {
    if (!this.audio.isConnected) {
      return;
    }
    const audioListener = this.getAudioListener();
    const audioContext = audioListener.context;
    if (!this.audio.props.src) {
      this.clearAudio();
    } else {
      const contentAddress = this.audio.contentSrcToContentAddress(this.audio.props.src);
      if (this.loadedAudioState && this.loadedAudioState.currentSrc === contentAddress) {
      } else {
        this.clearAudio();
        const abortController = new AbortController();
        this.srcLoadingInstanceManager.start(
          this.audio.getLoadingProgressManager(),
          contentAddress
        );
        const srcLoadPromise = this.asyncLoadSourceAsset(
          contentAddress,
          abortController,
          audioContext,
          (loaded, total) => {
            this.srcLoadingInstanceManager.setProgress(loaded / total);
          }
        );
        this.loadedAudioState = {
          loadedAudio: {
            mode: "LOADING",
            abortController,
            srcLoadPromise
          },
          currentSrc: contentAddress
        };
        srcLoadPromise.then((buffer) => {
          var _a;
          if (this.loadedAudioState && ((_a = this.loadedAudioState.loadedAudio) == null ? void 0 : _a.mode) === "LOADING" && this.loadedAudioState.loadedAudio.srcLoadPromise === srcLoadPromise) {
            this.loadedAudioState.loadedAudio = {
              mode: "LOADED",
              buffer,
              currentSource: null
            };
            this.srcLoadingInstanceManager.finish();
            this.syncAudioTime();
          }
        }).catch((e) => {
          var _a;
          if (this.loadedAudioState && ((_a = this.loadedAudioState.loadedAudio) == null ? void 0 : _a.mode) === "LOADING" && this.loadedAudioState.loadedAudio.srcLoadPromise === srcLoadPromise) {
            console.error("Failed to load audio", e);
            this.srcLoadingInstanceManager.error(e);
            this.clearAudio();
          }
        });
      }
    }
    this.syncAudioTime();
  }
  async asyncLoadSourceAsset(contentAddress, abortController, audioContext, onProgress) {
    return new Promise((resolve, reject) => {
      (async () => {
        if (contentAddress.startsWith("data:")) {
          const base64 = contentAddress.split(",", 2)[1];
          if (!base64) {
            reject(new Error("Invalid data URL"));
            return;
          }
          let arrayBuffer;
          try {
            const binary = atob(base64);
            const uint8Array = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
              uint8Array[i] = binary.charCodeAt(i);
            }
            arrayBuffer = uint8Array.buffer;
          } catch (e) {
            console.error("Failed to decode base64 data URL", e);
            return;
          }
          audioContext.decodeAudioData(arrayBuffer).then((audioBuffer) => {
            if (abortController.signal.aborted) {
              return;
            }
            resolve(audioBuffer);
          }).catch((e) => {
            console.error("Failed to decode data URI audio data", e);
          });
          return;
        }
        const response = await fetch(contentAddress, {
          signal: abortController.signal
        });
        if (response.ok) {
          response.arrayBuffer().then((buffer) => {
            if (abortController.signal.aborted) {
              return;
            }
            audioContext.decodeAudioData(buffer).then((audioBuffer) => {
              if (abortController.signal.aborted) {
                return;
              }
              resolve(audioBuffer);
            });
          }).catch((e) => {
            console.error("Failed to decode fetched audio data", e);
          });
        } else {
          console.error("Failed to fetch audio data", response);
        }
      })();
    });
  }
  setSrc() {
    this.updateAudio();
  }
  setStartTime() {
    if (this.loadedAudioState) {
      this.syncAudioTime();
    }
  }
  setPauseTime() {
    if (this.loadedAudioState) {
      this.syncAudioTime();
    }
  }
  setLoopDuration() {
    if (this.loadedAudioState) {
      this.syncAudioTime();
    }
  }
  setLoop() {
    this.updateAudio();
  }
  setEnabled() {
    this.updateAudio();
  }
  setVolume(volume) {
    this.positionalAudio.setVolume(volume);
  }
  setConeAngle(coneAngle, mAudioProps) {
    this.positionalAudio.setDirectionalCone(
      mAudioProps.coneAngle,
      mAudioProps.coneFalloffAngle ?? 360,
      0
    );
    this.updateDebugVisualisation();
  }
  setConeFalloffAngle(coneFalloffAngle, mAudioProps) {
    this.positionalAudio.setDirectionalCone(
      mAudioProps.coneAngle,
      mAudioProps.coneFalloffAngle ?? 360,
      0
    );
    this.updateDebugVisualisation();
  }
  setDebug() {
    this.updateDebugVisualisation();
  }
  dispose() {
    if (this.positionalAudio) {
      this.positionalAudio.context.removeEventListener(
        "statechange",
        this.audioContextStateChangedListener
      );
      this.positionalAudio.disconnect();
      this.positionalAudio.removeFromParent();
    }
    this.clearAudio();
    if (this.delayedPauseTimer) {
      clearTimeout(this.delayedPauseTimer);
      this.delayedPauseTimer = null;
    }
    this.documentTimeListener.remove();
    this.clearDebugVisualisation();
    this.srcLoadingInstanceManager.dispose();
  }
  clearDebugVisualisation() {
    var _a;
    if (this.audioDebugHelper) {
      this.audioDebugHelper.removeFromParent();
      this.audioDebugHelper = null;
    }
    if (this.audioDebugConeX) {
      this.audioDebugConeX.removeFromParent();
      this.audioDebugConeX = null;
      (_a = this.audioDebugConeY) == null ? void 0 : _a.removeFromParent();
      this.audioDebugConeY = null;
    }
  }
  updateDebugVisualisation() {
    var _a, _b, _c;
    if (!this.audio.props.debug) {
      this.clearDebugVisualisation();
    } else {
      if (!this.audioDebugHelper) {
        this.audioDebugHelper = new THREE.Mesh(debugAudioGeometry, debugAudioMaterial);
        this.audio.getContainer().add(this.audioDebugHelper);
      }
      if (!this.audioDebugConeX && this.audio.props.coneAngle) {
        this.audioDebugConeX = new PositionalAudioHelper(this.positionalAudio, 10);
        this.positionalAudio.add(this.audioDebugConeX);
        this.audioDebugConeY = new PositionalAudioHelper(this.positionalAudio, 10);
        this.audioDebugConeY.rotation.z = Math.PI / 2;
        this.positionalAudio.add(this.audioDebugConeY);
      }
      if (!this.audio.props.coneAngle && this.audioDebugConeX) {
        this.audioDebugConeX.removeFromParent();
        this.audioDebugConeX = null;
        (_a = this.audioDebugConeY) == null ? void 0 : _a.removeFromParent();
        this.audioDebugConeY = null;
      }
    }
    (_b = this.audioDebugConeX) == null ? void 0 : _b.update();
    (_c = this.audioDebugConeY) == null ? void 0 : _c.update();
  }
  getAudioListener() {
    return this.audio.getScene().getGraphicsAdapter().getAudioListener();
  }
};

// src/elements/ThreeJSChatProbe.ts
import { ChatProbeGraphics } from "@mml-io/mml-web";
import * as THREE2 from "three";
var _ThreeJSChatProbe = class _ThreeJSChatProbe extends ChatProbeGraphics {
  constructor(chatProbe) {
    super(chatProbe);
    this.chatProbe = chatProbe;
    this.debugMesh = null;
  }
  disable() {
  }
  enable() {
  }
  setRange() {
    this.updateDebugVisualisation();
  }
  setDebug() {
    this.updateDebugVisualisation();
  }
  clearDebugVisualisation() {
    if (this.debugMesh) {
      this.debugMesh.removeFromParent();
      this.debugMesh = null;
    }
  }
  updateDebugVisualisation() {
    if (!this.chatProbe.props.debug) {
      this.clearDebugVisualisation();
    } else {
      if (this.chatProbe.isConnected && !this.debugMesh) {
        const mesh = new THREE2.Mesh(_ThreeJSChatProbe.DebugGeometry, _ThreeJSChatProbe.DebugMaterial);
        mesh.castShadow = false;
        mesh.receiveShadow = false;
        this.debugMesh = mesh;
        this.chatProbe.getContainer().add(this.debugMesh);
      }
      if (this.debugMesh) {
        this.debugMesh.scale.set(
          this.chatProbe.props.range,
          this.chatProbe.props.range,
          this.chatProbe.props.range
        );
      }
    }
  }
  dispose() {
    this.clearDebugVisualisation();
  }
};
_ThreeJSChatProbe.DebugGeometry = new THREE2.SphereGeometry(1, 16, 16, 1);
_ThreeJSChatProbe.DebugMaterial = new THREE2.MeshBasicMaterial({
  color: 16776960,
  wireframe: true,
  transparent: true,
  opacity: 0.3
});
var ThreeJSChatProbe = _ThreeJSChatProbe;

// src/elements/ThreeJSCube.ts
import { CubeGraphics } from "@mml-io/mml-web";
import * as THREE3 from "three";
var _ThreeJSCube = class _ThreeJSCube extends CubeGraphics {
  constructor(cube) {
    super(cube);
    this.cube = cube;
    this.material = new THREE3.MeshStandardMaterial({
      color: new THREE3.Color(cube.props.color.r, cube.props.color.g, cube.props.color.b)
    });
    this.mesh = new THREE3.Mesh(_ThreeJSCube.boxGeometry, this.material);
    this.mesh.castShadow = cube.props.castShadows;
    this.mesh.receiveShadow = true;
    this.cube.getContainer().add(this.mesh);
  }
  disable() {
  }
  enable() {
  }
  getCollisionElement() {
    return this.mesh;
  }
  setColor(color) {
    this.material.color = new THREE3.Color(color.r, color.g, color.b);
  }
  setWidth(width) {
    this.mesh.scale.x = width;
  }
  setHeight(height) {
    this.mesh.scale.y = height;
  }
  setDepth(depth) {
    this.mesh.scale.z = depth;
  }
  setCastShadows(castShadows) {
    this.mesh.castShadow = castShadows;
  }
  setOpacity(opacity) {
    const needsUpdate = this.material.transparent === (opacity === 1);
    this.material.transparent = opacity !== 1;
    this.material.needsUpdate = needsUpdate;
    this.material.opacity = opacity;
  }
  dispose() {
  }
};
_ThreeJSCube.boxGeometry = new THREE3.BoxGeometry(1, 1, 1);
var ThreeJSCube = _ThreeJSCube;

// src/elements/ThreeJSCylinder.ts
import { CylinderGraphics } from "@mml-io/mml-web";
import * as THREE4 from "three";
var _ThreeJSCylinder = class _ThreeJSCylinder extends CylinderGraphics {
  constructor(cylinder) {
    super(cylinder);
    this.cylinder = cylinder;
    this.material = new THREE4.MeshStandardMaterial({
      color: new THREE4.Color(
        cylinder.props.color.r,
        cylinder.props.color.g,
        cylinder.props.color.b
      )
    });
    this.mesh = new THREE4.Mesh(_ThreeJSCylinder.cylinderGeometry, this.material);
    this.mesh.castShadow = cylinder.props.castShadows;
    this.mesh.receiveShadow = true;
    this.cylinder.getContainer().add(this.mesh);
  }
  disable() {
  }
  enable() {
  }
  getCollisionElement() {
    return this.mesh;
  }
  setColor(color) {
    this.material.color = new THREE4.Color(color.r, color.g, color.b);
  }
  setRadius(radius) {
    this.mesh.scale.x = radius * 2;
    this.mesh.scale.z = radius * 2;
  }
  setHeight(height) {
    this.mesh.scale.y = height;
  }
  setCastShadows(castShadows) {
    this.mesh.castShadow = castShadows;
  }
  setOpacity(opacity) {
    const needsUpdate = this.material.transparent === (opacity === 1);
    this.material.transparent = opacity !== 1;
    this.material.needsUpdate = needsUpdate;
    this.material.opacity = opacity;
  }
  dispose() {
  }
};
_ThreeJSCylinder.cylinderGeometry = new THREE4.CylinderGeometry(0.5, 0.5, 1);
var ThreeJSCylinder = _ThreeJSCylinder;

// src/elements/ThreeJSDebugHelper.ts
import { DebugHelperGraphics } from "@mml-io/mml-web";
import * as THREE5 from "three";
var ThreeJSDebugHelper = class extends DebugHelperGraphics {
  constructor(debugHelper) {
    super(debugHelper);
    this.debugHelper = debugHelper;
    this.debugAxes = null;
    this.debugAxes = new THREE5.AxesHelper(1);
    this.debugHelper.getContainer().add(this.debugAxes);
  }
  dispose() {
    if (this.debugAxes) {
      this.debugHelper.getContainer().remove(this.debugAxes);
    }
    this.debugAxes = null;
  }
};

// src/elements/ThreeJSFrame.ts
import { FrameGraphics } from "@mml-io/mml-web";
import * as THREE6 from "three";
function setMeshToBoundingBox(mesh, minX, maxX, minY, maxY, minZ, maxZ) {
  mesh.scale.set(maxX - minX, maxY - minY, maxZ - minZ);
  mesh.position.set((maxX + minX) / 2, (maxY + minY) / 2, (maxZ + minZ) / 2);
}
var _ThreeJSFrame = class _ThreeJSFrame extends FrameGraphics {
  constructor(frame) {
    super(frame);
    this.frame = frame;
    this.debugMeshes = null;
  }
  setSrc() {
  }
  setDebug() {
    this.updateDebugVisualisation();
  }
  setLoadRange() {
    this.updateDebugVisualisation();
  }
  setUnloadRange() {
    this.updateDebugVisualisation();
  }
  setMinX() {
    this.updateDebugVisualisation();
  }
  setMaxX() {
    this.updateDebugVisualisation();
  }
  setMinY() {
    this.updateDebugVisualisation();
  }
  setMaxY() {
    this.updateDebugVisualisation();
  }
  setMinZ() {
    this.updateDebugVisualisation();
  }
  setMaxZ() {
    this.updateDebugVisualisation();
  }
  disable() {
  }
  enable() {
  }
  dispose() {
  }
  clearDebugVisualisation() {
    if (this.debugMeshes) {
      this.debugMeshes.debugBoxConstraintMesh.removeFromParent();
      this.debugMeshes.debugBoxLoadRangeMesh.removeFromParent();
      this.debugMeshes.debugBoxUnloadRangeMesh.removeFromParent();
      this.debugMeshes = null;
    }
  }
  updateDebugVisualisation() {
    if (!this.frame.props.debug) {
      this.clearDebugVisualisation();
    } else {
      if (!this.frame.isConnected) {
        return;
      }
      if (!this.debugMeshes) {
        this.debugMeshes = {
          debugBoxConstraintMesh: new THREE6.Mesh(
            _ThreeJSFrame.DebugBoxGeometry,
            _ThreeJSFrame.DebugConstraintMaterial
          ),
          debugBoxLoadRangeMesh: new THREE6.Mesh(
            _ThreeJSFrame.DebugBoxGeometry,
            _ThreeJSFrame.DebugLoadRangeMaterial
          ),
          debugBoxUnloadRangeMesh: new THREE6.Mesh(
            _ThreeJSFrame.DebugBoxGeometry,
            _ThreeJSFrame.DebugUnloadRangeMaterial
          )
        };
        this.frame.getContainer().add(this.debugMeshes.debugBoxConstraintMesh);
        this.frame.getContainer().add(this.debugMeshes.debugBoxLoadRangeMesh);
        this.frame.getContainer().add(this.debugMeshes.debugBoxUnloadRangeMesh);
      }
      let boxBounds = this.frame.getDefinedBoxBounds();
      if (!boxBounds) {
        boxBounds = [0, 0, 0, 0, 0, 0];
      }
      const [minX, maxX, minY, maxY, minZ, maxZ] = boxBounds;
      this.debugMeshes.debugBoxConstraintMesh.visible = true;
      this.debugMeshes.debugBoxLoadRangeMesh.visible = true;
      this.debugMeshes.debugBoxUnloadRangeMesh.visible = true;
      setMeshToBoundingBox(
        this.debugMeshes.debugBoxConstraintMesh,
        minX,
        maxX,
        minY,
        maxY,
        minZ,
        maxZ
      );
      if (this.frame.props.loadRange === null) {
        this.debugMeshes.debugBoxLoadRangeMesh.visible = false;
        this.debugMeshes.debugBoxUnloadRangeMesh.visible = false;
      } else {
        this.debugMeshes.debugBoxLoadRangeMesh.visible = true;
        this.debugMeshes.debugBoxUnloadRangeMesh.visible = true;
        setMeshToBoundingBox(
          this.debugMeshes.debugBoxLoadRangeMesh,
          minX - this.frame.props.loadRange,
          maxX + this.frame.props.loadRange,
          minY - this.frame.props.loadRange,
          maxY + this.frame.props.loadRange,
          minZ - this.frame.props.loadRange,
          maxZ + this.frame.props.loadRange
        );
        setMeshToBoundingBox(
          this.debugMeshes.debugBoxUnloadRangeMesh,
          minX - this.frame.props.loadRange - this.frame.props.unloadRange,
          maxX + this.frame.props.loadRange + this.frame.props.unloadRange,
          minY - this.frame.props.loadRange - this.frame.props.unloadRange,
          maxY + this.frame.props.loadRange + this.frame.props.unloadRange,
          minZ - this.frame.props.loadRange - this.frame.props.unloadRange,
          maxZ + this.frame.props.loadRange + this.frame.props.unloadRange
        );
      }
    }
  }
};
_ThreeJSFrame.DebugBoxGeometry = new THREE6.BoxGeometry(1, 1, 1, 1, 1, 1);
_ThreeJSFrame.DebugConstraintMaterial = new THREE6.MeshBasicMaterial({
  color: 16711680,
  wireframe: true,
  transparent: true,
  opacity: 0.3
});
_ThreeJSFrame.DebugLoadRangeMaterial = new THREE6.MeshBasicMaterial({
  color: 65280,
  wireframe: true,
  transparent: true,
  opacity: 0.3
});
_ThreeJSFrame.DebugUnloadRangeMaterial = new THREE6.MeshBasicMaterial({
  color: 255,
  wireframe: true,
  transparent: true,
  opacity: 0.3
});
var ThreeJSFrame = _ThreeJSFrame;

// src/elements/ThreeJSImage.ts
import {
  calculateContentSize,
  Image,
  ImageGraphics,
  LoadingInstanceManager as LoadingInstanceManager3
} from "@mml-io/mml-web";
import * as THREE7 from "three";
var _ThreeJSImage = class _ThreeJSImage extends ImageGraphics {
  constructor(image, updateMeshCallback) {
    super(image, updateMeshCallback);
    this.image = image;
    this.updateMeshCallback = updateMeshCallback;
    this.latestImageHandle = null;
    this.loadedImageHasTransparency = false;
    this.srcLoadingInstanceManager = new LoadingInstanceManager3(`${Image.tagName}.src`);
    this.material = new THREE7.MeshStandardMaterial({
      color: 16777215,
      transparent: this.image.props.opacity !== 1 || this.loadedImageHasTransparency,
      opacity: this.image.props.opacity,
      side: THREE7.DoubleSide
    });
    this.mesh = new THREE7.Mesh(_ThreeJSImage.planeGeometry, this.material);
    this.mesh.castShadow = image.props.castShadows;
    this.mesh.receiveShadow = true;
    this.image.getContainer().add(this.mesh);
  }
  getWidthAndHeight() {
    return {
      width: this.mesh.scale.x,
      height: this.mesh.scale.y
    };
  }
  disable() {
  }
  enable() {
  }
  getCollisionElement() {
    return this.mesh;
  }
  setWidth() {
    this.updateWidthAndHeight();
  }
  setHeight() {
    this.updateWidthAndHeight();
  }
  setCastShadows(castShadows) {
    this.mesh.castShadow = castShadows;
  }
  setOpacity(opacity) {
    const shouldBeTransparent = opacity !== 1 || this.loadedImageHasTransparency;
    const needsUpdate = this.material.transparent !== shouldBeTransparent;
    this.material.transparent = shouldBeTransparent;
    this.material.opacity = opacity;
    if (needsUpdate) {
      this.material.needsUpdate = true;
    }
  }
  setEmissive() {
    this.updateMaterialEmissiveIntensity();
  }
  updateMaterialEmissiveIntensity() {
    if (this.material) {
      const map = this.material.map;
      if (this.image.props.emissive > 0) {
        this.material.emissive = new THREE7.Color(16777215);
        this.material.emissiveMap = map;
        this.material.emissiveIntensity = this.image.props.emissive;
        this.material.needsUpdate = true;
      } else {
        this.material.emissive = new THREE7.Color(0);
        this.material.emissiveMap = null;
        this.material.emissiveIntensity = 1;
        this.material.needsUpdate = true;
      }
    }
  }
  setSrc(newValue) {
    var _a;
    if (((_a = this.latestImageHandle) == null ? void 0 : _a.url) === newValue) {
      return;
    }
    if (this.latestImageHandle) {
      this.latestImageHandle.dispose();
      this.srcLoadingInstanceManager.abortIfLoading();
    }
    this.latestImageHandle = null;
    const src = (newValue || "").trim();
    const isDataUri = src.startsWith("data:image/");
    if (this.loadedImageDimensions !== null && !isDataUri) {
      this.clearImage();
    }
    if (!src) {
      this.updateWidthAndHeight();
      this.srcLoadingInstanceManager.abortIfLoading();
      return;
    }
    if (!this.material) {
      return;
    }
    if (isDataUri) {
      const image = document.createElement("img");
      image.src = src;
      this.loadedImageDimensions = {
        width: image.width,
        height: image.height
      };
      const finalize = () => {
        const texture = new THREE7.CanvasTexture(image);
        const result = {
          texture,
          width: image.width,
          height: image.height,
          hasTransparency: hasTransparency(image)
        };
        this.applyTexture(result);
      };
      if (image.complete) {
        finalize();
      } else {
        image.addEventListener("load", finalize);
      }
      this.srcLoadingInstanceManager.abortIfLoading();
      return;
    }
    const contentSrc = this.image.contentSrcToContentAddress(src);
    this.srcLoadingInstanceManager.start(this.image.getLoadingProgressManager(), contentSrc);
    const imageHandle = this.image.getScene().getGraphicsAdapter().getResourceManager().loadImage(contentSrc);
    this.latestImageHandle = imageHandle;
    imageHandle.onProgress((loaded, total) => {
      if (this.latestImageHandle !== imageHandle) {
        return;
      }
      this.srcLoadingInstanceManager.setProgress(loaded / total);
    });
    imageHandle.onLoad((result) => {
      if (result instanceof Error) {
        console.error("Error loading image:", newValue, result);
        this.srcLoadingInstanceManager.error(result);
        return;
      }
      if (this.latestImageHandle !== imageHandle || !this.material) {
        return;
      }
      this.applyTexture(result);
      this.srcLoadingInstanceManager.finish();
    });
  }
  updateWidthAndHeight() {
    const mesh = this.mesh;
    const { width, height } = calculateContentSize({
      content: this.loadedImageDimensions ? { width: this.loadedImageDimensions.width, height: this.loadedImageDimensions.height } : void 0,
      width: this.image.props.width,
      height: this.image.props.height
    });
    mesh.scale.x = width;
    mesh.scale.y = height;
    this.updateMeshCallback();
  }
  applyTexture(result) {
    this.loadedImageHasTransparency = result.hasTransparency;
    if (!this.material) {
      return;
    }
    this.loadedImageDimensions = {
      width: result.width,
      height: result.height
    };
    this.material.map = result.texture;
    this.material.transparent = this.image.props.opacity !== 1 || result.hasTransparency;
    this.material.alphaTest = 0.01;
    this.material.needsUpdate = true;
    this.updateMaterialEmissiveIntensity();
    this.updateWidthAndHeight();
  }
  clearImage() {
    this.loadedImageDimensions = null;
    if (this.material && this.material.map) {
      this.material.needsUpdate = true;
      this.material.map = null;
      this.material.alphaMap = null;
      this.material.alphaTest = 0;
    }
    this.updateWidthAndHeight();
  }
  dispose() {
    if (this.latestImageHandle) {
      this.latestImageHandle.dispose();
    }
    this.latestImageHandle = null;
    this.material.map = null;
    if (this.material.emissiveMap) {
      this.material.emissiveMap.dispose();
      this.material.emissiveMap = null;
    }
    this.material.dispose();
    this.loadedImageDimensions = null;
    this.srcLoadingInstanceManager.dispose();
  }
};
_ThreeJSImage.planeGeometry = new THREE7.PlaneGeometry(1, 1);
var ThreeJSImage = _ThreeJSImage;
function hasTransparency(image) {
  if (image.width === 0 || image.height === 0) {
    return false;
  }
  const canvas = document.createElement("canvas");
  canvas.width = image.width;
  canvas.height = image.height;
  const ctx = canvas.getContext("2d");
  ctx.drawImage(image, 0, 0);
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
  for (let i = 3, n = imageData.length; i < n; i += 4) {
    if (imageData[i] < 255) {
      return true;
    }
  }
  return false;
}

// src/elements/ThreeJSInteraction.ts
import { InteractionGraphics } from "@mml-io/mml-web";
import * as THREE8 from "three";
var _ThreeJSInteraction = class _ThreeJSInteraction extends InteractionGraphics {
  constructor(positionProbe) {
    super(positionProbe);
    this.positionProbe = positionProbe;
    this.debugMesh = null;
  }
  disable() {
  }
  enable() {
  }
  setRange() {
    this.updateDebugVisualisation();
  }
  setInFocus() {
  }
  setLineOfSight() {
  }
  setPriority() {
  }
  setPrompt() {
  }
  setDebug() {
    this.updateDebugVisualisation();
  }
  clearDebugVisualisation() {
    if (this.debugMesh) {
      this.debugMesh.removeFromParent();
      this.debugMesh = null;
    }
  }
  updateDebugVisualisation() {
    if (!this.positionProbe.props.debug) {
      this.clearDebugVisualisation();
    } else {
      if (this.positionProbe.isConnected && !this.debugMesh) {
        const mesh = new THREE8.Mesh(
          _ThreeJSInteraction.DebugGeometry,
          _ThreeJSInteraction.DebugMaterial
        );
        mesh.castShadow = false;
        mesh.receiveShadow = false;
        this.debugMesh = mesh;
        this.positionProbe.getContainer().add(this.debugMesh);
      }
      if (this.debugMesh) {
        this.debugMesh.scale.set(
          this.positionProbe.props.range,
          this.positionProbe.props.range,
          this.positionProbe.props.range
        );
      }
    }
  }
  dispose() {
    this.clearDebugVisualisation();
  }
};
_ThreeJSInteraction.DebugGeometry = new THREE8.SphereGeometry(1, 16, 16, 1);
_ThreeJSInteraction.DebugMaterial = new THREE8.MeshBasicMaterial({
  color: 43520,
  wireframe: true,
  transparent: true,
  opacity: 0.3
});
var ThreeJSInteraction = _ThreeJSInteraction;

// src/elements/ThreeJSLabel.ts
import { LabelGraphics } from "@mml-io/mml-web";
import * as THREE9 from "three";
var _ThreeJSLabel = class _ThreeJSLabel extends LabelGraphics {
  constructor(label) {
    super(label);
    this.label = label;
    this.material = null;
    this.latestLabelHandle = null;
    this.shouldDrawText = false;
    this.material = new THREE9.MeshStandardMaterial({
      transparent: false
    });
    this.mesh = new THREE9.Mesh(_ThreeJSLabel.labelGeometry, this.material);
    this.mesh.material = this.material;
    this.mesh.scale.x = this.label.props.width;
    this.mesh.scale.y = this.label.props.height;
    this.mesh.castShadow = this.label.props.castShadows;
    this.mesh.receiveShadow = true;
    this.redrawText();
    this.label.getContainer().add(this.mesh);
  }
  allAttributesObserved() {
    this.shouldDrawText = true;
    this.redrawText();
  }
  disable() {
  }
  enable() {
  }
  getCollisionElement() {
    return this.mesh;
  }
  setContent() {
    this.redrawText();
  }
  setAlignment() {
    this.redrawText();
  }
  setFontSize() {
    this.redrawText();
  }
  setPadding() {
    this.redrawText();
  }
  setFontColor() {
    this.redrawText();
  }
  setEmissive() {
    this.updateMaterialEmissiveIntensity();
  }
  setColor() {
    this.redrawText();
  }
  setWidth(width) {
    this.mesh.scale.x = width;
    this.redrawText();
  }
  setHeight(height) {
    this.mesh.scale.y = height;
    this.redrawText();
  }
  setCastShadows(castShadows) {
    this.mesh.castShadow = castShadows;
  }
  redrawText() {
    if (!this.shouldDrawText) {
      return;
    }
    if (!this.material) {
      return;
    }
    if (this.latestLabelHandle) {
      this.latestLabelHandle.dispose();
      this.latestLabelHandle = null;
    }
    const desiredWidth = this.label.props.width * 200;
    const desiredHeight = this.label.props.height * 200;
    const handle = this.label.getScene().getGraphicsAdapter().getResourceManager().loadLabel({
      content: this.label.props.content,
      fontSize: this.label.props.fontSize * 2,
      paddingPx: this.label.props.padding,
      textColorRGB255A1: {
        r: this.label.props.fontColor.r * 255,
        g: this.label.props.fontColor.g * 255,
        b: this.label.props.fontColor.b * 255,
        a: this.label.props.fontColor.a ?? 1
      },
      backgroundColorRGB255A1: {
        r: this.label.props.color.r * 255,
        g: this.label.props.color.g * 255,
        b: this.label.props.color.b * 255,
        a: this.label.props.color.a ?? 1
      },
      dimensions: {
        width: desiredWidth,
        height: desiredHeight
      },
      alignment: this.label.props.alignment,
      bold: true
    });
    this.latestLabelHandle = handle;
    const apply = (result2) => {
      if (result2 instanceof Error || !this.material) {
        return;
      }
      this.material.map = result2.texture;
      const hasTransparency3 = (this.label.props.color.a ?? 1) < 1;
      this.material.transparent = hasTransparency3;
      this.material.alphaTest = hasTransparency3 ? 0.01 : 0;
      this.material.needsUpdate = true;
      this.updateMaterialEmissiveIntensity();
    };
    const result = handle.getResult();
    if (result) {
      apply(result);
    } else {
      handle.onLoad(apply);
    }
  }
  updateMaterialEmissiveIntensity() {
    if (this.material) {
      const map = this.material.map;
      if (this.label.props.emissive > 0) {
        this.material.emissive = new THREE9.Color(16777215);
        this.material.emissiveMap = map;
        this.material.emissiveIntensity = this.label.props.emissive;
        this.material.needsUpdate = true;
      } else {
        this.material.emissive = new THREE9.Color(0);
        this.material.emissiveMap = null;
        this.material.emissiveIntensity = 1;
        this.material.needsUpdate = true;
      }
    }
  }
  dispose() {
    if (this.latestLabelHandle) {
      this.latestLabelHandle.dispose();
      this.latestLabelHandle = null;
    }
    if (this.material) {
      this.material.map = null;
      if (this.material.emissiveMap) {
        this.material.emissiveMap.dispose();
        this.material.emissiveMap = null;
      }
      this.material.dispose();
      this.material = null;
    }
  }
};
_ThreeJSLabel.labelGeometry = new THREE9.PlaneGeometry(1, 1);
var ThreeJSLabel = _ThreeJSLabel;

// src/elements/ThreeJSLight.ts
import { LightTypes } from "@mml-io/mml-web";
import { LightGraphics } from "@mml-io/mml-web";
import * as THREE10 from "three";
var debugSphereSize = 0.25;
var ThreeJSLight = class extends LightGraphics {
  constructor(light) {
    super(light);
    this.light = light;
    this.createLight();
  }
  createLight() {
    if (this.threeLight) {
      this.threeLight.removeFromParent();
    }
    const { r, g, b } = this.light.props.color;
    const color = new THREE10.Color(r, g, b);
    switch (this.light.props.type) {
      case LightTypes.spotlight: {
        const light = new THREE10.SpotLight(
          color,
          this.light.props.intensity,
          this.light.props.distance ?? void 0,
          THREE10.MathUtils.degToRad(this.light.props.angleDeg)
        );
        const target = new THREE10.Object3D();
        target.position.set(0, -1, 0);
        light.position.set(0, 0, 0);
        light.add(target);
        light.target = target;
        this.threeLight = light;
        break;
      }
      case LightTypes.point:
        this.threeLight = new THREE10.PointLight(
          color,
          this.light.props.intensity,
          this.light.props.distance ?? void 0
        );
        break;
    }
    if (this.threeLight.shadow) {
      this.threeLight.castShadow = this.light.props.castShadows;
      this.threeLight.shadow.mapSize.width = 512;
      this.threeLight.shadow.mapSize.height = 512;
      if (this.threeLight.shadow.camera.isPerspectiveCamera) {
        this.threeLight.shadow.camera.near = 0.5;
        this.threeLight.shadow.camera.far = 500;
      }
      this.threeLight.shadow.bias = -1e-3;
      this.threeLight.shadow.normalBias = 0.01;
      const d = 10;
      const c = this.threeLight.shadow.camera;
      c.left = -d;
      c.right = d;
      c.top = d;
      c.bottom = -d;
    }
    this.threeLight.intensity = this.light.props.intensity;
    this.light.getContainer().add(this.threeLight);
    if (this.threeLightHelper) {
      this.makeLightHelper();
    }
    if (!this.light.props.enabled) {
      this.threeLight.visible = false;
      if (this.threeLightHelper) {
        this.threeLightHelper.visible = false;
      }
    }
  }
  makeLightHelper() {
    if (this.threeLightHelper) {
      this.threeLightHelper.removeFromParent();
      this.threeLightHelper = null;
    }
    if (this.light instanceof THREE10.PointLight) {
      this.threeLightHelper = new THREE10.PointLightHelper(this.light, debugSphereSize);
    } else if (this.light instanceof THREE10.SpotLight) {
      this.threeLightHelper = new THREE10.SpotLightHelper(this.light);
    }
    if (this.threeLightHelper) {
      this.light.getContainer().add(this.threeLightHelper);
      this.threeLightHelper.matrix = this.threeLight.matrix;
      this.threeLightHelper.visible = this.threeLight.visible;
    }
  }
  disable() {
  }
  enable() {
  }
  setEnabled(enabled) {
    this.threeLight.visible = enabled;
    if (this.threeLightHelper) {
      this.threeLightHelper.visible = enabled;
    }
  }
  setCastShadows(castShadows) {
    this.threeLight.castShadow = castShadows;
  }
  setAngle(angle) {
    if (this.threeLight.isSpotLight) {
      this.threeLight.angle = THREE10.MathUtils.degToRad(angle);
    }
  }
  setIntensity(intensity) {
    this.threeLight.intensity = intensity;
  }
  setDistance(distance) {
    this.threeLight.distance = distance;
  }
  setType() {
    this.createLight();
  }
  setDebug(debug) {
    if (debug && !this.threeLightHelper) {
      this.makeLightHelper();
    } else if (!debug && this.threeLightHelper) {
      this.threeLightHelper.removeFromParent();
      this.threeLightHelper = null;
    }
  }
  setColor(color) {
    this.threeLight.color.set(new THREE10.Color(color.r, color.g, color.b));
    if (this.threeLightHelper) {
      this.threeLightHelper.color = new THREE10.Color(color.r, color.g, color.b);
    }
  }
  dispose() {
    this.light.getContainer().remove(this.threeLight);
    if (this.threeLightHelper) {
      this.threeLightHelper.removeFromParent();
    }
  }
};

// src/elements/ThreeJSLink.ts
import { LinkGraphics } from "@mml-io/mml-web";
var ThreeJSLink = class extends LinkGraphics {
  constructor(link) {
    super(link);
    this.link = link;
  }
  disable() {
  }
  enable() {
  }
  setHref() {
  }
  setTarget() {
  }
  dispose() {
  }
};

// src/elements/ThreeJSMElement.ts
import { MELEMENT_PROPERTY_NAME } from "@mml-io/mml-web";
import { MElementGraphics } from "@mml-io/mml-web";
import * as THREE11 from "three";
var ThreeJSMElement = class extends MElementGraphics {
  constructor(element) {
    super(element);
    this.element = element;
    this.currentParentContainer = null;
    this.container = new THREE11.Group();
    this.container.name = this.constructor.name;
    this.container[MELEMENT_PROPERTY_NAME] = element;
    if (this.currentParentContainer !== null) {
      throw new Error("Already connected to a parent");
    }
    const mElementParent = this.element.getMElementParent();
    if (mElementParent) {
      this.currentParentContainer = mElementParent.getContainer();
      this.currentParentContainer.add(this.container);
      return;
    }
    const scene = this.element.getScene();
    this.currentParentContainer = scene.getGraphicsAdapter().getRootContainer();
    this.currentParentContainer.add(this.container);
  }
  getContainer() {
    return this.container;
  }
  dispose() {
    if (this.currentParentContainer === null) {
      throw new Error("Was not connected to a parent");
    }
    this.currentParentContainer.remove(this.container);
    this.currentParentContainer = null;
  }
};

// src/elements/ThreeJSModel.ts
import { Model as Model2, TransformableElement } from "@mml-io/mml-web";
import { ModelGraphics } from "@mml-io/mml-web";
import { LoadingInstanceManager as LoadingInstanceManager4 } from "@mml-io/mml-web";
import * as THREE12 from "three";
function createFilteredClip(clip, nodeNames) {
  const compatibleTracks = clip.tracks.filter((track) => {
    const trackName = track.name;
    const nodeName = trackName.split(".")[0];
    return nodeNames.has(nodeName);
  });
  const filteredClip = new THREE12.AnimationClip(clip.name, clip.duration, compatibleTracks);
  return filteredClip;
}
var _ThreeJSModel = class _ThreeJSModel extends ModelGraphics {
  constructor(model, updateMeshCallback) {
    super(model, updateMeshCallback);
    this.model = model;
    this.updateMeshCallback = updateMeshCallback;
    this.srcLoadingInstanceManager = new LoadingInstanceManager4(`${Model2.tagName}.src`);
    this.animLoadingInstanceManager = new LoadingInstanceManager4(`${Model2.tagName}.anim`);
    this.latestSrcModelHandle = null;
    this.latestAnimModelHandle = null;
    this.socketChildrenByBone = /* @__PURE__ */ new Map();
    this.attachments = /* @__PURE__ */ new Map();
    this.registeredParentAttachment = null;
    this.debugBoundingBox = null;
    this.loadedState = null;
    this.animState = null;
    this.documentTimeTickListener = null;
    this.childAnimationMixer = null;
    this.childAnimations = /* @__PURE__ */ new Map();
  }
  hasLoadedModel() {
    var _a;
    return !!((_a = this.loadedState) == null ? void 0 : _a.group);
  }
  hasLoadedAnimation() {
    var _a;
    return !!((_a = this.animState) == null ? void 0 : _a.appliedAnimation);
  }
  disable() {
  }
  enable() {
  }
  getBoundingBox() {
    if (this.loadedState) {
      return {
        centerOffset: this.loadedState.boundingBox.centerOffset,
        size: this.loadedState.boundingBox.size
      };
    }
    return null;
  }
  getCollisionElement() {
    var _a;
    return ((_a = this.loadedState) == null ? void 0 : _a.group) ?? null;
  }
  setDebug() {
    this.updateDebugVisualisation();
  }
  setCastShadows(castShadows) {
    if (this.loadedState) {
      this.loadedState.group.traverse((object) => {
        if (object.isMesh) {
          const mesh = object;
          mesh.castShadow = castShadows;
        }
      });
    }
  }
  updateChildAnimation(animation, animationState) {
    let childAnimation = this.childAnimations.get(animation);
    if (!this.childAnimationMixer || !this.loadedState) {
      this.childAnimations.set(animation, {
        action: null,
        clip: null,
        animationState
      });
    } else {
      if (childAnimation && childAnimation.action && childAnimation.clip !== animationState.animationClip) {
        childAnimation.action.stop();
        this.childAnimationMixer.uncacheAction(
          childAnimation.action.getClip(),
          this.loadedState.group
        );
        childAnimation.action = null;
        childAnimation = void 0;
      }
      if (!childAnimation) {
        childAnimation = {
          action: null,
          clip: null,
          animationState
        };
        this.childAnimations.set(animation, childAnimation);
      } else {
        childAnimation.animationState = animationState;
      }
      if (!childAnimation.action && animationState && animationState.animationClip) {
        const filteredClip = createFilteredClip(
          animationState.animationClip,
          this.loadedState.nodeNames
        );
        const action = this.childAnimationMixer.clipAction(filteredClip, this.loadedState.group);
        action.enabled = true;
        this.childAnimations.set(animation, {
          action,
          clip: animationState.animationClip,
          animationState
        });
      }
    }
    for (const [attachment, attachmentAnimState] of this.attachments) {
      this.updateAnimationForAttachment(attachment, attachmentAnimState, animation, animationState);
    }
    const documentTime = this.model.getDocumentTime();
    this.updateAnimation(documentTime);
  }
  updateAnimationForAttachment(attachment, attachmentAnimState, animation, animationState) {
    let attachmentChildAnimation = attachmentAnimState.childAnimations.animations.get(animation);
    const attachmentChildAnimationMixer = attachmentAnimState.childAnimations.animationMixer;
    const attachmentLoadedState = attachment.modelGraphics.loadedState;
    if (!attachmentLoadedState) {
      throw new Error("Attachment must be loaded before registering");
    }
    if (attachmentChildAnimation && attachmentChildAnimation.action && attachmentChildAnimation.clip && attachmentChildAnimation.clip !== animationState.animationClip) {
      attachmentChildAnimation.action.stop();
      attachmentChildAnimationMixer.uncacheAction(
        attachmentChildAnimation.clip,
        attachmentLoadedState.group
      );
      attachmentChildAnimation.action = null;
      attachmentChildAnimation = void 0;
    }
    if (!attachmentChildAnimation) {
      attachmentChildAnimation = {
        action: null,
        clip: null,
        animationState
      };
      attachmentAnimState.childAnimations.animations.set(animation, attachmentChildAnimation);
    } else {
      attachmentChildAnimation.animationState = animationState;
    }
    if (!attachmentChildAnimation.action && animationState && animationState.animationClip) {
      const filteredClip = createFilteredClip(
        animationState.animationClip,
        attachmentLoadedState.nodeNames
      );
      const action = attachmentChildAnimationMixer.clipAction(
        filteredClip,
        attachmentLoadedState.group
      );
      action.enabled = true;
      action.play();
      attachmentAnimState.childAnimations.animations.set(animation, {
        action,
        clip: animationState.animationClip,
        animationState
      });
    }
  }
  removeChildAnimation(animation) {
    const childAnimation = this.childAnimations.get(animation);
    if (childAnimation) {
      const action = childAnimation.action;
      if (action) {
        action.stop();
        if (this.childAnimationMixer && this.loadedState) {
          this.childAnimationMixer.uncacheAction(action.getClip(), this.loadedState.group);
        }
      }
      this.childAnimations.delete(animation);
      for (const [attachment, attachmentAnimState] of this.attachments) {
        this.removeAnimationForAttachment(attachment, attachmentAnimState, animation);
      }
    }
  }
  removeAnimationForAttachment(attachment, attachmentAnimState, animation) {
    const attachmentChildAnimation = attachmentAnimState.childAnimations.animations.get(animation);
    if (attachmentChildAnimation) {
      const action = attachmentChildAnimation.action;
      if (action) {
        action.stop();
        const attachmentLoadedState = attachment.modelGraphics.loadedState;
        if (attachmentLoadedState) {
          attachmentAnimState.childAnimations.animationMixer.uncacheAction(
            action.getClip(),
            attachmentLoadedState.group
          );
        }
        attachmentChildAnimation.action = null;
      }
    }
    attachmentAnimState.childAnimations.animations.delete(animation);
  }
  setAnim(anim) {
    var _a, _b, _c, _d;
    if (((_a = this.latestAnimModelHandle) == null ? void 0 : _a.url) === anim) {
      return;
    }
    if (this.latestAnimModelHandle) {
      this.latestAnimModelHandle.dispose();
      this.animLoadingInstanceManager.abortIfLoading();
    }
    this.latestAnimModelHandle = null;
    this.resetAnimationMixer();
    this.animState = null;
    for (const [, attachmentAnimState] of this.attachments) {
      if (attachmentAnimState) {
        (_c = (_b = attachmentAnimState.directAnimation) == null ? void 0 : _b.animationMixer) == null ? void 0 : _c.stopAllAction();
        if ((_d = attachmentAnimState.directAnimation) == null ? void 0 : _d.animationMixer) {
          attachmentAnimState.directAnimation.animationMixer.update(0);
        }
        attachmentAnimState.childAnimations.animationMixer.stopAllAction();
        attachmentAnimState.childAnimations.animationMixer.update(0);
        attachmentAnimState.directAnimation = null;
      }
    }
    if (!anim) {
      this.animLoadingInstanceManager.abortIfLoading();
      if (this.loadedState && !this.registeredParentAttachment) {
        const parent = this.model.parentElement;
        if (parent && Model2.isModel(parent)) {
          this.registeredParentAttachment = parent;
          parent.modelGraphics.registerAttachment(this.model);
        }
      }
      if (this.loadedState && !this.documentTimeTickListener) {
        this.documentTimeTickListener = this.model.addDocumentTimeTickListener(
          (documentTime) => {
            this.updateAnimation(documentTime);
          }
        );
      }
      for (const [attachment, attachmentAnimState] of this.attachments) {
        for (const [animation, childAnimation] of this.childAnimations) {
          this.updateAnimationForAttachment(
            attachment,
            attachmentAnimState,
            animation,
            childAnimation.animationState
          );
        }
      }
      return;
    }
    if (this.registeredParentAttachment) {
      this.registeredParentAttachment.modelGraphics.unregisterAttachment(
        this.model
      );
      this.registeredParentAttachment = null;
    }
    const animSrc = this.model.contentSrcToContentAddress(anim);
    this.animLoadingInstanceManager.start(this.model.getLoadingProgressManager(), animSrc);
    const animModelHandle = this.model.getScene().getGraphicsAdapter().getResourceManager().loadModel(animSrc);
    this.latestAnimModelHandle = animModelHandle;
    animModelHandle.onProgress((loaded, total) => {
      if (this.latestAnimModelHandle !== animModelHandle) {
        return;
      }
      this.animLoadingInstanceManager.setProgress(loaded / total);
    });
    animModelHandle.onLoad((result) => {
      if (result instanceof Error) {
        console.error("Error loading m-model.anim", result);
        this.latestAnimModelHandle = null;
        this.animLoadingInstanceManager.error(result);
        return;
      }
      if (this.latestAnimModelHandle !== animModelHandle || !this.model.isConnected) {
        return;
      }
      const animationClip = result.animations[0];
      if (this.loadedState) {
        const filteredClip = createFilteredClip(animationClip, this.loadedState.nodeNames);
        this.playAnimation(filteredClip);
      } else {
        this.playAnimation(animationClip);
      }
      for (const [model] of this.attachments) {
        this.registerAttachment(model);
      }
      this.animLoadingInstanceManager.finish();
    });
  }
  setAnimEnabled() {
    var _a, _b, _c;
    if (this.model.props.animEnabled) {
      if (this.animState && !this.animState.appliedAnimation) {
        for (const [attachment] of this.attachments) {
          this.registerAttachment(attachment);
        }
        this.playAnimation(this.animState.currentAnimationClip);
      }
    } else if (!this.model.props.animEnabled) {
      for (const [attachment, attachmentAnimState] of this.attachments) {
        if (attachmentAnimState) {
          (_b = (_a = attachmentAnimState.directAnimation) == null ? void 0 : _a.animationMixer) == null ? void 0 : _b.stopAllAction();
          if ((_c = attachmentAnimState.directAnimation) == null ? void 0 : _c.animationMixer) {
            attachmentAnimState.directAnimation.animationMixer.update(0);
          }
          attachmentAnimState.childAnimations.animationMixer.stopAllAction();
          attachmentAnimState.childAnimations.animationMixer.update(0);
          attachmentAnimState.directAnimation = null;
        }
        this.model.getContainer().add(attachment.getContainer());
      }
    }
  }
  setAnimLoop() {
  }
  setAnimStartTime() {
  }
  setAnimPauseTime() {
  }
  transformed() {
  }
  setSrc(src) {
    var _a, _b;
    if (((_a = this.latestSrcModelHandle) == null ? void 0 : _a.url) === src) {
      return;
    }
    if (this.latestSrcModelHandle) {
      this.latestSrcModelHandle.dispose();
      this.srcLoadingInstanceManager.abortIfLoading();
    }
    this.latestSrcModelHandle = null;
    if (this.loadedState !== null) {
      this.loadedState.group.removeFromParent();
      if (this.registeredParentAttachment) {
        this.registeredParentAttachment.modelGraphics.unregisterAttachment(
          this.model
        );
        this.registeredParentAttachment = null;
      }
      _ThreeJSModel.disposeOfGroup(this.loadedState.group);
      this.loadedState = null;
      this.updateMeshCallback();
      this.updateDebugVisualisation();
    }
    if (this.childAnimationMixer) {
      this.childAnimationMixer.stopAllAction();
      this.childAnimationMixer = null;
    }
    for (const [, childAnimation] of this.childAnimations) {
      (_b = childAnimation.action) == null ? void 0 : _b.stop();
      childAnimation.action = null;
    }
    if (!src) {
      this.latestSrcModelHandle = null;
      this.srcLoadingInstanceManager.abortIfLoading();
      this.socketChildrenByBone.forEach((children) => {
        children.forEach((child) => {
          this.model.getContainer().add(child.getContainer());
        });
      });
      this.updateMeshCallback();
      this.updateDebugVisualisation();
      return;
    }
    const contentSrc = this.model.contentSrcToContentAddress(src);
    this.srcLoadingInstanceManager.start(this.model.getLoadingProgressManager(), contentSrc);
    const srcModelHandle = this.model.getScene().getGraphicsAdapter().getResourceManager().loadModel(contentSrc);
    this.latestSrcModelHandle = srcModelHandle;
    srcModelHandle.onProgress((loaded, total) => {
      if (this.latestSrcModelHandle !== srcModelHandle) {
        return;
      }
      this.srcLoadingInstanceManager.setProgress(loaded / total);
    });
    srcModelHandle.onLoad((result) => {
      if (result instanceof Error) {
        console.error("Error loading m-model.src", result);
        this.latestSrcModelHandle = null;
        this.srcLoadingInstanceManager.error(result);
        return;
      }
      result.group.traverse((child) => {
        if (child.isMesh) {
          child.castShadow = this.model.props.castShadows;
          child.receiveShadow = true;
        }
      });
      const group = result.group;
      const bones = /* @__PURE__ */ new Map();
      const nodeNames = /* @__PURE__ */ new Set();
      group.traverse((object) => {
        nodeNames.add(object.name);
        if (object instanceof THREE12.Bone) {
          bones.set(object.name, object);
        }
      });
      const boundingBox = new THREE12.Box3();
      group.updateWorldMatrix(true, true);
      boundingBox.expandByObject(group);
      this.loadedState = {
        group,
        bones,
        nodeNames,
        boundingBox: {
          size: boundingBox.getSize(new THREE12.Vector3(0, 0, 0)),
          centerOffset: boundingBox.getCenter(new THREE12.Vector3(0, 0, 0))
        }
      };
      this.model.getContainer().add(group);
      this.childAnimationMixer = new THREE12.AnimationMixer(group);
      if (!this.documentTimeTickListener) {
        this.documentTimeTickListener = this.model.addDocumentTimeTickListener(
          (documentTime) => {
            this.updateAnimation(documentTime);
          }
        );
      }
      for (const [boneName, children] of this.socketChildrenByBone) {
        const bone = bones.get(boneName);
        if (bone) {
          children.forEach((child) => {
            bone.add(child.getContainer());
          });
        }
      }
      this.updateMeshCallback();
      const parent = this.model.parentElement;
      if (parent && Model2.isModel(parent)) {
        if (!this.latestAnimModelHandle && !this.animState) {
          this.registeredParentAttachment = parent;
          parent.modelGraphics.registerAttachment(this.model);
        }
      }
      if (this.animState) {
        this.playAnimation(this.animState.currentAnimationClip);
      }
      this.srcLoadingInstanceManager.finish();
      this.updateDebugVisualisation();
      for (const [animation, childAnimation] of this.childAnimations) {
        this.updateChildAnimation(animation, childAnimation.animationState);
      }
    });
  }
  registerAttachment(attachment) {
    const childAnimationGroup = new THREE12.AnimationObjectGroup();
    const childAnimationMixer = new THREE12.AnimationMixer(childAnimationGroup);
    const animState = {
      directAnimation: null,
      childAnimations: {
        animationMixer: childAnimationMixer,
        animations: /* @__PURE__ */ new Map()
      }
    };
    for (const [animation, childAnimation] of this.childAnimations) {
      this.updateAnimationForAttachment(
        attachment,
        animState,
        animation,
        childAnimation.animationState
      );
    }
    if (this.animState) {
      const attachmentLoadedState = attachment.modelGraphics.loadedState;
      if (!attachmentLoadedState) {
        throw new Error("Attachment must be loaded before registering");
      }
      const animationGroup = new THREE12.AnimationObjectGroup();
      const animationMixer = new THREE12.AnimationMixer(animationGroup);
      const action = animationMixer.clipAction(this.animState.currentAnimationClip);
      animState.directAnimation = {
        animationMixer,
        animationAction: action
      };
      animationGroup.add(attachmentLoadedState.group);
      action.play();
    }
    this.attachments.set(attachment, animState);
  }
  unregisterAttachment(attachment) {
    var _a;
    const attachmentState = this.attachments.get(attachment);
    if (attachmentState) {
      if (attachmentState.directAnimation) {
        (_a = attachmentState.directAnimation.animationMixer) == null ? void 0 : _a.stopAllAction();
      }
      attachmentState.childAnimations.animationMixer.stopAllAction();
    }
    this.attachments.delete(attachment);
  }
  updateDebugVisualisation() {
    if (!this.model.props.debug) {
      this.clearDebugVisualisation();
    } else {
      if (!this.debugBoundingBox) {
        this.debugBoundingBox = new THREE12.Mesh(
          _ThreeJSModel.DebugBoundingBoxGeometry,
          _ThreeJSModel.DebugBoundingBoxMaterial
        );
        this.model.getContainer().add(this.debugBoundingBox);
      }
      if (this.loadedState) {
        const boundingBox = this.loadedState.boundingBox;
        if (boundingBox.centerOffset) {
          this.debugBoundingBox.position.copy(boundingBox.centerOffset);
        } else {
          this.debugBoundingBox.position.set(0, 0, 0);
        }
        this.debugBoundingBox.scale.copy(boundingBox.size);
      } else {
        this.debugBoundingBox.scale.set(0, 0, 0);
      }
    }
  }
  clearDebugVisualisation() {
    if (this.debugBoundingBox) {
      this.debugBoundingBox.removeFromParent();
      this.debugBoundingBox = null;
    }
  }
  resetAnimationMixer() {
    if (this.documentTimeTickListener) {
      this.documentTimeTickListener.remove();
      this.documentTimeTickListener = null;
    }
    if (this.animState) {
      const appliedAnimation = this.animState.appliedAnimation;
      if (appliedAnimation) {
        appliedAnimation.animationMixer.stopAllAction();
      }
      this.animState.appliedAnimation = null;
    }
  }
  registerSocketChild(child, socketName) {
    let children = this.socketChildrenByBone.get(socketName);
    if (!children) {
      children = /* @__PURE__ */ new Set();
      this.socketChildrenByBone.set(socketName, children);
    }
    children.add(child);
    if (this.loadedState) {
      const bone = this.loadedState.bones.get(socketName);
      if (bone) {
        bone.add(child.getContainer());
      } else {
        this.model.getContainer().add(child.getContainer());
      }
    }
  }
  unregisterSocketChild(child, socketName, addToRoot = true) {
    const socketChildren = this.socketChildrenByBone.get(socketName);
    if (socketChildren) {
      socketChildren.delete(child);
      if (addToRoot) {
        this.model.getContainer().add(child.getContainer());
      }
      if (socketChildren.size === 0) {
        this.socketChildrenByBone.delete(socketName);
      }
    }
  }
  triggerSocketedChildrenTransformed() {
    this.socketChildrenByBone.forEach((children) => {
      children.forEach((child) => {
        if (TransformableElement.isTransformableElement(child)) {
          child.didUpdateTransformation();
        }
      });
    });
  }
  playAnimation(anim) {
    this.resetAnimationMixer();
    this.animState = {
      currentAnimationClip: anim,
      appliedAnimation: null
    };
    const animationGroup = new THREE12.AnimationObjectGroup();
    const animationMixer = new THREE12.AnimationMixer(animationGroup);
    const action = animationMixer.clipAction(anim);
    this.animState.appliedAnimation = {
      animationGroup,
      animationMixer,
      animationAction: action
    };
    if (this.loadedState) {
      animationGroup.add(this.loadedState.group);
    }
    action.play();
    if (!this.documentTimeTickListener) {
      this.documentTimeTickListener = this.model.addDocumentTimeTickListener(
        (documentTime) => {
          this.updateAnimation(documentTime);
        }
      );
    }
  }
  updateAnimation(docTimeMs, force = false) {
    var _a, _b, _c, _d;
    if (this.animState) {
      if (!this.model.props.animEnabled && this.animState.appliedAnimation) {
        this.resetAnimationMixer();
        this.triggerSocketedChildrenTransformed();
      } else {
        if (!this.animState.appliedAnimation) {
          this.playAnimation(this.animState.currentAnimationClip);
        }
        let animationTimeMs = docTimeMs - this.model.props.animStartTime;
        if (docTimeMs < this.model.props.animStartTime) {
          animationTimeMs = 0;
        } else if (this.model.props.animPauseTime !== null) {
          if (docTimeMs > this.model.props.animPauseTime) {
            animationTimeMs = this.model.props.animPauseTime - this.model.props.animStartTime;
          }
        }
        const clip = this.animState.currentAnimationClip;
        if (clip !== null) {
          if (!this.model.props.animLoop) {
            if (animationTimeMs > clip.duration * 1e3) {
              animationTimeMs = clip.duration * 1e3;
            }
          }
        }
        for (const [model, attachmentAnimState] of this.attachments) {
          if (attachmentAnimState.directAnimation) {
            (_a = attachmentAnimState.directAnimation.animationMixer) == null ? void 0 : _a.setTime(animationTimeMs / 1e3);
            model.modelGraphics.triggerSocketedChildrenTransformed();
          }
        }
        if (force) {
          (_b = this.animState.appliedAnimation) == null ? void 0 : _b.animationMixer.setTime((animationTimeMs + 1) / 1e3);
        }
        (_c = this.animState.appliedAnimation) == null ? void 0 : _c.animationMixer.setTime(animationTimeMs / 1e3);
        this.triggerSocketedChildrenTransformed();
      }
    } else if (this.childAnimationMixer) {
      if (this.model.props.animEnabled) {
        const animationTimes = /* @__PURE__ */ new Map();
        let hasActiveAnimations = false;
        for (const [animation, childAnimation] of this.childAnimations) {
          const animationState = childAnimation.animationState;
          const action = childAnimation.action;
          if (animationState && action) {
            let shouldBeActive = true;
            let animationTimeMs = 0;
            if (docTimeMs < animationState.startTime) {
              shouldBeActive = false;
            } else {
              animationTimeMs = docTimeMs - animationState.startTime;
            }
            if (shouldBeActive && animationState.pauseTime !== null) {
              if (docTimeMs > animationState.pauseTime) {
                shouldBeActive = false;
              }
            }
            const durationMs = (((_d = animationState.animationClip) == null ? void 0 : _d.duration) ?? 1) * 1e3;
            animationTimeMs = animationTimeMs * animationState.speed;
            if (animationState.ratio !== null) {
              animationTimeMs = animationState.ratio * durationMs;
            }
            if (shouldBeActive && animationState.animationClip) {
              if (!animationState.loop) {
                if (animationTimeMs > durationMs) {
                  animationTimeMs = durationMs;
                  shouldBeActive = false;
                }
              }
            }
            if (shouldBeActive) {
              animationTimes.set(animation, animationTimeMs);
              action.enabled = true;
              action.setEffectiveWeight(animationState.weight);
              if (animationState.weight > 0) {
                hasActiveAnimations = true;
                action.play();
              } else {
                action.stop();
              }
              action.time = animationTimeMs % durationMs / 1e3;
            } else {
              action.enabled = false;
              action.stop();
            }
          }
        }
        if (!hasActiveAnimations) {
          this.childAnimationMixer.stopAllAction();
        }
        this.childAnimationMixer.update(0);
        for (const [, attachmentAnimState] of this.attachments) {
          for (const [animation, childAnimation] of attachmentAnimState.childAnimations.animations) {
            const animationTimeMs = animationTimes.get(animation);
            const action = childAnimation.action;
            if (action) {
              if (animationTimeMs !== void 0) {
                action.enabled = true;
                action.setEffectiveWeight(childAnimation.animationState.weight);
                if (childAnimation.animationState.weight > 0) {
                  action.play();
                } else {
                  action.stop();
                }
                action.time = animationTimeMs / 1e3;
              } else {
                action.enabled = false;
                action.stop();
              }
            }
          }
          if (!hasActiveAnimations) {
            attachmentAnimState.childAnimations.animationMixer.stopAllAction();
          }
          attachmentAnimState.childAnimations.animationMixer.update(1e-9);
        }
        this.triggerSocketedChildrenTransformed();
      } else {
        this.childAnimationMixer.stopAllAction();
      }
    }
  }
  dispose() {
    var _a, _b;
    if (this.documentTimeTickListener) {
      this.documentTimeTickListener.remove();
      this.documentTimeTickListener = null;
    }
    if (this.registeredParentAttachment) {
      (_b = (_a = this.registeredParentAttachment) == null ? void 0 : _a.modelGraphics) == null ? void 0 : _b.unregisterAttachment(
        this.model
      );
      this.registeredParentAttachment = null;
    }
    if (this.loadedState) {
      this.loadedState.group.removeFromParent();
      _ThreeJSModel.disposeOfGroup(this.loadedState.group);
      this.loadedState = null;
    }
    this.clearDebugVisualisation();
    if (this.latestSrcModelHandle) {
      this.latestSrcModelHandle.dispose();
    }
    this.latestSrcModelHandle = null;
    if (this.latestAnimModelHandle) {
      this.latestAnimModelHandle.dispose();
    }
    this.latestAnimModelHandle = null;
    this.animLoadingInstanceManager.dispose();
    this.srcLoadingInstanceManager.dispose();
    if (this.childAnimationMixer) {
      this.childAnimationMixer.stopAllAction();
      this.childAnimationMixer = null;
    }
    this.childAnimations.clear();
  }
  static disposeOfGroup(group) {
    group.traverse((child) => {
      if (child.isMesh) {
        const mesh = child;
        mesh.geometry.dispose();
        if (Array.isArray(mesh.material)) {
          for (const material of mesh.material) {
            _ThreeJSModel.disposeOfMaterial(material);
          }
        } else if (mesh.material) {
          _ThreeJSModel.disposeOfMaterial(mesh.material);
        }
      }
    });
  }
  static disposeOfMaterial(material) {
    material.dispose();
    for (const key of Object.keys(material)) {
      const value = material[key];
      if (value && typeof value === "object" && "minFilter" in value) {
        value.dispose();
      }
    }
  }
};
_ThreeJSModel.DebugBoundingBoxGeometry = new THREE12.BoxGeometry(1, 1, 1, 1, 1, 1);
_ThreeJSModel.DebugBoundingBoxMaterial = new THREE12.MeshBasicMaterial({
  color: 16711680,
  wireframe: true,
  transparent: true,
  opacity: 0.3
});
var ThreeJSModel = _ThreeJSModel;

// src/elements/ThreeJSOverlay.ts
import { OverlayGraphics } from "@mml-io/mml-web";
var ThreeJSOverlay = class extends OverlayGraphics {
  constructor(overlay) {
    super(overlay);
    this.overlay = overlay;
  }
  disable() {
  }
  enable() {
  }
  setAnchor() {
  }
  setOffsetX() {
  }
  setOffsetY() {
  }
  dispose() {
  }
};

// src/elements/ThreeJSPlane.ts
import { PlaneGraphics } from "@mml-io/mml-web";
import * as THREE13 from "three";
var _ThreeJSPlane = class _ThreeJSPlane extends PlaneGraphics {
  constructor(plane) {
    super(plane);
    this.plane = plane;
    this.material = new THREE13.MeshStandardMaterial({
      color: new THREE13.Color(plane.props.color.r, plane.props.color.g, plane.props.color.b)
    });
    this.mesh = new THREE13.Mesh(_ThreeJSPlane.planeGeometry, this.material);
    this.mesh.castShadow = plane.props.castShadows;
    this.mesh.receiveShadow = true;
    this.plane.getContainer().add(this.mesh);
  }
  disable() {
  }
  enable() {
  }
  getCollisionElement() {
    return this.mesh;
  }
  setColor(color) {
    this.material.color = new THREE13.Color(color.r, color.g, color.b);
  }
  setWidth(width) {
    this.mesh.scale.x = width;
  }
  setHeight(height) {
    this.mesh.scale.y = height;
  }
  setCastShadows(castShadows) {
    this.mesh.castShadow = castShadows;
  }
  setOpacity(opacity) {
    const needsUpdate = this.material.transparent === (opacity === 1);
    this.material.transparent = opacity !== 1;
    this.material.needsUpdate = needsUpdate;
    this.material.opacity = opacity;
  }
  dispose() {
  }
};
_ThreeJSPlane.planeGeometry = new THREE13.PlaneGeometry(1, 1);
var ThreeJSPlane = _ThreeJSPlane;

// src/elements/ThreeJSPositionProbe.ts
import { PositionProbeGraphics } from "@mml-io/mml-web";
import * as THREE14 from "three";
var _ThreeJSPositionProbe = class _ThreeJSPositionProbe extends PositionProbeGraphics {
  constructor(positionProbe) {
    super(positionProbe);
    this.positionProbe = positionProbe;
    this.debugMesh = null;
  }
  disable() {
  }
  enable() {
  }
  setRange() {
    this.updateDebugVisualisation();
  }
  setDebug() {
    this.updateDebugVisualisation();
  }
  clearDebugVisualisation() {
    if (this.debugMesh) {
      this.debugMesh.removeFromParent();
      this.debugMesh = null;
    }
  }
  updateDebugVisualisation() {
    if (!this.positionProbe.props.debug) {
      this.clearDebugVisualisation();
    } else {
      if (this.positionProbe.isConnected && !this.debugMesh) {
        const mesh = new THREE14.Mesh(
          _ThreeJSPositionProbe.DebugGeometry,
          _ThreeJSPositionProbe.DebugMaterial
        );
        mesh.castShadow = false;
        mesh.receiveShadow = false;
        this.debugMesh = mesh;
        this.positionProbe.getContainer().add(this.debugMesh);
      }
      if (this.debugMesh) {
        this.debugMesh.scale.set(
          this.positionProbe.props.range,
          this.positionProbe.props.range,
          this.positionProbe.props.range
        );
      }
    }
  }
  dispose() {
    this.clearDebugVisualisation();
  }
};
_ThreeJSPositionProbe.DebugGeometry = new THREE14.SphereGeometry(1, 16, 16, 1);
_ThreeJSPositionProbe.DebugMaterial = new THREE14.MeshBasicMaterial({
  color: 16711680,
  wireframe: true,
  transparent: true,
  opacity: 0.3
});
var ThreeJSPositionProbe = _ThreeJSPositionProbe;

// src/elements/ThreeJSPrompt.ts
import { PromptGraphics } from "@mml-io/mml-web";
var ThreeJSPrompt = class extends PromptGraphics {
  constructor(prompt) {
    super(prompt);
    this.prompt = prompt;
  }
  disable() {
  }
  enable() {
  }
  setMessage() {
  }
  setPlaceholder() {
  }
  setPrefill() {
  }
  setDebug() {
  }
  dispose() {
  }
};

// src/elements/ThreeJSRemoteDocument.ts
import { RemoteDocumentGraphics } from "@mml-io/mml-web";
import * as THREE16 from "three";

// src/ThreeJSReconnectingStatus.ts
import { CanvasText } from "@mml-io/mml-web";
import * as THREE15 from "three";
function createReconnectingStatus() {
  const canvas = new CanvasText().renderText("Reconnecting", {
    bold: true,
    fontSize: 32,
    paddingPx: 10,
    textColorRGB255A1: {
      r: 255,
      g: 0,
      b: 0,
      a: 1
    },
    backgroundColorRGB255A1: {
      r: 255,
      g: 255,
      b: 255,
      a: 1
    },
    alignment: "center"
  });
  const texture = new THREE15.Texture(canvas);
  texture.minFilter = THREE15.LinearFilter;
  texture.magFilter = THREE15.LinearFilter;
  texture.format = THREE15.RGBAFormat;
  texture.needsUpdate = true;
  const width = canvas.width;
  const height = canvas.height;
  const material = new THREE15.MeshBasicMaterial({
    map: texture,
    side: THREE15.DoubleSide
  });
  const geometry = new THREE15.PlaneGeometry(width / 100, height / 100, 1, 1);
  return { geometry, material, width: width / 100, height: height / 100 };
}
var reconnectingStatus = null;
function getThreeJSReconnectingStatus() {
  if (!reconnectingStatus) {
    reconnectingStatus = createReconnectingStatus();
  }
  return reconnectingStatus;
}

// src/elements/ThreeJSRemoteDocument.ts
var ThreeJSRemoteDocument = class extends RemoteDocumentGraphics {
  constructor(element) {
    super(element);
    this.element = element;
    this.statusUI = null;
  }
  showError(showError) {
    if (!showError) {
      if (this.statusUI !== null) {
        this.element.getContainer().remove(this.statusUI);
        this.statusUI = null;
      }
    } else {
      if (this.statusUI === null) {
        const { geometry, material, height } = getThreeJSReconnectingStatus();
        const mesh = new THREE16.Mesh(
          geometry,
          material
        );
        mesh.position.set(0, height / 2, 0);
        this.statusUI = mesh;
        this.element.getContainer().add(this.statusUI);
      }
    }
  }
  dispose() {
  }
};

// src/elements/ThreeJSSphere.ts
import { SphereGraphics } from "@mml-io/mml-web";
import * as THREE17 from "three";
var defaultSphereWidthSegments = 16;
var defaultSphereHeightSegments = 16;
var _ThreeJSSphere = class _ThreeJSSphere extends SphereGraphics {
  constructor(sphere) {
    super(sphere);
    this.sphere = sphere;
    this.material = new THREE17.MeshStandardMaterial({
      color: new THREE17.Color(sphere.props.color.r, sphere.props.color.g, sphere.props.color.b)
    });
    this.mesh = new THREE17.Mesh(_ThreeJSSphere.sphereGeometry, this.material);
    this.mesh.castShadow = sphere.props.castShadows;
    this.mesh.receiveShadow = true;
    this.sphere.getContainer().add(this.mesh);
  }
  disable() {
  }
  enable() {
  }
  getCollisionElement() {
    return this.mesh;
  }
  setColor(color) {
    this.material.color = new THREE17.Color(color.r, color.g, color.b);
  }
  setRadius(radius) {
    this.mesh.scale.x = radius * 2;
    this.mesh.scale.y = radius * 2;
    this.mesh.scale.z = radius * 2;
  }
  setCastShadows(castShadows) {
    this.mesh.castShadow = castShadows;
  }
  setOpacity(opacity) {
    const needsUpdate = this.material.transparent === (opacity === 1);
    this.material.transparent = opacity !== 1;
    this.material.needsUpdate = needsUpdate;
    this.material.opacity = opacity;
  }
  dispose() {
  }
};
_ThreeJSSphere.sphereGeometry = new THREE17.SphereGeometry(
  0.5,
  defaultSphereWidthSegments,
  defaultSphereHeightSegments
);
var ThreeJSSphere = _ThreeJSSphere;

// src/elements/ThreeJSTransformable.ts
import {
  Matr4,
  TransformableGraphics
} from "@mml-io/mml-web";
import * as THREE18 from "three";
var ThreeJSTransformable = class extends TransformableGraphics {
  constructor(transformableElement) {
    super(transformableElement);
    this.transformableElement = transformableElement;
    this.socketName = null;
    this.registeredSocketParent = null;
  }
  getWorldMatrix() {
    const container = this.getContainer();
    container.updateWorldMatrix(true, false);
    return new Matr4(container.matrixWorld.elements);
  }
  getWorldPosition() {
    return this.getContainer().getWorldPosition(new THREE18.Vector3());
  }
  getLocalPosition() {
    return this.getContainer().position;
  }
  getVisible() {
    return this.getContainer().visible;
  }
  setVisible(visible) {
    this.getContainer().visible = visible;
  }
  setSocket(socketName) {
    if (this.socketName !== socketName) {
      if (this.socketName !== null && this.registeredSocketParent) {
        this.registeredSocketParent.unregisterSocketChild(
          this.transformableElement,
          this.socketName
        );
      }
      this.socketName = socketName;
      if (socketName !== null) {
        this.registerWithParentModel(socketName);
      }
    } else {
      this.socketName = socketName;
    }
  }
  registerWithParentModel(socketName) {
    var _a;
    if ((_a = this.transformableElement.parentElement) == null ? void 0 : _a.isModel) {
      const parentModel = this.transformableElement.parentElement;
      this.registeredSocketParent = parentModel.modelGraphics;
      this.registeredSocketParent.registerSocketChild(this.transformableElement, socketName);
    }
  }
  getContainer() {
    return this.transformableElement.getContainer();
  }
  setX(x) {
    this.getContainer().position.x = x;
  }
  setY(y) {
    this.getContainer().position.y = y;
  }
  setZ(z) {
    this.getContainer().position.z = z;
  }
  setRotationX(rotationX) {
    this.getContainer().rotation.x = rotationX * THREE18.MathUtils.DEG2RAD;
  }
  setRotationY(rotationY) {
    this.getContainer().rotation.y = rotationY * THREE18.MathUtils.DEG2RAD;
  }
  setRotationZ(rotationZ) {
    this.getContainer().rotation.z = rotationZ * THREE18.MathUtils.DEG2RAD;
  }
  setScaleX(scaleX) {
    this.getContainer().scale.x = scaleX;
  }
  setScaleY(scaleY) {
    this.getContainer().scale.y = scaleY;
  }
  setScaleZ(scaleZ) {
    this.getContainer().scale.z = scaleZ;
  }
  dispose() {
    if (this.socketName && this.registeredSocketParent !== null) {
      this.registeredSocketParent.unregisterSocketChild(
        this.transformableElement,
        this.socketName,
        false
      );
    }
  }
};

// src/elements/ThreeJSVideo.ts
import {
  calculateContentSize as calculateContentSize2,
  StaticFileVideoSource,
  VideoGraphics,
  WHEPVideoSource
} from "@mml-io/mml-web";
import * as THREE19 from "three";
var audioRefDistance2 = 1;
var audioRolloffFactor2 = 1;
var disabledVideoMaterial = new THREE19.MeshStandardMaterial({
  color: 0,
  side: THREE19.DoubleSide
});
var ThreeJSVideo = class extends VideoGraphics {
  constructor(video, updateMeshCallback) {
    super(video, updateMeshCallback);
    this.video = video;
    this.updateMeshCallback = updateMeshCallback;
    this.videoSource = null;
    this.loadedVideoState = null;
    const geometry = new THREE19.PlaneGeometry(1, 1, 1, 1);
    this.videoMaterial = new THREE19.MeshStandardMaterial({
      color: 16777215,
      transparent: false,
      side: THREE19.DoubleSide
    });
    this.mesh = new THREE19.Mesh(geometry, disabledVideoMaterial);
    this.mesh.castShadow = true;
    this.mesh.receiveShadow = false;
    this.video.getContainer().add(this.mesh);
  }
  getWidthAndHeight() {
    return {
      width: this.mesh.scale.x,
      height: this.mesh.scale.y
    };
  }
  syncVideoTime() {
    if (this.loadedVideoState) {
      const videoTag = this.loadedVideoState.video;
      if (videoTag.readyState === 0) {
        return;
      }
      const audioListener = this.getAudioListener();
      const audioContext = audioListener.context;
      if (audioContext.state === "running") {
        videoTag.muted = false;
      }
      if (this.video.isDisabled()) {
        videoTag.muted = true;
      }
      if (this.videoSource) {
        this.videoSource.syncVideoSource(this.video.props);
      }
    }
  }
  getAudioListener() {
    return this.video.getScene().getGraphicsAdapter().getAudioListener();
  }
  enable() {
    this.updateVideo();
  }
  disable() {
    this.updateVideo();
  }
  getCollisionElement() {
    return this.mesh;
  }
  setSrc() {
    this.updateVideo();
  }
  setWidth() {
    this.updateWidthAndHeight();
  }
  setHeight() {
    this.updateWidthAndHeight();
  }
  setEnabled() {
    this.updateVideo();
  }
  setCastShadows() {
    this.updateVideo();
  }
  setLoop() {
    this.updateVideo();
  }
  setVolume() {
    if (this.loadedVideoState) {
      this.loadedVideoState.audio.setVolume(this.video.props.volume);
    }
  }
  setEmissive() {
    this.updateVideo();
    this.updateMaterialEmissiveIntensity();
  }
  setStartTime() {
    this.updateVideo();
  }
  setPauseTime() {
    this.updateVideo();
  }
  updateVideo() {
    if (!this.video.isConnected) {
      return;
    }
    if (!this.video.props.enabled) {
      this.clearSource();
      return;
    }
    if (!this.video.props.src) {
      this.clearSource();
    } else {
      const contentAddress = this.video.contentSrcToContentAddress(this.video.props.src);
      if (this.videoSource === null || this.videoSource.getContentAddress() !== contentAddress) {
        this.clearSource();
        const video = document.createElement("video");
        video.playsInline = true;
        video.muted = true;
        video.autoplay = true;
        video.crossOrigin = "anonymous";
        const audioListener = this.getAudioListener();
        const audioContext = audioListener.context;
        const audio = new THREE19.PositionalAudio(audioListener);
        audio.setMediaElementSource(video);
        audio.setVolume(this.video.props.volume);
        audio.setRefDistance(audioRefDistance2);
        audio.setRolloffFactor(audioRolloffFactor2);
        this.loadedVideoState = {
          video,
          audio,
          videoTexture: null
        };
        this.updateMaterialEmissiveIntensity();
        this.video.getContainer().add(audio);
        const url = new URL(contentAddress);
        if (WHEPVideoSource.isWHEPURL(url)) {
          this.videoSource = new WHEPVideoSource(url, video);
        } else {
          this.videoSource = new StaticFileVideoSource(url, video, this.video.props, () => {
            return this.video.getDocumentTime();
          });
        }
        audioContext.addEventListener("statechange", () => {
          this.syncVideoTime();
        });
        video.addEventListener("loadeddata", () => {
          if (!this.loadedVideoState || this.loadedVideoState.video !== video) {
            return;
          }
          const videoTexture = new THREE19.VideoTexture(video);
          this.videoMaterial.map = videoTexture;
          this.videoMaterial.needsUpdate = true;
          this.mesh.material = this.videoMaterial;
          this.loadedVideoState.videoTexture = videoTexture;
          this.syncVideoTime();
          this.updateWidthAndHeight();
          this.updateMaterialEmissiveIntensity();
        });
      }
    }
    if (this.videoSource) {
      this.syncVideoTime();
    }
  }
  clearSource() {
    if (this.videoSource) {
      this.videoSource.dispose();
      this.videoSource = null;
    }
    if (this.loadedVideoState) {
      const tag = this.loadedVideoState.video;
      tag.pause();
      tag.src = "";
      tag.load();
      this.loadedVideoState = null;
      this.mesh.material = disabledVideoMaterial;
      this.updateWidthAndHeight();
    }
  }
  dispose() {
    this.clearSource();
    if (this.loadedVideoState) {
      this.loadedVideoState = null;
    }
  }
  updateMaterialEmissiveIntensity() {
    if (this.loadedVideoState && this.loadedVideoState.videoTexture) {
      if (this.video.props.emissive > 0) {
        this.videoMaterial.emissive = new THREE19.Color(16777215);
        this.videoMaterial.emissiveMap = this.loadedVideoState.videoTexture;
        this.videoMaterial.emissiveIntensity = this.video.props.emissive;
        this.videoMaterial.needsUpdate = true;
      } else {
        this.videoMaterial.emissive = new THREE19.Color(0);
        this.videoMaterial.emissiveMap = null;
        this.videoMaterial.emissiveIntensity = 1;
        this.videoMaterial.needsUpdate = true;
      }
    }
  }
  updateWidthAndHeight() {
    const mesh = this.mesh;
    const { width, height } = calculateContentSize2({
      content: this.loadedVideoState ? {
        width: this.loadedVideoState.video.videoWidth,
        height: this.loadedVideoState.video.videoHeight
      } : void 0,
      width: this.video.props.width,
      height: this.video.props.height
    });
    mesh.scale.x = width;
    mesh.scale.y = height;
    this.updateMeshCallback();
  }
};

// src/resources/ThreeJSImageHandle.ts
var ThreeJSImageHandleImpl = class {
  constructor(imageResource) {
    this.imageResource = imageResource;
    this.onLoadCallbacks = /* @__PURE__ */ new Set();
    this.onProgressCallbacks = /* @__PURE__ */ new Set();
    this.result = null;
    this.url = imageResource.url;
  }
  onProgress(onProgress) {
    this.onProgressCallbacks.add(onProgress);
  }
  onLoad(onLoad) {
    this.onLoadCallbacks.add(onLoad);
    if (this.result) {
      onLoad(this.result);
    }
  }
  getResult() {
    return this.result;
  }
  handleProgress(loaded, total) {
    for (const onProgressCallback of this.onProgressCallbacks) {
      onProgressCallback(loaded, total);
    }
  }
  handleLoaded(result) {
    this.result = result;
    for (const onLoadCallback of this.onLoadCallbacks) {
      onLoadCallback(result);
    }
  }
  handleError(error) {
    this.result = error;
    for (const onLoadCallback of this.onLoadCallbacks) {
      onLoadCallback(error);
    }
  }
  dispose() {
    this.imageResource.disposeHandle(this);
  }
};

// src/resources/ThreeJSImageResource.ts
import * as THREE20 from "three";

// src/resources/ThreeJSImageLoader.ts
var ThreeJSImageLoader = class {
  static load(url, onLoad, onError, abortSignal) {
    const image = document.createElement("img");
    image.crossOrigin = "anonymous";
    function onImageLoad() {
      removeEventListeners();
      onLoad(this);
    }
    function onImageError(event) {
      removeEventListeners();
      onError(event);
    }
    function removeEventListeners() {
      image.removeEventListener("load", onImageLoad, false);
      image.removeEventListener("error", onImageError, false);
    }
    abortSignal.addEventListener("abort", () => {
      removeEventListeners();
      image.src = "";
    });
    image.addEventListener("load", onImageLoad, false);
    image.addEventListener("error", onImageError, false);
    image.src = url;
    return image;
  }
};

// src/resources/ThreeJSImageResource.ts
var ThreeJSImageResource = class {
  constructor(url, onRemove) {
    this.url = url;
    this.onRemove = onRemove;
    this.imageHandles = /* @__PURE__ */ new Set();
    this.imageElement = null;
    this.texture = null;
    this.hasTransparency = false;
    this.abortController = null;
    this.abortController = new AbortController();
    ThreeJSImageLoader.load(
      url,
      (image) => {
        this.imageElement = image;
        this.hasTransparency = hasTransparency2(image);
        this.texture = new THREE20.CanvasTexture(
          image
        );
        const result = {
          texture: this.texture,
          width: image.width,
          height: image.height,
          hasTransparency: this.hasTransparency
        };
        for (const imageHandle of this.imageHandles) {
          imageHandle.handleLoaded(result);
        }
        this.abortController = null;
      },
      (error) => {
        const errorObj = new Error(`Failed to load image: ${error.message}`);
        for (const imageHandle of this.imageHandles) {
          imageHandle.handleError(errorObj);
        }
        this.abortController = null;
      },
      this.abortController.signal
    );
  }
  getResult() {
    if (this.texture && this.imageElement) {
      return {
        texture: this.texture,
        width: this.imageElement.width,
        height: this.imageElement.height,
        hasTransparency: this.hasTransparency
      };
    }
    return null;
  }
  createHandle() {
    const imageHandle = new ThreeJSImageHandleImpl(this);
    this.imageHandles.add(imageHandle);
    const result = this.getResult();
    if (result !== null) {
      imageHandle.handleLoaded(result);
    }
    return imageHandle;
  }
  disposeHandle(imageHandle) {
    var _a;
    this.imageHandles.delete(imageHandle);
    if (this.imageHandles.size === 0) {
      (_a = this.abortController) == null ? void 0 : _a.abort();
      this.abortController = null;
      if (this.texture) {
        this.texture.dispose();
        this.texture = null;
      }
      this.imageElement = null;
      this.onRemove();
    }
  }
};
function hasTransparency2(image) {
  if (image.width === 0 || image.height === 0) {
    return false;
  }
  const canvas = document.createElement("canvas");
  canvas.width = image.width;
  canvas.height = image.height;
  const ctx = canvas.getContext("2d");
  ctx.drawImage(image, 0, 0);
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
  for (let i = 3, n = imageData.length; i < n; i += 4) {
    if (imageData[i] < 255) {
      return true;
    }
  }
  return false;
}

// src/resources/ThreeJSLabelHandle.ts
var ThreeJSLabelHandleImpl = class {
  constructor(labelResource) {
    this.labelResource = labelResource;
    this.onLoadCallbacks = /* @__PURE__ */ new Set();
    this.result = null;
  }
  onLoad(onLoad) {
    this.onLoadCallbacks.add(onLoad);
    if (this.result) {
      onLoad(this.result);
    }
  }
  getResult() {
    return this.result;
  }
  handleLoaded(result) {
    this.result = result;
    for (const onLoadCallback of this.onLoadCallbacks) {
      onLoadCallback(result);
    }
  }
  handleError(error) {
    this.result = error;
    for (const onLoadCallback of this.onLoadCallbacks) {
      onLoadCallback(error);
    }
  }
  dispose() {
    this.labelResource.disposeHandle(this);
  }
};

// src/resources/ThreeJSLabelResource.ts
import { CanvasText as CanvasText2 } from "@mml-io/mml-web";
import * as THREE21 from "three";
var _ThreeJSLabelResource = class _ThreeJSLabelResource {
  constructor(options, onRemove, maxTextureSize = _ThreeJSLabelResource.DEFAULT_MAX_TEXTURE_SIZE) {
    this.onRemove = onRemove;
    this.maxTextureSize = maxTextureSize;
    this.handles = /* @__PURE__ */ new Set();
    this.result = null;
    if (!_ThreeJSLabelResource.sharedCanvasText) {
      _ThreeJSLabelResource.sharedCanvasText = new CanvasText2();
    }
    const scale = Math.min(
      1,
      Math.min(
        this.maxTextureSize / options.dimensions.width,
        this.maxTextureSize / options.dimensions.height
      )
    );
    const clampedDimensions = {
      width: options.dimensions.width * scale,
      height: options.dimensions.height * scale
    };
    const canvasText = _ThreeJSLabelResource.sharedCanvasText;
    const canvas = canvasText.renderText(options.content, {
      bold: options.bold,
      fontSize: options.fontSize * scale,
      paddingPx: options.paddingPx * scale,
      textColorRGB255A1: options.textColorRGB255A1,
      backgroundColorRGB255A1: options.backgroundColorRGB255A1,
      dimensions: clampedDimensions,
      alignment: options.alignment
    });
    let texture;
    if (canvas.width === 0 || canvas.height === 0) {
      const emptyPixel = new Uint8Array([0, 0, 0, 0]);
      texture = new THREE21.DataTexture(emptyPixel, 1, 1, THREE21.RGBAFormat);
    } else {
      const ctx = canvas.getContext("2d");
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      texture = new THREE21.DataTexture(
        imageData.data,
        canvas.width,
        canvas.height,
        THREE21.RGBAFormat
      );
    }
    texture.flipY = true;
    texture.colorSpace = THREE21.NoColorSpace;
    texture.premultiplyAlpha = true;
    texture.magFilter = THREE21.LinearFilter;
    texture.minFilter = THREE21.LinearMipmapLinearFilter;
    texture.generateMipmaps = true;
    texture.needsUpdate = true;
    this.result = {
      texture,
      width: canvas.width,
      height: canvas.height
    };
  }
  getResult() {
    return this.result;
  }
  createHandle() {
    const handle = new ThreeJSLabelHandleImpl({
      disposeHandle: this.disposeHandle.bind(this)
    });
    this.handles.add(handle);
    if (this.result) {
      handle.handleLoaded(this.result);
    }
    return handle;
  }
  disposeHandle(handle) {
    this.handles.delete(handle);
    if (this.handles.size === 0) {
      if (this.result && this.result.texture) {
        this.result.texture.dispose();
      }
      this.result = null;
      this.onRemove();
    }
  }
};
_ThreeJSLabelResource.DEFAULT_MAX_TEXTURE_SIZE = 1024;
_ThreeJSLabelResource.sharedCanvasText = null;
var ThreeJSLabelResource = _ThreeJSLabelResource;

// src/resources/ThreeJSModelHandle.ts
import * as SkeletonUtils from "three/examples/jsm/utils/SkeletonUtils.js";
var ThreeJSModelHandleImpl = class {
  constructor(modelResource) {
    this.modelResource = modelResource;
    this.onLoadCallbacks = /* @__PURE__ */ new Set();
    this.onProgressCallbacks = /* @__PURE__ */ new Set();
    this.result = null;
    this.url = modelResource.url;
  }
  onProgress(onProgress) {
    this.onProgressCallbacks.add(onProgress);
  }
  onLoad(onLoad) {
    this.onLoadCallbacks.add(onLoad);
    if (this.result) {
      onLoad(this.result);
    }
  }
  getResult() {
    return this.result;
  }
  handleProgress(loaded, total) {
    for (const onProgressCallback of this.onProgressCallbacks) {
      onProgressCallback(loaded, total);
    }
  }
  handleLoaded(result) {
    const clonedGroup = SkeletonUtils.clone(result.group);
    this.result = {
      group: clonedGroup,
      animations: result.animations
    };
    for (const onLoadCallback of this.onLoadCallbacks) {
      onLoadCallback(this.result);
    }
  }
  handleError(error) {
    this.result = error;
    for (const onLoadCallback of this.onLoadCallbacks) {
      onLoadCallback(error);
    }
  }
  dispose() {
    this.modelResource.disposeHandle(this);
  }
};

// src/resources/ThreeJSModelResource.ts
import { ModelLoader } from "@mml-io/model-loader";
var _ThreeJSModelResource = class _ThreeJSModelResource {
  constructor(url, onRemove, maxTextureSize = _ThreeJSModelResource.DEFAULT_MAX_TEXTURE_SIZE) {
    this.url = url;
    this.onRemove = onRemove;
    this.maxTextureSize = maxTextureSize;
    this.modelHandles = /* @__PURE__ */ new Set();
    this.modelResult = null;
    this.abortController = null;
    this.abortController = new AbortController();
    _ThreeJSModelResource.getModelLoader().load(
      url,
      (loaded, total) => {
        for (const modelHandle of this.modelHandles) {
          modelHandle.handleProgress(loaded, total);
        }
      },
      this.abortController
    ).then((result) => {
      this.modelResult = result;
      try {
        _ThreeJSModelResource.clampTexturesToMaxSize(result.group, this.maxTextureSize);
      } catch (e) {
        console.warn("Texture clamping failed", e);
      }
      for (const modelHandle of this.modelHandles) {
        modelHandle.handleLoaded(result);
      }
    }).finally(() => {
      this.abortController = null;
    });
  }
  static getModelLoader() {
    if (!_ThreeJSModelResource.modelLoader) {
      _ThreeJSModelResource.modelLoader = new ModelLoader();
    }
    return _ThreeJSModelResource.modelLoader;
  }
  getResult() {
    return this.modelResult;
  }
  createHandle() {
    const modelHandle = new ThreeJSModelHandleImpl(this);
    this.modelHandles.add(modelHandle);
    if (this.modelResult !== null) {
      modelHandle.handleLoaded(this.modelResult);
    }
    return modelHandle;
  }
  disposeHandle(modelHandle) {
    var _a;
    this.modelHandles.delete(modelHandle);
    if (this.modelHandles.size === 0) {
      (_a = this.abortController) == null ? void 0 : _a.abort();
      this.abortController = null;
      this.onRemove();
    }
  }
  static clampTexturesToMaxSize(root, maxSize) {
    const processedTextures = /* @__PURE__ */ new Set();
    root.traverse((object) => {
      const maybeMesh = object;
      if (maybeMesh.isMesh) {
        const material = maybeMesh.material;
        if (!material) {
          return;
        }
        if (Array.isArray(material)) {
          for (const mat of material) {
            _ThreeJSModelResource.processMaterialTextures(mat, maxSize, processedTextures);
          }
        } else {
          _ThreeJSModelResource.processMaterialTextures(material, maxSize, processedTextures);
        }
      }
    });
  }
  static processMaterialTextures(material, maxSize, processed) {
    const materialAny = material;
    for (const key of Object.keys(materialAny)) {
      const value = materialAny[key];
      if (value && typeof value === "object" && value.isTexture) {
        const texture = value;
        if (processed.has(texture)) {
          continue;
        }
        processed.add(texture);
        _ThreeJSModelResource.resizeTextureIfTooLarge(texture, maxSize);
      }
    }
  }
  static resizeTextureIfTooLarge(texture, maxSize) {
    var _a;
    const texAny = texture;
    if (texAny.isCompressedTexture || texAny.isCubeTexture || texAny.isVideoTexture) {
      return;
    }
    const image = texAny.image ?? ((_a = texAny.source) == null ? void 0 : _a.data);
    if (!image || typeof image.width !== "number" || typeof image.height !== "number") {
      return;
    }
    const width = image.width;
    const height = image.height;
    if (width <= maxSize && height <= maxSize) {
      return;
    }
    console.warn(
      "Texture resizing is being performed. Original size: ",
      width,
      height,
      "Maximum size: ",
      maxSize
    );
    const scale = Math.min(maxSize / width, maxSize / height);
    const newWidth = Math.max(1, Math.floor(width * scale));
    const newHeight = Math.max(1, Math.floor(height * scale));
    const canvas = document.createElement("canvas");
    canvas.width = newWidth;
    canvas.height = newHeight;
    const ctx = canvas.getContext("2d");
    if (!ctx) {
      return;
    }
    try {
      ctx.drawImage(image, 0, 0, newWidth, newHeight);
      if (texAny.source && texAny.source.data !== void 0) {
        texAny.source.data = canvas;
      }
      texture.image = canvas;
      texture.needsUpdate = true;
    } catch {
    }
  }
};
_ThreeJSModelResource.DEFAULT_MAX_TEXTURE_SIZE = 2048;
_ThreeJSModelResource.modelLoader = null;
var ThreeJSModelResource = _ThreeJSModelResource;

// src/resources/ThreeJSResourceManager.ts
var ThreeJSResourceManager = class {
  constructor(options = {}) {
    this.options = options;
    this.modelResources = /* @__PURE__ */ new Map();
    this.imageResources = /* @__PURE__ */ new Map();
    this.labelResources = /* @__PURE__ */ new Map();
  }
  loadModel(url) {
    let modelResource = this.modelResources.get(url);
    if (!modelResource) {
      modelResource = new ThreeJSModelResource(
        url,
        () => {
          this.modelResources.delete(url);
        },
        this.options.modelMaxTextureSize
      );
      this.modelResources.set(url, modelResource);
    }
    return modelResource.createHandle();
  }
  loadImage(url) {
    let imageResource = this.imageResources.get(url);
    if (!imageResource) {
      imageResource = new ThreeJSImageResource(url, () => {
        this.imageResources.delete(url);
      });
      this.imageResources.set(url, imageResource);
    }
    return imageResource.createHandle();
  }
  loadLabel(options) {
    const key = buildLabelResourceKey(options);
    let labelResource = this.labelResources.get(key);
    if (!labelResource) {
      labelResource = new ThreeJSLabelResource(
        options,
        () => {
          this.labelResources.delete(key);
        },
        this.options.labelMaxTextureSize
      );
      this.labelResources.set(key, labelResource);
    }
    return labelResource.createHandle();
  }
};
function buildLabelResourceKey(options) {
  const key = {
    content: options.content,
    fontSize: options.fontSize * 2,
    paddingPx: options.paddingPx,
    textColorRGB255A1: {
      r: Math.round(options.textColorRGB255A1.r * 255),
      g: Math.round(options.textColorRGB255A1.g * 255),
      b: Math.round(options.textColorRGB255A1.b * 255),
      a: options.textColorRGB255A1.a ?? 1
    },
    backgroundColorRGB255A1: {
      r: Math.round(options.backgroundColorRGB255A1.r * 255),
      g: Math.round(options.backgroundColorRGB255A1.g * 255),
      b: Math.round(options.backgroundColorRGB255A1.b * 255),
      a: options.backgroundColorRGB255A1.a ?? 1
    },
    dimensions: {
      width: options.dimensions.width * 200,
      height: options.dimensions.height * 200
    },
    alignment: options.alignment,
    bold: true
  };
  return JSON.stringify(key);
}

// src/ThreeJSClickTrigger.ts
import {
  EventHandlerCollection,
  getRelativePositionAndRotationRelativeToObject,
  MElement as MElement3
} from "@mml-io/mml-web";
import * as THREE22 from "three";
var mouseMovePixelsThreshold = 10;
var mouseMoveTimeThresholdMilliseconds = 500;
var ThreeJSClickTrigger = class _ThreeJSClickTrigger {
  constructor(clickTarget, rootContainer, camera) {
    this.clickTarget = clickTarget;
    this.rootContainer = rootContainer;
    this.camera = camera;
    this.eventHandlerCollection = new EventHandlerCollection();
    this.mouseDownTime = null;
    this.mouseMoveDelta = 0;
    this.raycaster = new THREE22.Raycaster();
    this.eventHandlerCollection.add(clickTarget, "mousedown", this.handleMouseDown.bind(this));
    this.eventHandlerCollection.add(clickTarget, "mouseup", this.handleMouseUp.bind(this));
    this.eventHandlerCollection.add(clickTarget, "mousemove", this.handleMouseMove.bind(this));
  }
  static init(clickTarget, rootContainer, camera) {
    return new _ThreeJSClickTrigger(clickTarget, rootContainer, camera);
  }
  handleMouseDown() {
    this.mouseDownTime = Date.now();
    this.mouseMoveDelta = 0;
  }
  handleMouseUp(event) {
    if (!this.mouseDownTime) {
      return;
    }
    const duration = Date.now() - this.mouseDownTime;
    this.mouseDownTime = null;
    if (this.mouseMoveDelta < mouseMovePixelsThreshold && duration < mouseMoveTimeThresholdMilliseconds) {
      this.handleClick(event);
    }
  }
  handleMouseMove(event) {
    if (this.mouseDownTime) {
      this.mouseMoveDelta += Math.abs(event.movementX) + Math.abs(event.movementY);
    }
  }
  handleClick(event) {
    if (event.detail.element) {
      return;
    }
    let x = 0;
    let y = 0;
    if (!document.pointerLockElement) {
      let width = window.innerWidth;
      let height = window.innerHeight;
      if (this.clickTarget instanceof HTMLElement) {
        width = this.clickTarget.offsetWidth;
        height = this.clickTarget.offsetHeight;
      }
      x = event.offsetX / width * 2 - 1;
      y = -(event.offsetY / height * 2 - 1);
    }
    this.raycaster.setFromCamera(new THREE22.Vector2(x, y), this.camera);
    const intersections = this.raycaster.intersectObject(this.rootContainer, true);
    if (intersections.length > 0) {
      for (const intersection of intersections) {
        let obj = intersection.object;
        currentIntersection: while (obj) {
          if (this.isMaterialIgnored(obj)) {
            break currentIntersection;
          }
          const mElement = MElement3.getMElementFromObject(obj);
          if (!mElement) {
            obj = obj.parent;
            continue currentIntersection;
          }
          if (!mElement.isClickable()) {
            break currentIntersection;
          }
          const elementRelative = getRelativePositionAndRotationRelativeToObject(
            {
              position: intersection.point,
              rotation: {
                x: 0,
                y: 0,
                z: 0
              }
            },
            mElement
          );
          mElement.dispatchEvent(
            new CustomEvent("click", {
              bubbles: true,
              detail: {
                position: {
                  ...elementRelative.position
                }
              }
            })
          );
          return;
        }
      }
    }
  }
  dispose() {
    this.eventHandlerCollection.clear();
  }
  isMaterialIgnored(obj) {
    const mesh = obj;
    if (mesh) {
      if (mesh.material && mesh.material.wireframe || mesh.material && mesh.material.wireframe || mesh.material && mesh.material.wireframe || mesh.material && mesh.material.wireframe || mesh.material && mesh.material.isLineBasicMaterial) {
        return true;
      }
    }
    return false;
  }
};

// src/ThreeJSGraphicsInterface.ts
var ThreeJSGraphicsInterface = {
  MElementGraphicsInterface: (element) => new ThreeJSMElement(element),
  MMLDebugHelperGraphicsInterface: (debugHelper) => new ThreeJSDebugHelper(debugHelper),
  MMLAudioGraphicsInterface: (element) => new ThreeJSAudio(element),
  MMLChatProbeGraphicsInterface: (element) => new ThreeJSChatProbe(element),
  MMLCubeGraphicsInterface: (element) => new ThreeJSCube(element),
  MMLCylinderGraphicsInterface: (element) => new ThreeJSCylinder(element),
  MMLFrameGraphicsInterface: (element) => new ThreeJSFrame(element),
  MMLImageGraphicsInterface: (element, updateMeshCallback) => new ThreeJSImage(element, updateMeshCallback),
  MMLInteractionGraphicsInterface: (element) => new ThreeJSInteraction(element),
  MMLLabelGraphicsInterface: (element) => new ThreeJSLabel(element),
  MMLLightGraphicsInterface: (element) => new ThreeJSLight(element),
  MMLOverlayGraphicsInterface: (element) => new ThreeJSOverlay(element),
  MMLLinkGraphicsInterface: (element) => new ThreeJSLink(element),
  MMLModelGraphicsInterface: (element, updateMeshCallback) => new ThreeJSModel(element, updateMeshCallback),
  MMLPlaneGraphicsInterface: (element) => new ThreeJSPlane(element),
  MMLPositionProbeGraphicsInterface: (element) => new ThreeJSPositionProbe(element),
  MMLPromptGraphicsInterface: (element) => new ThreeJSPrompt(element),
  MMLSphereGraphicsInterface: (element) => new ThreeJSSphere(element),
  MMLTransformableGraphicsInterface: (element) => new ThreeJSTransformable(element),
  MMLVideoGraphicsInterface: (element, updateMeshCallback) => new ThreeJSVideo(element, updateMeshCallback),
  MMLAnimationGraphicsInterface: (element) => new ThreeJSAnimation(element),
  RemoteDocumentGraphicsInterface: (element) => new ThreeJSRemoteDocument(element)
};

// src/ThreeJSInteractionAdapter.ts
import * as THREE23 from "three";
var _ThreeJSInteractionAdapter = class _ThreeJSInteractionAdapter {
  static interactionShouldShowDistance(interaction, camera, scene) {
    const worldPos = interaction.getContainer().getWorldPosition(_ThreeJSInteractionAdapter.worldPos);
    const cameraPos = camera.position;
    const distance = cameraPos.distanceTo(worldPos);
    if (distance > interaction.props.range) {
      return null;
    }
    if (interaction.props.inFocus) {
      _ThreeJSInteractionAdapter.matrix.multiplyMatrices(
        camera.projectionMatrix,
        camera.matrixWorldInverse
      );
      _ThreeJSInteractionAdapter.frustum.setFromProjectionMatrix(_ThreeJSInteractionAdapter.matrix);
      if (!_ThreeJSInteractionAdapter.frustum.containsPoint(worldPos)) {
        return null;
      }
    }
    if (interaction.props.lineOfSight) {
      const raycastResults = _ThreeJSInteractionAdapter.getRaycastResults(
        cameraPos,
        worldPos,
        distance,
        scene
      );
      if (raycastResults.length > 0) {
        for (const result of raycastResults) {
          if (!_ThreeJSInteractionAdapter.hasAncestor(result.object, interaction.getContainer())) {
            return null;
          }
        }
      }
    }
    return distance;
  }
  static getRaycastResults(a, b, distance, scene) {
    _ThreeJSInteractionAdapter.direction.copy(b);
    _ThreeJSInteractionAdapter.direction.sub(a);
    _ThreeJSInteractionAdapter.direction.normalize();
    _ThreeJSInteractionAdapter.raycaster.set(a, _ThreeJSInteractionAdapter.direction);
    _ThreeJSInteractionAdapter.raycaster.near = 0;
    _ThreeJSInteractionAdapter.raycaster.far = distance;
    _ThreeJSInteractionAdapter.intersections.length = 0;
    _ThreeJSInteractionAdapter.raycaster.intersectObject(
      scene,
      true,
      _ThreeJSInteractionAdapter.intersections
    );
    return _ThreeJSInteractionAdapter.intersections;
  }
  static hasAncestor(object, ancestor) {
    let parent = object.parent;
    while (parent !== null) {
      if (parent === ancestor) {
        return true;
      }
      parent = parent.parent;
    }
    return false;
  }
};
_ThreeJSInteractionAdapter.worldPos = new THREE23.Vector3();
_ThreeJSInteractionAdapter.matrix = new THREE23.Matrix4();
_ThreeJSInteractionAdapter.frustum = new THREE23.Frustum();
_ThreeJSInteractionAdapter.raycaster = new THREE23.Raycaster();
_ThreeJSInteractionAdapter.intersections = new Array();
_ThreeJSInteractionAdapter.direction = new THREE23.Vector3();
var ThreeJSInteractionAdapter = _ThreeJSInteractionAdapter;

// src/ThreeJSMemoryInspector.ts
import * as THREE24 from "three";
var ThreeJSMemoryInspector = class _ThreeJSMemoryInspector {
  /**
   * Opens a new window with a comprehensive memory report including thumbnails
   */
  static openMemoryReport(scene) {
    const reportWindow = window.open(
      "",
      "_blank",
      "width=1200,height=800,scrollbars=yes,resizable=yes"
    );
    if (!reportWindow) {
      console.error("Failed to open memory report window. Please check popup blockers.");
      return;
    }
    const { geometries, textures, materials, stats } = _ThreeJSMemoryInspector.analyzeScene(scene);
    const textureThumbnails = _ThreeJSMemoryInspector.generateTextureThumbnails(scene);
    const geometryPreviews = _ThreeJSMemoryInspector.generateGeometryPreviews(scene);
    _ThreeJSMemoryInspector.buildReportUI(
      reportWindow.document,
      geometries,
      textures,
      materials,
      stats,
      textureThumbnails,
      geometryPreviews
    );
  }
  static analyzeScene(scene) {
    const geometries = /* @__PURE__ */ new Map();
    const textures = /* @__PURE__ */ new Map();
    const materials = /* @__PURE__ */ new Map();
    scene.traverse((object) => {
      const asMesh = object;
      if (asMesh.isMesh) {
        const objectPath = _ThreeJSMemoryInspector.getObjectPath(asMesh, scene);
        const objectName = _ThreeJSMemoryInspector.getObjectDisplayName(asMesh);
        if (asMesh.geometry) {
          const geometry = asMesh.geometry;
          if (!geometries.has(geometry.uuid)) {
            geometries.set(
              geometry.uuid,
              _ThreeJSMemoryInspector.analyzeGeometry(geometry, objectName, objectPath, asMesh.uuid)
            );
          } else {
            const geometryInfo = geometries.get(geometry.uuid);
            if (!geometryInfo.usedByObjectInstanceIds.includes(asMesh.uuid)) {
              geometryInfo.usedByObjectInstanceIds.push(asMesh.uuid);
              geometryInfo.usedByObjects.push(objectName);
              geometryInfo.objectPaths.push(objectPath);
            }
          }
        }
        const materialsArray = Array.isArray(asMesh.material) ? asMesh.material : [asMesh.material];
        materialsArray.forEach((material) => {
          if (material) {
            if (!materials.has(material.uuid)) {
              const materialInfo = _ThreeJSMemoryInspector.analyzeMaterial(
                material,
                objectName,
                objectPath,
                asMesh.uuid
              );
              materials.set(material.uuid, materialInfo);
              materialInfo.textures.forEach((textureInfo) => {
                if (!textures.has(textureInfo.uuid)) {
                  textures.set(textureInfo.uuid, textureInfo);
                } else {
                  const existingTexture = textures.get(textureInfo.uuid);
                  if (!existingTexture.usedByMaterials.includes(
                    material.name || material.uuid.substring(0, 8)
                  )) {
                    existingTexture.usedByMaterials.push(
                      material.name || material.uuid.substring(0, 8)
                    );
                  }
                  if (!existingTexture.usedByObjectInstanceIds.includes(asMesh.uuid)) {
                    existingTexture.usedByObjectInstanceIds.push(asMesh.uuid);
                    existingTexture.usedByObjects.push(objectName);
                    existingTexture.usedByObjectPaths.push(objectPath);
                  }
                }
              });
            } else {
              const materialInfo = materials.get(material.uuid);
              if (!materialInfo.usedByObjects.includes(objectName)) {
                materialInfo.usedByObjects.push(objectName);
              }
              const materialName = material.name || material.uuid.substring(0, 8);
              const textureProperties = [
                "map",
                "normalMap",
                "roughnessMap",
                "metalnessMap",
                "aoMap",
                "emissiveMap",
                "bumpMap",
                "displacementMap",
                "alphaMap",
                "lightMap",
                "envMap"
              ];
              textureProperties.forEach((prop) => {
                const texture = material[prop];
                if (texture && texture.isTexture) {
                  if (!textures.has(texture.uuid)) {
                    textures.set(
                      texture.uuid,
                      _ThreeJSMemoryInspector.analyzeTexture(
                        texture,
                        materialName,
                        objectName,
                        objectPath,
                        asMesh.uuid
                      )
                    );
                  } else {
                    const existingTexture = textures.get(texture.uuid);
                    if (!existingTexture.usedByMaterials.includes(materialName)) {
                      existingTexture.usedByMaterials.push(materialName);
                    }
                    if (!existingTexture.usedByObjectInstanceIds.includes(asMesh.uuid)) {
                      existingTexture.usedByObjectInstanceIds.push(asMesh.uuid);
                      existingTexture.usedByObjects.push(objectName);
                      existingTexture.usedByObjectPaths.push(objectPath);
                    }
                  }
                }
              });
            }
          }
        });
      }
    });
    const totalGeometryMemory = Array.from(geometries.values()).reduce(
      (sum, geo) => sum + geo.memoryBytes,
      0
    );
    const totalTextureMemory = Array.from(textures.values()).reduce(
      (sum, tex) => sum + tex.memoryBytes,
      0
    );
    const totalMemory = totalGeometryMemory + totalTextureMemory;
    const stats = {
      geometryCount: geometries.size,
      textureCount: textures.size,
      materialCount: materials.size,
      totalGeometryMemory,
      totalTextureMemory,
      totalMemory
    };
    return { geometries, textures, materials, stats };
  }
  static analyzeGeometry(geometry, objectName, objectPath, objectInstanceId) {
    let memoryBytes = 0;
    let vertexCount = 0;
    let triangleCount = 0;
    for (const name in geometry.attributes) {
      const attribute = geometry.attributes[name];
      memoryBytes += attribute.count * attribute.itemSize * attribute.array.BYTES_PER_ELEMENT;
    }
    if (geometry.index) {
      memoryBytes += geometry.index.count * geometry.index.array.BYTES_PER_ELEMENT;
      triangleCount = geometry.index.count / 3;
    }
    if (geometry.attributes.position) {
      vertexCount = geometry.attributes.position.count;
      if (!geometry.index) {
        triangleCount = vertexCount / 3;
      }
    }
    return {
      name: geometry.name || `Geometry_${geometry.uuid.substring(0, 8)}`,
      uuid: geometry.uuid,
      memoryBytes,
      vertexCount,
      triangleCount,
      usedByObjects: [objectName],
      objectPaths: [objectPath],
      usedByObjectInstanceIds: [objectInstanceId]
    };
  }
  static analyzeMaterial(material, objectName, objectPath, objectInstanceId) {
    const textures = [];
    let textureCount = 0;
    const textureProperties = [
      "map",
      "normalMap",
      "roughnessMap",
      "metalnessMap",
      "aoMap",
      "emissiveMap",
      "bumpMap",
      "displacementMap",
      "alphaMap",
      "lightMap",
      "envMap"
    ];
    textureProperties.forEach((prop) => {
      const texture = material[prop];
      if (texture && texture.isTexture) {
        textures.push(
          _ThreeJSMemoryInspector.analyzeTexture(
            texture,
            material.name || material.uuid.substring(0, 8),
            objectName,
            objectPath,
            objectInstanceId
          )
        );
        textureCount++;
      }
    });
    return {
      name: material.name || `Material_${material.uuid.substring(0, 8)}`,
      uuid: material.uuid,
      textureCount,
      textures,
      usedByObjects: [objectName]
    };
  }
  static analyzeTexture(texture, materialName, objectName, objectPath, objectInstanceId) {
    let memoryBytes = 0;
    let width = 0;
    let height = 0;
    let format = "Unknown";
    const textureAny = texture;
    if (textureAny.isCompressedTexture) {
      const result = _ThreeJSMemoryInspector.calculateCompressedTextureMemory(texture);
      memoryBytes = result.memoryBytes;
      width = result.width;
      height = result.height;
      format = result.format;
    } else if (textureAny.isDataTexture && texture.image) {
      const dataImage = texture.image;
      width = dataImage.width || 0;
      height = dataImage.height || 0;
      if (dataImage.data && dataImage.data.byteLength) {
        memoryBytes = dataImage.data.byteLength;
        if (texture.generateMipmaps) {
          memoryBytes *= 1.333;
        }
      } else {
        memoryBytes = width * height * 4;
        if (texture.generateMipmaps) {
          memoryBytes *= 1.333;
        }
      }
      if (texture.format) {
        format = _ThreeJSMemoryInspector.getTextureFormatName(texture.format);
      }
    } else if (texture.image) {
      const imageSource = texture.image;
      width = imageSource.width || 0;
      height = imageSource.height || 0;
      memoryBytes = width * height * 4 * 1.333;
      if (texture.format) {
        format = _ThreeJSMemoryInspector.getTextureFormatName(texture.format);
      }
    }
    let url;
    let sourceType = "Unknown";
    if (textureAny.isCompressedTexture) {
      sourceType = "Compressed Texture (KTX2)";
      url = `${width}x${height} - ${format}`;
    } else if (textureAny.isDataTexture) {
      sourceType = "DataTexture (Label/Generated)";
      url = `${width}x${height} - ${format}`;
    } else if (texture.source && texture.source.data) {
      const sourceData = texture.source.data;
      const sourceDataWithSrc = sourceData;
      if (sourceDataWithSrc.src) {
        url = sourceDataWithSrc.src;
        if (url && url.startsWith("data:")) {
          sourceType = "Data URL";
          url = `${url.substring(0, 50)}...`;
        } else if (url && url.startsWith("blob:")) {
          sourceType = "Blob URL";
        } else {
          sourceType = "File URL";
        }
      } else if (sourceData instanceof HTMLCanvasElement) {
        sourceType = "Canvas";
        url = `Canvas(${sourceData.width}x${sourceData.height})`;
      } else if (sourceData instanceof ImageData) {
        sourceType = "ImageData";
        url = `ImageData(${sourceData.width}x${sourceData.height})`;
      } else if (sourceData instanceof HTMLVideoElement) {
        sourceType = "Video";
        url = sourceData.src || "Video Element";
      } else if (sourceData.constructor.name === "ImageBitmap") {
        sourceType = "ImageBitmap";
        url = `ImageBitmap(${sourceData.width}x${sourceData.height})`;
      } else if (typeof sourceData === "object" && sourceData !== null && "data" in sourceData && "width" in sourceData && "height" in sourceData) {
        const dataSource = sourceData;
        sourceType = "DataTexture (Raw Data)";
        url = `${dataSource.width}x${dataSource.height}`;
      }
    } else if (texture.image) {
      const image = texture.image;
      if (image && image.src) {
        url = image.src;
        if (url && url.startsWith("data:")) {
          sourceType = "Data URL";
          url = `${url.substring(0, 50)}...`;
        } else if (url && url.startsWith("blob:")) {
          sourceType = "Blob URL";
        } else {
          sourceType = "File URL";
        }
      } else if (image instanceof HTMLCanvasElement) {
        sourceType = "Canvas";
        url = `Canvas(${image.width}x${image.height})`;
      } else if (image && image.data && image.width && image.height) {
        sourceType = "DataTexture (Raw Data)";
        url = `${image.width}x${image.height}`;
      }
    }
    return {
      name: texture.name || `Texture_${texture.uuid.substring(0, 8)}`,
      uuid: texture.uuid,
      memoryBytes,
      width,
      height,
      format,
      usedByMaterials: [materialName],
      usedByObjects: [objectName],
      usedByObjectPaths: [objectPath || objectName],
      usedByObjectInstanceIds: [objectInstanceId || "unknown"],
      url,
      sourceType
    };
  }
  static getTextureFormatName(format) {
    const formatNames = {
      1023: "RGBA",
      1022: "RGB",
      1024: "RGBAInteger",
      1025: "RGBInteger",
      1026: "DepthComponent",
      1027: "DepthStencil",
      1028: "LuminanceAlpha",
      1029: "Luminance",
      1030: "Alpha",
      1031: "Red",
      1032: "RedInteger",
      1033: "RG",
      1034: "RGInteger",
      // Compressed formats
      33776: "RGB_S3TC_DXT1",
      33777: "RGBA_S3TC_DXT1",
      33778: "RGBA_S3TC_DXT3",
      33779: "RGBA_S3TC_DXT5",
      35840: "RGB_PVRTC_4BPPV1",
      35841: "RGB_PVRTC_2BPPV1",
      35842: "RGBA_PVRTC_4BPPV1",
      35843: "RGBA_PVRTC_2BPPV1",
      36196: "RGB_ETC1",
      37808: "RGBA_ASTC_4x4",
      37809: "RGBA_ASTC_5x4",
      37810: "RGBA_ASTC_5x5",
      37811: "RGBA_ASTC_6x5",
      37812: "RGBA_ASTC_6x6",
      37813: "RGBA_ASTC_8x5",
      37814: "RGBA_ASTC_8x6",
      37815: "RGBA_ASTC_8x8",
      37816: "RGBA_ASTC_10x5",
      37817: "RGBA_ASTC_10x6",
      37818: "RGBA_ASTC_10x8",
      37819: "RGBA_ASTC_10x10",
      37820: "RGBA_ASTC_12x10",
      37821: "RGBA_ASTC_12x12",
      37492: "RGBA_BPTC_UNORM",
      36492: "RGB_ETC2",
      36494: "RGBA_ETC2_EAC"
    };
    return formatNames[format] || `Format_${format}`;
  }
  static calculateCompressedTextureMemory(texture) {
    const textureAny = texture;
    let totalMemory = 0;
    let width = 0;
    let height = 0;
    let format = "Unknown Compressed";
    if (texture.format) {
      format = _ThreeJSMemoryInspector.getTextureFormatName(texture.format);
    }
    if (textureAny.mipmaps && Array.isArray(textureAny.mipmaps)) {
      for (const mipmap of textureAny.mipmaps) {
        if (mipmap.data && mipmap.data.byteLength) {
          totalMemory += mipmap.data.byteLength;
          if (width === 0) {
            width = mipmap.width || 0;
            height = mipmap.height || 0;
          }
        }
      }
    }
    if (width === 0 && textureAny.image) {
      width = textureAny.image.width || 0;
      height = textureAny.image.height || 0;
    }
    return {
      memoryBytes: totalMemory,
      width,
      height,
      format
    };
  }
  static getObjectPath(object, scene) {
    const path = [];
    let current = object;
    while (current && current !== scene) {
      const name = current.name || current.constructor.name || "Object";
      path.unshift(name);
      current = current.parent;
    }
    return path.join(" > ");
  }
  static getObjectDisplayName(object) {
    var _a;
    if (object.name) {
      return object.name;
    }
    let current = object.parent;
    while (current && current !== ((_a = object.parent) == null ? void 0 : _a.parent)) {
      if (current.name) {
        return `${current.name} > ${object.constructor.name}`;
      }
      current = current.parent;
    }
    return `${object.constructor.name}_${object.uuid.substring(0, 8)}`;
  }
  static generateTextureThumbnails(scene) {
    const thumbnails = /* @__PURE__ */ new Map();
    const textureMap = /* @__PURE__ */ new Map();
    scene.traverse((object) => {
      const asMesh = object;
      if (asMesh.isMesh) {
        const materialsArray = Array.isArray(asMesh.material) ? asMesh.material : [asMesh.material];
        materialsArray.forEach((material) => {
          if (material) {
            const textureProperties = [
              "map",
              "normalMap",
              "roughnessMap",
              "metalnessMap",
              "aoMap",
              "emissiveMap",
              "bumpMap",
              "displacementMap",
              "alphaMap",
              "lightMap",
              "envMap"
            ];
            textureProperties.forEach((prop) => {
              const texture = material[prop];
              if (texture && texture.isTexture && !textureMap.has(texture.uuid)) {
                textureMap.set(texture.uuid, texture);
              }
            });
          }
        });
      }
    });
    textureMap.forEach((texture, uuid) => {
      try {
        const thumbnail = _ThreeJSMemoryInspector.createTextureThumbnail(texture);
        if (thumbnail) {
          thumbnails.set(uuid, thumbnail);
        }
      } catch (error) {
        console.warn(`Failed to generate thumbnail for texture ${uuid}:`, error);
      }
    });
    return thumbnails;
  }
  static generateGeometryPreviews(scene) {
    const previews = /* @__PURE__ */ new Map();
    const geometryMap = /* @__PURE__ */ new Map();
    scene.traverse((object) => {
      const asMesh = object;
      if (asMesh.isMesh && asMesh.geometry) {
        const geometry = asMesh.geometry;
        if (!geometryMap.has(geometry.uuid)) {
          geometryMap.set(geometry.uuid, geometry);
        }
      }
    });
    let sharedRenderer = null;
    try {
      sharedRenderer = new THREE24.WebGLRenderer({ antialias: true, alpha: true });
      sharedRenderer.setSize(200, 200);
      sharedRenderer.setClearColor(2236962, 0);
      geometryMap.forEach((geometry, uuid) => {
        try {
          const preview = _ThreeJSMemoryInspector.createGeometryPreview(geometry, sharedRenderer);
          if (preview) {
            previews.set(uuid, preview);
          }
        } catch (error) {
          console.warn(`Failed to generate preview for geometry ${uuid}:`, error);
        }
      });
    } catch (error) {
      console.warn("Failed to initialize shared WebGLRenderer for geometry previews:", error);
    } finally {
      if (sharedRenderer) {
        sharedRenderer.dispose();
      }
    }
    return previews;
  }
  static createTextureThumbnail(texture) {
    try {
      const textureAny = texture;
      if (textureAny.isCompressedTexture) {
        return _ThreeJSMemoryInspector.createCompressedTextureThumbnail(texture);
      }
      if (textureAny.isDataTexture) {
        return _ThreeJSMemoryInspector.createCompressedTextureThumbnail(texture);
      }
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      if (!ctx) {
        return null;
      }
      let sourceElement = null;
      if (texture.source && texture.source.data) {
        sourceElement = texture.source.data;
      } else if (texture.image) {
        sourceElement = texture.image;
      }
      if (!sourceElement) {
        return null;
      }
      const maxSize = 200;
      let width = 0;
      let height = 0;
      if (sourceElement instanceof HTMLCanvasElement) {
        width = sourceElement.width;
        height = sourceElement.height;
      } else if (sourceElement instanceof ImageData) {
        width = sourceElement.width;
        height = sourceElement.height;
      } else if (sourceElement instanceof HTMLVideoElement) {
        width = sourceElement.videoWidth || sourceElement.width;
        height = sourceElement.videoHeight || sourceElement.height;
      } else if (sourceElement.constructor.name === "ImageBitmap") {
        width = sourceElement.width;
        height = sourceElement.height;
      } else if (sourceElement instanceof HTMLImageElement) {
        width = sourceElement.naturalWidth || sourceElement.width;
        height = sourceElement.naturalHeight || sourceElement.height;
      }
      if (width === 0 || height === 0) {
        return null;
      }
      const scale = Math.min(maxSize / width, maxSize / height);
      canvas.width = Math.floor(width * scale);
      canvas.height = Math.floor(height * scale);
      if (sourceElement instanceof ImageData) {
        const tempCanvas = document.createElement("canvas");
        const tempCtx = tempCanvas.getContext("2d");
        if (tempCtx) {
          tempCanvas.width = sourceElement.width;
          tempCanvas.height = sourceElement.height;
          tempCtx.putImageData(sourceElement, 0, 0);
          ctx.drawImage(tempCanvas, 0, 0, canvas.width, canvas.height);
        }
      } else if (sourceElement instanceof HTMLCanvasElement || sourceElement instanceof HTMLImageElement || sourceElement instanceof HTMLVideoElement || sourceElement.constructor.name === "ImageBitmap") {
        ctx.drawImage(sourceElement, 0, 0, canvas.width, canvas.height);
      } else {
        return null;
      }
      return canvas.toDataURL("image/png");
    } catch (error) {
      console.warn("Error creating texture thumbnail:", error);
      return null;
    }
  }
  static createCompressedTextureThumbnail(texture) {
    let renderer = null;
    try {
      const textureAny = texture;
      let width = 0;
      let height = 0;
      if (textureAny.mipmaps && textureAny.mipmaps.length > 0) {
        width = textureAny.mipmaps[0].width || 0;
        height = textureAny.mipmaps[0].height || 0;
      }
      if (width === 0 || height === 0 && textureAny.image) {
        width = textureAny.image.width || 0;
        height = textureAny.image.height || 0;
      }
      if (width === 0 || height === 0) {
        return null;
      }
      const maxSize = 200;
      const scale = Math.min(maxSize / width, maxSize / height);
      const thumbWidth = Math.floor(width * scale);
      const thumbHeight = Math.floor(height * scale);
      renderer = new THREE24.WebGLRenderer({ antialias: false, alpha: true });
      renderer.setSize(thumbWidth, thumbHeight);
      renderer.setClearColor(0, 0);
      const scene = new THREE24.Scene();
      const camera = new THREE24.OrthographicCamera(-0.5, 0.5, 0.5, -0.5, 0, 1);
      camera.position.z = 0.5;
      const geometry = new THREE24.PlaneGeometry(1, 1);
      const material = new THREE24.MeshBasicMaterial({
        map: texture,
        side: THREE24.DoubleSide,
        transparent: true
      });
      const plane = new THREE24.Mesh(geometry, material);
      scene.add(plane);
      renderer.render(scene, camera);
      const canvas = renderer.domElement;
      const dataURL = canvas.toDataURL("image/png");
      geometry.dispose();
      material.dispose();
      return dataURL;
    } catch (error) {
      console.warn("Error creating compressed texture thumbnail:", error);
      return null;
    } finally {
      if (renderer) {
        renderer.dispose();
      }
    }
  }
  static createGeometryPreview(geometry, renderer) {
    try {
      const tempScene = new THREE24.Scene();
      const tempCamera = new THREE24.PerspectiveCamera(50, 1, 0.1, 1e3);
      renderer.setSize(200, 200);
      renderer.setClearColor(2236962, 0);
      const material = new THREE24.MeshStandardMaterial({
        color: 15658734,
        roughness: 0.9,
        metalness: 0,
        side: THREE24.DoubleSide,
        polygonOffset: true,
        polygonOffsetFactor: 1,
        polygonOffsetUnits: 1
      });
      const mesh = new THREE24.Mesh(geometry, material);
      const wireGeom = new THREE24.WireframeGeometry(geometry);
      const wireMaterial = new THREE24.LineBasicMaterial({ color: 16777215 });
      const wireframe = new THREE24.LineSegments(wireGeom, wireMaterial);
      wireframe.renderOrder = 1;
      geometry.computeBoundingSphere();
      let radius = 0;
      let center = new THREE24.Vector3();
      if (geometry.boundingSphere) {
        radius = geometry.boundingSphere.radius;
        center.copy(geometry.boundingSphere.center);
      } else {
        geometry.computeBoundingBox();
        const box = geometry.boundingBox;
        if (!box) {
          return null;
        }
        center = new THREE24.Vector3();
        box.getCenter(center);
        const size = new THREE24.Vector3();
        box.getSize(size);
        radius = Math.max(size.x, size.y, size.z) * 0.5;
      }
      mesh.position.sub(center);
      wireframe.position.copy(mesh.position);
      const fovRad = tempCamera.fov * Math.PI / 180;
      let distance = radius / Math.sin(fovRad / 2);
      distance *= 1.05;
      const dir = new THREE24.Vector3(1, 1, 1).normalize();
      tempCamera.position.copy(dir.multiplyScalar(distance));
      tempCamera.lookAt(0, 0, 0);
      const ambientLight = new THREE24.AmbientLight(4210752, 0.6);
      const directionalLight = new THREE24.DirectionalLight(16777215, 0.8);
      directionalLight.position.set(1, 1, 1);
      tempScene.add(mesh);
      tempScene.add(wireframe);
      tempScene.add(ambientLight);
      tempScene.add(directionalLight);
      renderer.render(tempScene, tempCamera);
      const canvas = renderer.domElement;
      const dataURL = canvas.toDataURL("image/png");
      material.dispose();
      wireMaterial.dispose();
      wireGeom.dispose();
      return dataURL;
    } catch (error) {
      console.warn("Error creating geometry preview:", error);
      return null;
    }
  }
  static buildReportUI(doc, geometries, textures, materials, stats, textureThumbnails, geometryPreviews) {
    doc.title = "Three.js Memory Report";
    const style = doc.createElement("style");
    style.textContent = _ThreeJSMemoryInspector.getReportStyles();
    doc.head.appendChild(style);
    doc.body.innerHTML = "";
    const container = doc.createElement("div");
    container.className = "container";
    const statsGrid = _ThreeJSMemoryInspector.createStatsGrid(doc, stats);
    container.appendChild(statsGrid);
    const section = doc.createElement("div");
    section.className = "section";
    const controls = _ThreeJSMemoryInspector.createControls(doc, stats);
    section.appendChild(controls);
    const sectionContent = doc.createElement("div");
    sectionContent.className = "section-content";
    const resultsInfo = doc.createElement("div");
    resultsInfo.className = "results-info";
    resultsInfo.id = "resultsInfo";
    sectionContent.appendChild(resultsInfo);
    const itemList = doc.createElement("div");
    itemList.className = "item-list";
    itemList.id = "itemList";
    sectionContent.appendChild(itemList);
    section.appendChild(sectionContent);
    container.appendChild(section);
    doc.body.appendChild(container);
    _ThreeJSMemoryInspector.initializeReportInteractivity(
      doc,
      geometries,
      textures,
      textureThumbnails,
      geometryPreviews
    );
  }
  static getReportStyles() {
    return `
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }

        .stat-card {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid #444;
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #4CAF50;
            margin-bottom: 5px;
        }

        .stat-label {
            color: #aaa;
            font-size: 0.9em;
        }

        .section {
            background: #2a2a2a;
            border-radius: 8px;
            margin-bottom: 30px;
            overflow: hidden;
            border: 1px solid #444;
        }

        .section-content {
            padding: 20px;
        }

        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
            padding: 16px 20px;
            background: #333;
            border-bottom: 1px solid #444;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 16px;
            flex-wrap: wrap;
        }
        .checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            background: #2a2a2a;
            padding: 6px 10px;
            border: 1px solid #555;
            border-radius: 6px;
        }
        .filter-bar {
            display: flex;
            align-items: center;
            gap: 12px;
            color: #ccc;
        }
        .clear-btn {
            background: transparent;
            border: 1px solid #666;
            color: #ccc;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
        }
        .clear-btn:hover { border-color: #888; color: #fff; }

        .item-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .item-row {
            display: flex;
            gap: 12px;
            align-items: center;
            background: #333;
            border: 1px solid #555;
            border-radius: 8px;
            padding: 12px;
        }
        .item-media {
            flex: 0 0 160px;
            height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #222;
            border: 1px solid #555;
            border-radius: 6px;
            overflow: hidden;
        }
        .item-media img { max-width: 100%; max-height: 100%; object-fit: contain; }
        .item-media .placeholder { color: #666; font-size: 0.85em; text-align: center; padding: 0 8px; }
        .item-content { flex: 1; min-width: 0; }
        .item-title { display: flex; gap: 10px; align-items: center; margin-bottom: 6px; }
        .item-name { font-weight: bold; color: #fff; font-size: 1.05em; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .type-badge { font-size: 0.75em; padding: 2px 6px; border-radius: 4px; border: 1px solid #555; color: #ddd; }
        .type-geometry { background: #263238; }
        .type-texture { background: #2e3a29; }
        .item-details { color: #ccc; font-size: 0.9em; }
        .item-detail-line { margin-bottom: 2px; }
        .item-meta { min-width: 140px; text-align: right; }
        .item-size { background: #4CAF50; color: #fff; padding: 4px 8px; border-radius: 4px; font-size: 0.8em; font-weight: bold; display: inline-block; }
        .item-usage { margin-top: 8px; color: #aaa; font-size: 0.85em; }
        .usage-list { margin-top: 6px; display: flex; gap: 6px; flex-wrap: wrap; }
        .usage-chip { background: #444; color: #ddd; border: 1px solid #666; border-radius: 14px; padding: 2px 8px; font-size: 0.75em; cursor: pointer; }
        .usage-chip:hover { background: #4a4a4a; border-color: #888; color: #fff; }
        .results-info { color: #aaa; font-size: 0.85em; margin-bottom: 12px; }
        .loading {
            text-align: center;
            color: #666;
            font-style: italic;
        }
        .more-items {
            color: #888;
            font-size: 0.75em;
            margin-left: 4px;
        }
    `;
  }
  static createStatsGrid(doc, stats) {
    const statsGrid = doc.createElement("div");
    statsGrid.className = "stats-grid";
    const formatBytes = (bytes) => `${(bytes / (1024 * 1024)).toFixed(2)} MB`;
    statsGrid.appendChild(
      _ThreeJSMemoryInspector.createStatCard(doc, formatBytes(stats.totalMemory), "Total Memory")
    );
    statsGrid.appendChild(
      _ThreeJSMemoryInspector.createStatCard(
        doc,
        formatBytes(stats.totalGeometryMemory),
        "Geometry Memory"
      )
    );
    statsGrid.appendChild(
      _ThreeJSMemoryInspector.createStatCard(
        doc,
        formatBytes(stats.totalTextureMemory),
        "Texture Memory"
      )
    );
    statsGrid.appendChild(
      _ThreeJSMemoryInspector.createStatCard(doc, String(stats.geometryCount), "Geometries")
    );
    statsGrid.appendChild(
      _ThreeJSMemoryInspector.createStatCard(doc, String(stats.textureCount), "Textures")
    );
    return statsGrid;
  }
  static createStatCard(doc, value, label) {
    const card = doc.createElement("div");
    card.className = "stat-card";
    const valueDiv = doc.createElement("div");
    valueDiv.className = "stat-value";
    valueDiv.textContent = value;
    card.appendChild(valueDiv);
    const labelDiv = doc.createElement("div");
    labelDiv.className = "stat-label";
    labelDiv.textContent = label;
    card.appendChild(labelDiv);
    return card;
  }
  static createControls(doc, stats) {
    const controls = doc.createElement("div");
    controls.className = "controls";
    const controlGroup = doc.createElement("div");
    controlGroup.className = "control-group";
    const texturesLabel = doc.createElement("label");
    texturesLabel.className = "checkbox";
    const texturesCheckbox = doc.createElement("input");
    texturesCheckbox.type = "checkbox";
    texturesCheckbox.id = "toggleTextures";
    texturesCheckbox.checked = true;
    texturesLabel.appendChild(texturesCheckbox);
    texturesLabel.appendChild(doc.createTextNode(` Textures (${stats.textureCount})`));
    controlGroup.appendChild(texturesLabel);
    const geometriesLabel = doc.createElement("label");
    geometriesLabel.className = "checkbox";
    const geometriesCheckbox = doc.createElement("input");
    geometriesCheckbox.type = "checkbox";
    geometriesCheckbox.id = "toggleGeometries";
    geometriesCheckbox.checked = true;
    geometriesLabel.appendChild(geometriesCheckbox);
    geometriesLabel.appendChild(doc.createTextNode(` Geometries (${stats.geometryCount})`));
    controlGroup.appendChild(geometriesLabel);
    controls.appendChild(controlGroup);
    const filterBar = doc.createElement("div");
    filterBar.className = "filter-bar";
    const filterStatus = doc.createElement("span");
    filterStatus.id = "filterStatus";
    filterStatus.textContent = "No object filter";
    filterBar.appendChild(filterStatus);
    const clearButton = doc.createElement("button");
    clearButton.id = "clearFilter";
    clearButton.className = "clear-btn";
    clearButton.textContent = "Clear filter";
    clearButton.style.display = "none";
    filterBar.appendChild(clearButton);
    controls.appendChild(filterBar);
    return controls;
  }
  static initializeReportInteractivity(doc, geometries, textures, textureThumbnails, geometryPreviews) {
    const texturesData = Array.from(textures.values()).map((tex) => ({
      type: "texture",
      uuid: tex.uuid,
      name: tex.name,
      memoryBytes: tex.memoryBytes,
      width: tex.width,
      height: tex.height,
      format: tex.format,
      sourceType: tex.sourceType,
      url: tex.url,
      usedByObjects: tex.usedByObjects,
      usedByObjectPaths: tex.usedByObjectPaths,
      usedByObjectInstanceIds: tex.usedByObjectInstanceIds,
      instanceCount: tex.usedByObjectInstanceIds.length,
      thumbnail: textureThumbnails.get(tex.uuid) || null
    })).sort((a, b) => b.memoryBytes - a.memoryBytes);
    const geometriesData = Array.from(geometries.values()).map((geo) => ({
      type: "geometry",
      uuid: geo.uuid,
      name: geo.name,
      memoryBytes: geo.memoryBytes,
      vertexCount: geo.vertexCount,
      triangleCount: geo.triangleCount,
      usedByObjects: geo.usedByObjects,
      usedByObjectPaths: geo.objectPaths,
      usedByObjectInstanceIds: geo.usedByObjectInstanceIds,
      instanceCount: geo.usedByObjectInstanceIds.length,
      preview: geometryPreviews.get(geo.uuid) || null
    })).sort((a, b) => b.memoryBytes - a.memoryBytes);
    const itemList = doc.getElementById("itemList");
    const resultsInfo = doc.getElementById("resultsInfo");
    const toggleTextures = doc.getElementById("toggleTextures");
    const toggleGeometries = doc.getElementById("toggleGeometries");
    const filterStatus = doc.getElementById("filterStatus");
    const clearFilterBtn = doc.getElementById("clearFilter");
    if (!itemList || !resultsInfo || !filterStatus || !clearFilterBtn) {
      return;
    }
    let activeObjectFilter = null;
    const formatBytes = (bytes) => `${(bytes / (1024 * 1024)).toFixed(2)} MB`;
    const render = () => {
      const includeTextures = (toggleTextures == null ? void 0 : toggleTextures.checked) ?? true;
      const includeGeometries = (toggleGeometries == null ? void 0 : toggleGeometries.checked) ?? true;
      let items = [];
      if (includeTextures) items.push(...texturesData);
      if (includeGeometries) items.push(...geometriesData);
      const total = items.length;
      if (activeObjectFilter) {
        const filter = activeObjectFilter;
        items = items.filter((item) => item.usedByObjectInstanceIds.includes(filter));
      }
      items.sort((a, b) => b.memoryBytes - a.memoryBytes);
      itemList.innerHTML = "";
      if (items.length === 0) {
        const loading = doc.createElement("div");
        loading.className = "loading";
        loading.textContent = "No items match the current filters.";
        itemList.appendChild(loading);
      } else {
        items.forEach((item) => {
          const itemRow = _ThreeJSMemoryInspector.createItemRow(
            doc,
            item,
            formatBytes,
            (objectId) => {
              activeObjectFilter = objectId;
              updateFilterBar();
              render();
            }
          );
          itemList.appendChild(itemRow);
        });
      }
      resultsInfo.textContent = `Showing ${items.length} of ${total} item(s)`;
    };
    const updateFilterBar = () => {
      if (activeObjectFilter) {
        filterStatus.textContent = `Object filter: ${activeObjectFilter}`;
        clearFilterBtn.style.display = "";
      } else {
        filterStatus.textContent = "No object filter";
        clearFilterBtn.style.display = "none";
      }
    };
    toggleTextures == null ? void 0 : toggleTextures.addEventListener("change", render);
    toggleGeometries == null ? void 0 : toggleGeometries.addEventListener("change", render);
    clearFilterBtn.addEventListener("click", () => {
      activeObjectFilter = null;
      updateFilterBar();
      render();
    });
    updateFilterBar();
    render();
  }
  static createItemRow(doc, item, formatBytes, onObjectClick) {
    const itemRow = doc.createElement("div");
    itemRow.className = "item-row";
    const itemMedia = doc.createElement("div");
    itemMedia.className = "item-media";
    const isTexture = item.type === "texture";
    const mediaSource = isTexture ? item.thumbnail : item.preview;
    if (mediaSource) {
      const img = doc.createElement("img");
      img.src = mediaSource;
      img.alt = item.name;
      itemMedia.appendChild(img);
    } else {
      const placeholder = doc.createElement("div");
      placeholder.className = "placeholder";
      placeholder.textContent = isTexture ? `${item.width} \xD7 ${item.height}` : `${item.vertexCount.toLocaleString()} vertices`;
      itemMedia.appendChild(placeholder);
    }
    itemRow.appendChild(itemMedia);
    const itemContent = doc.createElement("div");
    itemContent.className = "item-content";
    const itemTitle = doc.createElement("div");
    itemTitle.className = "item-title";
    const itemName = doc.createElement("div");
    itemName.className = "item-name";
    itemName.textContent = item.name;
    itemTitle.appendChild(itemName);
    const typeBadge = doc.createElement("div");
    typeBadge.className = `type-badge ${isTexture ? "type-texture" : "type-geometry"}`;
    typeBadge.textContent = isTexture ? "Texture" : "Geometry";
    itemTitle.appendChild(typeBadge);
    itemContent.appendChild(itemTitle);
    const itemDetails = doc.createElement("div");
    itemDetails.className = "item-details";
    if (isTexture) {
      const line1 = doc.createElement("div");
      line1.className = "item-detail-line";
      line1.textContent = `${item.width} \xD7 ${item.height} \u2022 ${item.format}`;
      itemDetails.appendChild(line1);
      const line2 = doc.createElement("div");
      line2.className = "item-detail-line";
      line2.textContent = `Source: ${item.sourceType}`;
      itemDetails.appendChild(line2);
      if (item.url) {
        const line3 = doc.createElement("div");
        line3.className = "item-detail-line";
        line3.textContent = `URL: ${item.url}`;
        itemDetails.appendChild(line3);
      }
    } else {
      const line1 = doc.createElement("div");
      line1.className = "item-detail-line";
      line1.textContent = `${item.vertexCount.toLocaleString()} vertices \u2022 ${item.triangleCount.toLocaleString()} triangles`;
      itemDetails.appendChild(line1);
    }
    itemContent.appendChild(itemDetails);
    const itemUsage = doc.createElement("div");
    itemUsage.className = "item-usage";
    const usageLabel = doc.createElement("div");
    usageLabel.textContent = `Used by ${item.usedByObjects.length} object(s):`;
    itemUsage.appendChild(usageLabel);
    const usageList = doc.createElement("div");
    usageList.className = "usage-list";
    const maxChips = 10;
    const objectsToShow = item.usedByObjects.slice(0, maxChips);
    objectsToShow.forEach((objName, idx) => {
      const chip = doc.createElement("button");
      chip.className = "usage-chip";
      chip.type = "button";
      chip.textContent = objName;
      chip.title = item.usedByObjectPaths[idx] || objName;
      chip.addEventListener("click", () => {
        onObjectClick(item.usedByObjectInstanceIds[idx]);
      });
      usageList.appendChild(chip);
    });
    if (item.usedByObjects.length > maxChips) {
      const more = doc.createElement("span");
      more.className = "more-items";
      more.textContent = `+${item.usedByObjects.length - maxChips} more`;
      usageList.appendChild(more);
    }
    itemUsage.appendChild(usageList);
    itemContent.appendChild(itemUsage);
    itemRow.appendChild(itemContent);
    const itemMeta = doc.createElement("div");
    itemMeta.className = "item-meta";
    const itemSize = doc.createElement("div");
    itemSize.className = "item-size";
    itemSize.textContent = formatBytes(item.memoryBytes);
    itemMeta.appendChild(itemSize);
    const instanceCount = doc.createElement("div");
    instanceCount.style.marginTop = "6px";
    instanceCount.style.color = "#bbb";
    instanceCount.style.fontSize = "0.8em";
    instanceCount.textContent = `${item.instanceCount} instance(s)`;
    itemMeta.appendChild(instanceCount);
    itemRow.appendChild(itemMeta);
    return itemRow;
  }
};
export {
  ThreeJSAnimation,
  ThreeJSAudio,
  ThreeJSChatProbe,
  ThreeJSClickTrigger,
  ThreeJSCube,
  ThreeJSCylinder,
  ThreeJSDebugHelper,
  ThreeJSFrame,
  ThreeJSGraphicsInterface,
  ThreeJSImage,
  ThreeJSImageHandleImpl,
  ThreeJSImageResource,
  ThreeJSInteraction,
  ThreeJSInteractionAdapter,
  ThreeJSLabel,
  ThreeJSLabelHandleImpl,
  ThreeJSLabelResource,
  ThreeJSLight,
  ThreeJSLink,
  ThreeJSMElement,
  ThreeJSMemoryInspector,
  ThreeJSModel,
  ThreeJSModelHandleImpl,
  ThreeJSModelResource,
  ThreeJSOverlay,
  ThreeJSPlane,
  ThreeJSPositionProbe,
  ThreeJSPrompt,
  ThreeJSRemoteDocument,
  ThreeJSResourceManager,
  ThreeJSSphere,
  ThreeJSTransformable,
  ThreeJSVideo
};
//# sourceMappingURL=index.js.map
