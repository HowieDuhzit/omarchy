import { Animation, Model, TransformableElement } from "@mml-io/mml-web";
import { ModelGraphics } from "@mml-io/mml-web";
import { IVect3 } from "@mml-io/mml-web";
import * as THREE from "three";
import { ThreeJSGraphicsAdapter } from "../ThreeJSGraphicsAdapter";
import { ThreeJSAnimationState } from "./ThreeJSAnimation";
type ThreeJSModelLoadState = {
    group: THREE.Object3D;
    bones: Map<string, THREE.Bone>;
    nodeNames: Set<string>;
    boundingBox: {
        size: THREE.Vector3;
        centerOffset: THREE.Vector3;
    };
};
type ThreeJSModelAnimState = {
    currentAnimationClip: THREE.AnimationClip;
    appliedAnimation: {
        animationGroup: THREE.AnimationObjectGroup;
        animationMixer: THREE.AnimationMixer;
        animationAction: THREE.AnimationAction;
    } | null;
};
export declare class ThreeJSModel extends ModelGraphics<ThreeJSGraphicsAdapter> {
    private model;
    private updateMeshCallback;
    private srcLoadingInstanceManager;
    private animLoadingInstanceManager;
    private latestSrcModelHandle;
    private latestAnimModelHandle;
    private socketChildrenByBone;
    private attachments;
    private registeredParentAttachment;
    private static DebugBoundingBoxGeometry;
    private static DebugBoundingBoxMaterial;
    private debugBoundingBox;
    protected loadedState: ThreeJSModelLoadState | null;
    protected animState: ThreeJSModelAnimState | null;
    private documentTimeTickListener;
    private childAnimationMixer;
    private childAnimations;
    constructor(model: Model<ThreeJSGraphicsAdapter>, updateMeshCallback: () => void);
    hasLoadedModel(): boolean;
    hasLoadedAnimation(): boolean;
    disable(): void;
    enable(): void;
    getBoundingBox(): {
        centerOffset: IVect3;
        size: IVect3;
    } | null;
    getCollisionElement(): THREE.Object3D<THREE.Object3DEventMap> | null;
    setDebug(): void;
    setCastShadows(castShadows: boolean): void;
    updateChildAnimation(animation: Animation<ThreeJSGraphicsAdapter>, animationState: ThreeJSAnimationState): void;
    private updateAnimationForAttachment;
    removeChildAnimation(animation: Animation<ThreeJSGraphicsAdapter>): void;
    private removeAnimationForAttachment;
    setAnim(anim: string | null): void;
    setAnimEnabled(): void;
    setAnimLoop(): void;
    setAnimStartTime(): void;
    setAnimPauseTime(): void;
    transformed(): void;
    setSrc(src: string | null): void;
    registerAttachment(attachment: Model<ThreeJSGraphicsAdapter>): void;
    unregisterAttachment(attachment: Model<ThreeJSGraphicsAdapter>): void;
    private updateDebugVisualisation;
    private clearDebugVisualisation;
    private resetAnimationMixer;
    registerSocketChild(child: TransformableElement<ThreeJSGraphicsAdapter>, socketName: string): void;
    unregisterSocketChild(child: TransformableElement<ThreeJSGraphicsAdapter>, socketName: string, addToRoot?: boolean): void;
    private triggerSocketedChildrenTransformed;
    private playAnimation;
    private updateAnimation;
    dispose(): void;
    private static disposeOfGroup;
    private static disposeOfMaterial;
}
export {};
//# sourceMappingURL=ThreeJSModel.d.ts.map