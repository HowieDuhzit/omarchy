import { PositionAndRotation } from "@mml-io/mml-web";
import { CameraManager } from "../camera/CameraManager";
import { CollisionsManager } from "../collisions/CollisionsManager";
import { KeyInputManager } from "../input/KeyInputManager";
import { VirtualJoystick } from "../input/VirtualJoystick";
import { EulXYZ } from "../math/EulXYZ";
import { Vect3 } from "../math/Vect3";
import { CharacterRenderState, CharacterDescription } from "../rendering/IRenderer";
import { CharacterControllerValues } from "../tweakpane/blades/characterControlsFolder";
import { TweakPane } from "../tweakpane/TweakPane";
import { AnimationMixer } from "./AnimationMixer";
import { CharacterState } from "./CharacterState";
import { LocalController } from "./LocalController";
import { RemoteController } from "./RemoteController";
type SpawnPosition = {
    x: number;
    y: number;
    z: number;
};
type SpawnPositionVariance = {
    x: number;
    y: number;
    z: number;
};
type RespawnTrigger = {
    minX: number;
    maxX: number;
    minY: number;
    maxY: number;
    minZ: number;
    maxZ: number;
};
export type SpawnConfiguration = {
    spawnPosition?: Partial<SpawnPosition>;
    spawnPositionVariance?: Partial<SpawnPositionVariance>;
    spawnYRotation?: number;
    respawnTrigger?: Partial<RespawnTrigger>;
    enableRespawnButton?: boolean;
};
export type SpawnConfigurationState = {
    spawnPosition: SpawnPosition;
    spawnPositionVariance: SpawnPositionVariance;
    spawnYRotation: number;
    respawnTrigger: RespawnTrigger;
    enableRespawnButton: boolean;
};
export type CharacterManagerConfig = {
    collisionsManager: CollisionsManager;
    cameraManager: CameraManager;
    keyInputManager: KeyInputManager;
    virtualJoystick?: VirtualJoystick;
    remoteUserStates: Map<number, CharacterState>;
    sendUpdate: (update: CharacterState) => void;
    sendLocalCharacterColors: (colors: Array<[number, number, number]>) => void;
    spawnConfiguration: SpawnConfigurationState;
    characterControllerValues: CharacterControllerValues;
    characterResolve: (clientId: number) => {
        username: string | null;
        characterDescription: CharacterDescription | null;
        colors: Array<[number, number, number]> | null;
    };
    updateURLLocation?: boolean;
};
type RemoteCharacterState = {
    id: number;
    controller: RemoteController;
    animationMixer: AnimationMixer;
    lastUsername: string;
    lastCharacterDescription: CharacterDescription | null;
    lastColors: Array<[number, number, number]> | null;
    renderState: CharacterRenderState;
};
export declare class CharacterManager {
    private config;
    static readonly headTargetOffset: Vect3;
    private localClientId;
    remoteCharacters: Map<number, RemoteCharacterState>;
    localController: LocalController | null;
    private localRenderState;
    private localAnimationMixer;
    private lastUpdateSentTime;
    private tempCameraTarget;
    private cachedCharacterStates;
    private pendingDescriptionUpdates;
    private pendingRemovals;
    constructor(config: CharacterManagerConfig);
    /**
     * Sets the local client ID early to prevent the local character from being
     * spawned as a remote character when network updates arrive before spawnLocalCharacter is called.
     */
    setLocalClientId(id: number): void;
    spawnLocalCharacter(id: number, spawnPosition?: Vect3, spawnRotation?: EulXYZ): void;
    setupTweakPane(tweakPane: TweakPane): void;
    getLocalCharacterPositionAndRotation(): PositionAndRotation;
    clear(): void;
    dispose(): void;
    networkCharacterInfoUpdated(id: number): void;
    update(deltaTime: number, frameCounter: number): {
        updatedCharacterDescriptions: number[];
        removedUserIds: number[];
    };
    getAllCharacterStates(): Map<number, CharacterRenderState>;
    getLocalClientId(): number;
}
export {};
//# sourceMappingURL=CharacterManager.d.ts.map