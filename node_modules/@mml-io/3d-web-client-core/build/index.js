// src/math/Quat.ts
var Quat = class _Quat {
  x;
  y;
  z;
  w;
  constructor(x = 0, y = 0, z = 0, w = 1) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }
  copy(other) {
    this.x = other.x || 0;
    this.y = other.y || 0;
    this.z = other.z || 0;
    this.w = other.w || 0;
    return this;
  }
  multiply(q) {
    return this.multiplyQuaternions(this, q);
  }
  premultiply(q) {
    return this.multiplyQuaternions(q, this);
  }
  multiplyQuaternions(a, b) {
    const qax = a.x;
    const qay = a.y;
    const qaz = a.z;
    const qaw = a.w;
    const qbx = b.x;
    const qby = b.y;
    const qbz = b.z;
    const qbw = b.w;
    this.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
    return this;
  }
  setFromEulerXYZ(euler) {
    const x = euler.x;
    const y = euler.y;
    const z = euler.z;
    const cos = Math.cos;
    const sin = Math.sin;
    const c1 = cos(x / 2);
    const c2 = cos(y / 2);
    const c3 = cos(z / 2);
    const s1 = sin(x / 2);
    const s2 = sin(y / 2);
    const s3 = sin(z / 2);
    this.x = s1 * c2 * c3 + c1 * s2 * s3;
    this.y = c1 * s2 * c3 - s1 * c2 * s3;
    this.z = c1 * c2 * s3 + s1 * s2 * c3;
    this.w = c1 * c2 * c3 - s1 * s2 * s3;
    return this;
  }
  setFromRotationMatrix(m) {
    const te = m.data, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
    if (trace > 0) {
      const s = 0.5 / Math.sqrt(trace + 1);
      this.w = 0.25 / s;
      this.x = (m32 - m23) * s;
      this.y = (m13 - m31) * s;
      this.z = (m21 - m12) * s;
    } else if (m11 > m22 && m11 > m33) {
      const s = 2 * Math.sqrt(1 + m11 - m22 - m33);
      this.w = (m32 - m23) / s;
      this.x = 0.25 * s;
      this.y = (m12 + m21) / s;
      this.z = (m13 + m31) / s;
    } else if (m22 > m33) {
      const s = 2 * Math.sqrt(1 + m22 - m11 - m33);
      this.w = (m13 - m31) / s;
      this.x = (m12 + m21) / s;
      this.y = 0.25 * s;
      this.z = (m23 + m32) / s;
    } else {
      const s = 2 * Math.sqrt(1 + m33 - m11 - m22);
      this.w = (m21 - m12) / s;
      this.x = (m13 + m31) / s;
      this.y = (m23 + m32) / s;
      this.z = 0.25 * s;
    }
    return this;
  }
  setFromAxisAngle(axis, angle) {
    const halfAngle = angle / 2;
    const s = Math.sin(halfAngle);
    this.x = axis.x * s;
    this.y = axis.y * s;
    this.z = axis.z * s;
    this.w = Math.cos(halfAngle);
    return this;
  }
  clone() {
    return new _Quat(this.x, this.y, this.z, this.w);
  }
  set(x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  }
  invert() {
    this.x *= -1;
    this.y *= -1;
    this.z *= -1;
    return this;
  }
  dot(other) {
    return this.x * other.x + this.y * other.y + this.z * other.z + this.w * other.w;
  }
  rotateTowards(other, scalar) {
    const angle = this.angleTo(other);
    if (angle === 0) {
      return this;
    }
    const t = Math.min(1, scalar / angle);
    this.slerp(other, t);
    return this;
  }
  angleTo(q) {
    return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));
  }
  slerp(qb, t) {
    if (t <= 0) return this;
    if (t >= 1) return this.copy(qb);
    const x1 = this.x, y1 = this.y, z1 = this.z, w1 = this.w;
    let x2 = qb.x, y2 = qb.y, z2 = qb.z, w2 = qb.w;
    let cosHalfTheta = w1 * w2 + x1 * x2 + y1 * y2 + z1 * z2;
    if (cosHalfTheta < 0) {
      w2 = -w2;
      x2 = -x2;
      y2 = -y2;
      z2 = -z2;
      cosHalfTheta = -cosHalfTheta;
    }
    if (cosHalfTheta >= 1) {
      return this.set(x1, y1, z1, w1);
    }
    const sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);
    if (sinHalfTheta < 1e-3) {
      this.w = 0.5 * (w1 + w2);
      this.x = 0.5 * (x1 + x2);
      this.y = 0.5 * (y1 + y2);
      this.z = 0.5 * (z1 + z2);
      return this.normalize();
    }
    const halfTheta = Math.acos(cosHalfTheta);
    const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta;
    const ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
    this.w = w1 * ratioA + w2 * ratioB;
    this.x = x1 * ratioA + x2 * ratioB;
    this.y = y1 * ratioA + y2 * ratioB;
    this.z = z1 * ratioA + z2 * ratioB;
    return this.normalize();
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  normalize() {
    let l = this.length();
    if (l === 0) {
      this.x = 0;
      this.y = 0;
      this.z = 0;
      this.w = 1;
    } else {
      l = 1 / l;
      this.x = this.x * l;
      this.y = this.y * l;
      this.z = this.z * l;
      this.w = this.w * l;
    }
    return this;
  }
};

// src/math/Vect3.ts
var tempQuaternion = new Quat();
var Vect3 = class _Vect3 {
  constructor(x = 0, y = 0, z = 0) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
  copy(other) {
    this.x = other.x;
    this.y = other.y;
    this.z = other.z;
    return this;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  lengthSquared() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  clone() {
    return new _Vect3(this.x, this.y, this.z);
  }
  set(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  }
  applyEulerXYZ(euler) {
    return this.applyQuat(tempQuaternion.setFromEulerXYZ(euler));
  }
  applyMatrix4(matrix) {
    const x = this.x;
    const y = this.y;
    const z = this.z;
    const e = matrix.data;
    const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
    return this;
  }
  transformDirection(matrix) {
    const x = this.x;
    const y = this.y;
    const z = this.z;
    const e = matrix.data;
    this.x = e[0] * x + e[4] * y + e[8] * z;
    this.y = e[1] * x + e[5] * y + e[9] * z;
    this.z = e[2] * x + e[6] * y + e[10] * z;
    return this.normalize();
  }
  add(other) {
    this.x += other.x;
    this.y += other.y;
    this.z += other.z;
    return this;
  }
  sub(other) {
    this.x -= other.x;
    this.y -= other.y;
    this.z -= other.z;
    return this;
  }
  applyQuat(q) {
    const vx = this.x, vy = this.y, vz = this.z;
    const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
    const tx = 2 * (qy * vz - qz * vy);
    const ty = 2 * (qz * vx - qx * vz);
    const tz = 2 * (qx * vy - qy * vx);
    this.x = vx + qw * tx + qy * tz - qz * ty;
    this.y = vy + qw * ty + qz * tx - qx * tz;
    this.z = vz + qw * tz + qx * ty - qy * tx;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  }
  normalize() {
    return this.multiplyScalar(1 / (this.length() || 1));
  }
  addScaledVector(other, scalar) {
    this.x += other.x * scalar;
    this.y += other.y * scalar;
    this.z += other.z * scalar;
    return this;
  }
  distanceTo(other) {
    return Math.sqrt(this.distanceToSquared(other));
  }
  distanceToSquared(other) {
    const dx = other.x - this.x;
    const dy = other.y - this.y;
    const dz = other.z - this.z;
    return dx * dx + dy * dy + dz * dz;
  }
  applyAxisAngle(axis, angle) {
    return this.applyQuat(tempQuaternion.setFromAxisAngle(axis, angle));
  }
  min(point) {
    this.x = Math.min(this.x, point.x);
    this.y = Math.min(this.y, point.y);
    this.z = Math.min(this.z, point.z);
    return this;
  }
  max(point) {
    this.x = Math.max(this.x, point.x);
    this.y = Math.max(this.y, point.y);
    this.z = Math.max(this.z, point.z);
    return this;
  }
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    return this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  }
  cross(other) {
    return this.crossVectors(this, other);
  }
  crossVectors(a, b) {
    const ax = a.x;
    const ay = a.y;
    const az = a.z;
    const bx = b.x;
    const by = b.y;
    const bz = b.z;
    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;
    return this;
  }
  subScalar(s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    return this;
  }
  addScalar(s) {
    this.x += s;
    this.y += s;
    this.z += s;
    return this;
  }
  multiply(other) {
    this.x *= other.x;
    this.y *= other.y;
    this.z *= other.z;
    return this;
  }
  lerp(target, alpha) {
    this.x += (target.x - this.x) * alpha;
    this.y += (target.y - this.y) * alpha;
    this.z += (target.z - this.z) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    return this;
  }
  toArray() {
    return [this.x, this.y, this.z];
  }
};

// src/math/Matr4.ts
var Vect3Zeroes = { x: 0, y: 0, z: 0 };
var Vect3Ones = { x: 1, y: 1, z: 1 };
var Matr4 = class _Matr4 {
  static tempMatr4 = new _Matr4();
  static tempVect3 = new Vect3();
  static tempQuat = new Quat();
  data = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  constructor(...args) {
    if (args.length > 0) {
      this.set(
        ...args
      );
    }
  }
  identity() {
    this.data = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    return this;
  }
  copy(m) {
    const te = this.data;
    const me = m.data;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    te[9] = me[9];
    te[10] = me[10];
    te[11] = me[11];
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    te[15] = me[15];
    return this;
  }
  fromArray(data) {
    this.data[0] = data[0];
    this.data[1] = data[1];
    this.data[2] = data[2];
    this.data[3] = data[3];
    this.data[4] = data[4];
    this.data[5] = data[5];
    this.data[6] = data[6];
    this.data[7] = data[7];
    this.data[8] = data[8];
    this.data[9] = data[9];
    this.data[10] = data[10];
    this.data[11] = data[11];
    this.data[12] = data[12];
    this.data[13] = data[13];
    this.data[14] = data[14];
    this.data[15] = data[15];
    return this;
  }
  set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    const te = this.data;
    te[0] = n11;
    te[4] = n12;
    te[8] = n13;
    te[12] = n14;
    te[1] = n21;
    te[5] = n22;
    te[9] = n23;
    te[13] = n24;
    te[2] = n31;
    te[6] = n32;
    te[10] = n33;
    te[14] = n34;
    te[3] = n41;
    te[7] = n42;
    te[11] = n43;
    te[15] = n44;
    return this;
  }
  setRotationFromQuaternion(q) {
    return this.compose(Vect3Zeroes, q, Vect3Ones);
  }
  clone() {
    return new _Matr4().copy(this);
  }
  determinant() {
    const te = this.data;
    const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
    const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
    const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
    const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
  }
  makeRotationX(theta) {
    const c = Math.cos(theta), s = Math.sin(theta);
    this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
    return this;
  }
  makeRotationY(theta) {
    const c = Math.cos(theta), s = Math.sin(theta);
    this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
    return this;
  }
  makeRotationZ(theta) {
    const c = Math.cos(theta), s = Math.sin(theta);
    this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }
  makeTranslation(x, y, z) {
    this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
    return this;
  }
  makeScale(x, y, z) {
    this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
    return this;
  }
  compose(position, quaternion, scale) {
    const te = this.data;
    const x = quaternion.x, y = quaternion.y, z = quaternion.z, w = quaternion.w;
    const x2 = x + x, y2 = y + y, z2 = z + z;
    const xx = x * x2, xy = x * y2, xz = x * z2;
    const yy = y * y2, yz = y * z2, zz = z * z2;
    const wx = w * x2, wy = w * y2, wz = w * z2;
    const sx = scale.x, sy = scale.y, sz = scale.z;
    te[0] = (1 - (yy + zz)) * sx;
    te[1] = (xy + wz) * sx;
    te[2] = (xz - wy) * sx;
    te[3] = 0;
    te[4] = (xy - wz) * sy;
    te[5] = (1 - (xx + zz)) * sy;
    te[6] = (yz + wx) * sy;
    te[7] = 0;
    te[8] = (xz + wy) * sz;
    te[9] = (yz - wx) * sz;
    te[10] = (1 - (xx + yy)) * sz;
    te[11] = 0;
    te[12] = position.x;
    te[13] = position.y;
    te[14] = position.z;
    te[15] = 1;
    return this;
  }
  decompose(position, quaternion, scale) {
    const te = this.data;
    const _v1 = _Matr4.tempVect3;
    let sx = _v1.set(te[0], te[1], te[2]).length();
    const sy = _v1.set(te[4], te[5], te[6]).length();
    const sz = _v1.set(te[8], te[9], te[10]).length();
    const det = this.determinant();
    if (det < 0) sx = -sx;
    position.x = te[12];
    position.y = te[13];
    position.z = te[14];
    const _m1 = _Matr4.tempMatr4;
    _m1.copy(this);
    const invSX = 1 / sx;
    const invSY = 1 / sy;
    const invSZ = 1 / sz;
    _m1.data[0] *= invSX;
    _m1.data[1] *= invSX;
    _m1.data[2] *= invSX;
    _m1.data[4] *= invSY;
    _m1.data[5] *= invSY;
    _m1.data[6] *= invSY;
    _m1.data[8] *= invSZ;
    _m1.data[9] *= invSZ;
    _m1.data[10] *= invSZ;
    const _q1 = _Matr4.tempQuat;
    _q1.setFromRotationMatrix(_m1);
    quaternion.x = _q1.x;
    quaternion.y = _q1.y;
    quaternion.z = _q1.z;
    quaternion.w = _q1.w;
    scale.x = sx;
    scale.y = sy;
    scale.z = sz;
    return this;
  }
  getScale(vect3) {
    const te = this.data;
    const _v1 = _Matr4.tempVect3;
    let sx = _v1.set(te[0], te[1], te[2]).length();
    const sy = _v1.set(te[4], te[5], te[6]).length();
    const sz = _v1.set(te[8], te[9], te[10]).length();
    const det = this.determinant();
    if (det < 0) sx = -sx;
    vect3.x = sx;
    vect3.y = sy;
    vect3.z = sz;
    return vect3;
  }
  multiply(m) {
    return this.multiplyMatrices(this, m);
  }
  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }
  multiplyMatrices(a, b) {
    const ae = a.data;
    const be = b.data;
    const te = this.data;
    const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
    const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
    const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
    const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
    const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
    const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
    const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
    const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  }
  invert() {
    const te = this.data, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    if (det === 0) {
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
    te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
    te[4] = t12 * detInv;
    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
    te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
    te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
    te[8] = t13 * detInv;
    te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
    te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
    te[12] = t14 * detInv;
    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
    te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
    te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
    return this;
  }
  equals(other) {
    for (let i = 0; i < 16; i++) {
      if (this.data[i] !== other.data[i]) {
        return false;
      }
    }
    return true;
  }
  setPosition(x, y, z) {
    this.data[12] = x;
    this.data[13] = y;
    this.data[14] = z;
    return this;
  }
};

// src/math/EulXYZ.ts
var EulXYZ = class _EulXYZ {
  static tempMatrix = new Matr4();
  x;
  y;
  z;
  constructor(x = 0, y = 0, z = 0) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
  setFromRotationMatrix(m) {
    const d = m.data;
    const m11 = d[0];
    const m12 = d[4];
    const m13 = d[8];
    const m22 = d[5];
    const m23 = d[9];
    const m32 = d[6];
    const m33 = d[10];
    this.y = Math.asin(clamp(m13, -1, 1));
    if (Math.abs(m13) < 0.9999999) {
      this.x = Math.atan2(-m23, m33);
      this.z = Math.atan2(-m12, m11);
    } else {
      this.x = Math.atan2(m32, m22);
      this.z = 0;
    }
    return this;
  }
  setFromQuaternion(q) {
    const matrix = _EulXYZ.tempMatrix;
    matrix.setRotationFromQuaternion(q);
    return this.setFromRotationMatrix(matrix);
  }
  copy(other) {
    this.x = other.x || 0;
    this.y = other.y || 0;
    this.z = other.z || 0;
    return this;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  lengthSquared() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  clone() {
    return new _EulXYZ(this.x, this.y, this.z);
  }
  set(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  }
};

// src/math/Ray.ts
var _edge1 = new Vect3();
var _edge2 = new Vect3();
var _normal = new Vect3();
var _diff = new Vect3();
var Ray = class _Ray {
  origin = new Vect3();
  direction = new Vect3();
  constructor(origin, direction) {
    if (origin) {
      this.origin.copy(origin);
    }
    if (direction) {
      this.direction.copy(direction);
    }
  }
  setOrigin(origin) {
    this.origin.copy(origin);
    return this;
  }
  setDirection(direction) {
    this.direction.copy(direction);
    return this;
  }
  clone() {
    return new _Ray(this.origin, this.direction);
  }
  set(origin, direction) {
    this.origin.copy(origin);
    this.direction.copy(direction);
    return this;
  }
  copy(ray) {
    this.origin.copy(ray.origin);
    this.direction.copy(ray.direction);
    return this;
  }
  applyMatrix4(matr4) {
    this.origin.applyMatrix4(matr4);
    this.direction.transformDirection(matr4);
    return this;
  }
  intersectTriangle(a, b, c, backfaceCulling, target) {
    _edge1.subVectors(b, a);
    _edge2.subVectors(c, a);
    _normal.crossVectors(_edge1, _edge2);
    let DdN = this.direction.dot(_normal);
    let sign;
    if (DdN > 0) {
      if (backfaceCulling) return null;
      sign = 1;
    } else if (DdN < 0) {
      sign = -1;
      DdN = -DdN;
    } else {
      return null;
    }
    _diff.subVectors(this.origin, a);
    const DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
    if (DdQxE2 < 0) {
      return null;
    }
    const DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff));
    if (DdE1xQ < 0) {
      return null;
    }
    if (DdQxE2 + DdE1xQ > DdN) {
      return null;
    }
    const QdN = -sign * _diff.dot(_normal);
    if (QdN < 0) {
      return null;
    }
    return this.at(QdN / DdN, target);
  }
  at(t, target) {
    return target.copy(this.origin).addScaledVector(this.direction, t);
  }
};

// src/math/Line.ts
var _startP = new Vect3();
var _startEnd = new Vect3();
var Line = class _Line {
  start = new Vect3();
  end = new Vect3();
  constructor(start, end) {
    if (start) {
      this.start.copy(start);
    }
    if (end) {
      this.end.copy(end);
    }
  }
  setStart(start) {
    this.start.copy(start);
    return this;
  }
  setEnd(end) {
    this.end.copy(end);
    return this;
  }
  length() {
    const dx = this.end.x - this.start.x;
    const dy = this.end.y - this.start.y;
    const dz = this.end.z - this.start.z;
    return Math.sqrt(dx * dx + dy * dy + dz * dz);
  }
  lengthSquared() {
    const dx = this.end.x - this.start.x;
    const dy = this.end.y - this.start.y;
    const dz = this.end.z - this.start.z;
    return dx * dx + dy * dy + dz * dz;
  }
  clone() {
    return new _Line(this.start, this.end);
  }
  copy(other) {
    this.start.copy(other.start);
    this.end.copy(other.end);
    return this;
  }
  applyMatrix4(matr4) {
    this.start.applyMatrix4(matr4);
    this.end.applyMatrix4(matr4);
    return this;
  }
  distance() {
    const dx = this.end.x - this.start.x;
    const dy = this.end.y - this.start.y;
    const dz = this.end.z - this.start.z;
    return Math.sqrt(dx * dx + dy * dy + dz * dz);
  }
  at(t, target) {
    target.x = this.start.x + t * (this.end.x - this.start.x);
    target.y = this.start.y + t * (this.end.y - this.start.y);
    target.z = this.start.z + t * (this.end.z - this.start.z);
    return target;
  }
  closestPointToPointParameter(point, clampToLine) {
    _startP.subVectors(point, this.start);
    _startEnd.subVectors(this.end, this.start);
    const startEnd2 = _startEnd.dot(_startEnd);
    const startEnd_startP = _startEnd.dot(_startP);
    let t = startEnd_startP / startEnd2;
    if (clampToLine) {
      t = clamp(t, 0, 1);
    }
    return t;
  }
  closestPointToPoint(point, clampToLine, target) {
    const t = this.closestPointToPointParameter(point, clampToLine);
    return this.delta(target).multiplyScalar(t).add(this.start);
  }
  delta(target) {
    return target.subVectors(this.end, this.start);
  }
};

// src/math/Box.ts
var tempPoints = [
  new Vect3(),
  new Vect3(),
  new Vect3(),
  new Vect3(),
  new Vect3(),
  new Vect3(),
  new Vect3(),
  new Vect3()
];
var Box = class _Box {
  min = new Vect3();
  max = new Vect3();
  constructor(min, max) {
    if (min) {
      this.min.copy(min);
    }
    if (max) {
      this.max.copy(max);
    }
  }
  setStart(min) {
    this.min.copy(min);
    return this;
  }
  setEnd(max) {
    this.max.copy(max);
    return this;
  }
  length() {
    const dx = this.max.x - this.min.x;
    const dy = this.max.y - this.min.y;
    const dz = this.max.z - this.min.z;
    return Math.sqrt(dx * dx + dy * dy + dz * dz);
  }
  clone() {
    return new _Box(this.min, this.max);
  }
  copy(other) {
    this.min.copy(other.min);
    this.max.copy(other.max);
    return this;
  }
  expandByPoint(point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  }
  makeEmpty() {
    this.min.set(Infinity, Infinity, Infinity);
    this.max.set(-Infinity, -Infinity, -Infinity);
    return this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  applyMatrix4(matr4) {
    if (this.isEmpty()) {
      return this;
    }
    tempPoints[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matr4);
    tempPoints[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matr4);
    tempPoints[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matr4);
    tempPoints[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matr4);
    tempPoints[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matr4);
    tempPoints[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matr4);
    tempPoints[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matr4);
    tempPoints[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matr4);
    this.makeEmpty();
    for (const p of tempPoints) {
      this.expandByPoint(p);
    }
    return this;
  }
};

// src/math/radToDeg.ts
function radToDeg(rad) {
  return rad * (180 / Math.PI);
}
function degToRad(deg) {
  return deg * (Math.PI / 180);
}

// src/helpers/math-helpers.ts
var roundToDecimalPlaces = (value, decimalPlaces) => {
  const mult = 10 ** decimalPlaces;
  return Math.round(value * mult) / mult;
};
var toArray = (origin, precision = 3) => {
  const array = [];
  array[0] = roundToDecimalPlaces(origin.x, precision);
  array[1] = roundToDecimalPlaces(origin.y, precision);
  array[2] = roundToDecimalPlaces(origin.z, precision);
  if (origin.w !== void 0) {
    array[3] = roundToDecimalPlaces(origin.w, precision);
  }
  return array;
};
var getSpawnPositionInsideCircle = (radius, positions, id, yPos = 0) => {
  if (id > 0) id += 3;
  const goldenAngle = Math.PI * (3 - Math.sqrt(5));
  const theta = id * goldenAngle;
  const scale = id / positions;
  const scaledRadius = scale * radius;
  const x = Math.cos(theta) * scaledRadius;
  const z = Math.sin(theta) * scaledRadius;
  return new Vect3(x, yPos, z);
};
var round = (n, digits) => {
  return Number(n.toFixed(digits));
};
var ease = (target, n, factor) => {
  return round((target - n) * factor, 5);
};
function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}
var remap = (value, minValue, maxValue, minScaledValue, maxScaledValue) => {
  return minScaledValue + (maxScaledValue - minScaledValue) * (value - minValue) / (maxValue - minValue);
};

// src/input/EventHandlerCollection.ts
var EventHandlerCollection = class _EventHandlerCollection {
  eventsByTarget = /* @__PURE__ */ new Map();
  add(target, key, listener, options) {
    target.addEventListener(key, listener, options);
    let existingTarget = this.eventsByTarget.get(target);
    if (existingTarget === void 0) {
      existingTarget = /* @__PURE__ */ new Map();
      this.eventsByTarget.set(target, existingTarget);
    }
    let existingKey = existingTarget.get(key);
    if (existingKey === void 0) {
      existingKey = /* @__PURE__ */ new Set();
      existingTarget.set(key, existingKey);
    }
    existingKey.add(listener);
    return this;
  }
  clear() {
    this.eventsByTarget.forEach((keyMap, target) => {
      keyMap.forEach((listenerSet, key) => {
        listenerSet.forEach((listenerFunc) => {
          target.removeEventListener(key, listenerFunc);
        });
      });
    });
    this.eventsByTarget.clear();
  }
  static create(initial) {
    const instance = new _EventHandlerCollection();
    if (initial !== void 0) {
      initial.forEach(([target, key, listenerFunc, options]) => {
        instance.add(target, key, listenerFunc, options);
      });
    }
    return instance;
  }
};

// src/tweakpane/tweakPaneActivity.ts
var isTweakpaneActive = false;
function setTweakpaneActive(status) {
  isTweakpaneActive = status;
}
function getTweakpaneActive() {
  return isTweakpaneActive;
}

// src/camera/CameraManager.ts
var cameraPanSensitivity = 20;
var scrollZoomSensitivity = 0.1;
var pinchZoomSensitivity = 0.025;
var CameraManager = class {
  constructor(targetElement, collisionsManager, initialPhi = Math.PI / 2, initialTheta = -Math.PI / 2) {
    this.targetElement = targetElement;
    this.collisionsManager = collisionsManager;
    this.targetElement.style.touchAction = "pinch-zoom";
    this.phi = initialPhi;
    this.targetPhi = this.phi;
    this.theta = initialTheta;
    this.targetTheta = this.theta;
    this.aspect = window.innerWidth / window.innerHeight;
    const initialPosition = new Vect3(0, 1.4, -this.initialDistance);
    const initialRotation = new Quat();
    this.cameraState = {
      position: initialPosition,
      rotation: initialRotation,
      fov: this.fov,
      aspect: this.aspect
    };
    this.flyCameraState = {
      position: new Vect3().copy(initialPosition),
      rotation: new Quat().copy(initialRotation),
      fov: this.initialFOV,
      aspect: this.aspect
    };
    this.createEventHandlers();
  }
  isMainCameraActive = true;
  initialDistance = 3.3;
  minDistance = 0.1;
  maxDistance = 5;
  damping = 0.21;
  zoomScale = 0.04;
  zoomDamping = 0.04;
  initialFOV = 60;
  maxFOV = 70;
  minFOV = 60;
  invertFOVMapping = false;
  fov = this.initialFOV;
  targetFOV = this.initialFOV;
  minPolarAngle = Math.PI * 0.05;
  maxPolarAngle = Math.PI * 0.95;
  distance = this.initialDistance;
  targetDistance = this.initialDistance;
  desiredDistance = this.initialDistance;
  phi;
  targetPhi;
  theta;
  targetTheta;
  target = new Vect3(0, 1.55, 0);
  hadTarget = false;
  cameraRay = new Ray();
  tempVec3 = new Vect3();
  eventHandlerCollection;
  finalTarget = new Vect3();
  isLerping = false;
  lerpTarget = new Vect3();
  lerpFactor = 0;
  lerpDuration = 2.1;
  tempMatr4 = new Matr4();
  activePointers = /* @__PURE__ */ new Map();
  cameraState;
  flyCameraState;
  aspect;
  // Fly camera orbit controls state
  flyCameraLookAt = new Vect3(0, 0, 0);
  flyCameraYaw = 0;
  flyCameraPitch = Math.PI * 0.4;
  flyCameraDistance = 15;
  flyCameraMouseDown = false;
  flyCameraIsPanning = false;
  flyCameraLastMouseX = 0;
  flyCameraLastMouseY = 0;
  flyCameraEventHandlerCollection = null;
  // Orbit controls settings
  orbitControlsRotateSensitivity = 2e-3;
  orbitControlsPanSensitivity = 0.01;
  orbitControlsZoomSensitivity = 0.1;
  // Polar angle constraints: 0 = camera above lookAt (looking down), π = camera below lookAt (looking up)
  // Constrain to prevent going over the top (pitch < 0) but allow pointing above horizon (pitch > π/2)
  orbitControlsMinPolarAngle = 1e-3;
  // Just above 0 to prevent going over the top
  orbitControlsMaxPolarAngle = Math.PI - 1e-3;
  // Just below π to allow looking up
  // Temporary vectors for panning calculations
  tempPanRight = new Vect3();
  tempPanUp = new Vect3();
  tempPanForward = new Vect3();
  createEventHandlers() {
    this.eventHandlerCollection = EventHandlerCollection.create([
      [this.targetElement, "pointerdown", this.onPointerDown.bind(this)],
      [this.targetElement, "gesturestart", this.preventDefaultAndStopPropagation.bind(this)],
      [this.targetElement, "wheel", this.onMouseWheel.bind(this)],
      [this.targetElement, "contextmenu", this.onContextMenu.bind(this)],
      [document, "pointerup", this.onPointerUp.bind(this)],
      [document, "pointercancel", this.onPointerUp.bind(this)],
      [document, "pointermove", this.onPointerMove.bind(this)]
    ]);
  }
  disposeEventHandlers() {
    this.eventHandlerCollection.clear();
  }
  createFlyCameraEventHandlers() {
    this.flyCameraEventHandlerCollection = EventHandlerCollection.create([
      [window, "blur", this.onFlyCameraBlur.bind(this)],
      [this.targetElement, "mousedown", this.onFlyCameraMouseDown.bind(this)],
      [document, "mousemove", this.onFlyCameraMouseMove.bind(this)],
      [document, "mouseup", this.onFlyCameraMouseUp.bind(this)],
      [this.targetElement, "wheel", this.onFlyCameraWheel.bind(this)],
      [this.targetElement, "contextmenu", this.onContextMenu.bind(this)]
    ]);
  }
  disposeFlyCameraEventHandlers() {
    if (this.flyCameraEventHandlerCollection) {
      this.flyCameraEventHandlerCollection.clear();
      this.flyCameraEventHandlerCollection = null;
    }
  }
  onFlyCameraBlur() {
    this.flyCameraMouseDown = false;
    this.flyCameraIsPanning = false;
  }
  onFlyCameraMouseDown(event) {
    if (event.button === 0) {
      this.flyCameraMouseDown = true;
      this.flyCameraIsPanning = false;
      this.flyCameraLastMouseX = event.clientX;
      this.flyCameraLastMouseY = event.clientY;
      document.body.style.cursor = "none";
      event.preventDefault();
    } else if (event.button === 1 || event.button === 2) {
      this.flyCameraMouseDown = true;
      this.flyCameraIsPanning = true;
      this.flyCameraLastMouseX = event.clientX;
      this.flyCameraLastMouseY = event.clientY;
      document.body.style.cursor = "move";
      event.preventDefault();
    }
  }
  onFlyCameraMouseUp(event) {
    this.flyCameraMouseDown = false;
    this.flyCameraIsPanning = false;
    document.body.style.cursor = "default";
  }
  onFlyCameraMouseMove(event) {
    if (!this.flyCameraMouseDown || getTweakpaneActive()) {
      return;
    }
    const movementX = event.movementX !== void 0 ? event.movementX : event.clientX - this.flyCameraLastMouseX;
    const movementY = event.movementY !== void 0 ? event.movementY : event.clientY - this.flyCameraLastMouseY;
    if (this.flyCameraIsPanning) {
      this.panFlyCameraLookAt(movementX, movementY);
    } else {
      this.flyCameraYaw -= movementX * this.orbitControlsRotateSensitivity;
      this.flyCameraPitch -= movementY * this.orbitControlsRotateSensitivity;
      this.flyCameraYaw = this.flyCameraYaw % (Math.PI * 2);
      this.flyCameraPitch = Math.max(
        this.orbitControlsMinPolarAngle,
        Math.min(this.orbitControlsMaxPolarAngle, this.flyCameraPitch)
      );
    }
    this.flyCameraLastMouseX = event.clientX;
    this.flyCameraLastMouseY = event.clientY;
    event.preventDefault();
  }
  panFlyCameraLookAt(deltaX, deltaY) {
    const sinPhi = Math.sin(this.flyCameraPitch);
    const cosPhi = Math.cos(this.flyCameraPitch);
    const sinTheta = Math.sin(this.flyCameraYaw);
    const cosTheta = Math.cos(this.flyCameraYaw);
    this.tempPanForward.set(-sinPhi * sinTheta, -cosPhi, -sinPhi * cosTheta).normalize();
    const worldUp = new Vect3(0, 1, 0);
    this.tempPanRight.copy(this.tempPanForward).cross(worldUp).normalize();
    if (this.tempPanRight.lengthSquared() < 0.01) {
      this.tempPanRight.set(cosTheta, 0, -sinTheta).normalize();
    }
    this.tempPanUp.copy(this.tempPanRight).cross(this.tempPanForward).normalize();
    const panDistance = this.flyCameraDistance * this.orbitControlsPanSensitivity;
    const panRight = this.tempPanRight.clone().multiplyScalar(-deltaX * panDistance);
    const panUp = this.tempPanUp.clone().multiplyScalar(deltaY * panDistance);
    this.flyCameraLookAt.add(panRight);
    this.flyCameraLookAt.add(panUp);
  }
  onFlyCameraWheel(event) {
    if (getTweakpaneActive()) {
      return;
    }
    event.preventDefault();
    this.flyCameraDistance += event.deltaY * this.orbitControlsZoomSensitivity;
    this.flyCameraDistance = Math.max(0.01, Math.min(this.flyCameraDistance, 1e3));
  }
  preventDefaultAndStopPropagation(evt) {
    evt.preventDefault();
    evt.stopPropagation();
  }
  onPointerDown(event) {
    if (event.button === 0 || event.button === 2) {
      const pointerInfo = { x: event.clientX, y: event.clientY };
      this.activePointers.set(event.pointerId, pointerInfo);
      document.body.style.cursor = "none";
    }
  }
  onPointerUp(event) {
    const existingPointer = this.activePointers.get(event.pointerId);
    if (existingPointer) {
      this.activePointers.delete(event.pointerId);
      if (this.activePointers.size === 0) {
        document.body.style.cursor = "default";
      }
    }
  }
  getAveragePointerPositionAndSpread() {
    const existingSum = { x: 0, y: 0 };
    this.activePointers.forEach((p) => {
      existingSum.x += p.x;
      existingSum.y += p.y;
    });
    const aX = existingSum.x / this.activePointers.size;
    const aY = existingSum.y / this.activePointers.size;
    let sumOfDistances = 0;
    this.activePointers.forEach((p) => {
      const distance = Math.sqrt((p.x - aX) ** 2 + (p.y - aY) ** 2);
      sumOfDistances += distance;
    });
    return { pos: { x: aX, y: aY }, spread: sumOfDistances / this.activePointers.size };
  }
  onPointerMove(event) {
    if (getTweakpaneActive()) {
      return;
    }
    const existingPointer = this.activePointers.get(event.pointerId);
    if (existingPointer) {
      const previous = this.getAveragePointerPositionAndSpread();
      existingPointer.x = event.clientX;
      existingPointer.y = event.clientY;
      const latest = this.getAveragePointerPositionAndSpread();
      const sX = latest.pos.x - previous.pos.x;
      const sY = latest.pos.y - previous.pos.y;
      const dx = sX / this.targetElement.clientWidth * cameraPanSensitivity;
      const dy = sY / this.targetElement.clientHeight * cameraPanSensitivity;
      if (this.activePointers.size > 1) {
        const zoomDelta = latest.spread - previous.spread;
        this.zoom(-zoomDelta * pinchZoomSensitivity);
      }
      this.targetTheta += dx;
      this.targetPhi -= dy;
      this.targetPhi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, this.targetPhi));
      event.preventDefault();
    }
  }
  onMouseWheel(event) {
    if (getTweakpaneActive()) {
      return;
    }
    event.preventDefault();
    const scrollAmount = event.deltaY * this.zoomScale * scrollZoomSensitivity;
    this.zoom(scrollAmount);
  }
  zoom(delta) {
    this.targetDistance += delta;
    this.targetDistance = Math.max(
      this.minDistance,
      Math.min(this.maxDistance, this.targetDistance)
    );
    this.desiredDistance = this.targetDistance;
  }
  onContextMenu(event) {
    event.preventDefault();
  }
  setTarget(target) {
    if (!this.isLerping) {
      this.target.copy(target);
    } else {
      this.finalTarget.copy(target);
      this.lerpTarget.copy(this.target);
      this.lerpFactor = 0;
    }
    if (!this.hadTarget) {
      this.hadTarget = true;
      this.reverseUpdateFromPositions(this.cameraState.position, this.cameraState.rotation);
    }
  }
  setLerpedTarget(target, targetDistance) {
    this.isLerping = true;
    this.targetDistance = targetDistance;
    this.desiredDistance = targetDistance;
    this.setTarget(target);
  }
  reverseUpdateFromPositions(position, rotation) {
    const dx = position.x - this.target.x;
    const dy = position.y - this.target.y;
    const dz = position.z - this.target.z;
    this.targetDistance = Math.sqrt(dx * dx + dy * dy + dz * dz);
    this.distance = this.targetDistance;
    this.desiredDistance = this.targetDistance;
    this.theta = Math.atan2(dz, dx);
    this.targetTheta = this.theta;
    this.phi = Math.acos(dy / this.targetDistance);
    this.targetPhi = this.phi;
    this.recomputeFoV(true);
  }
  adjustCameraPosition(position, rotation) {
    const offsetDistance = 0.5;
    const offset = this.tempVec3.set(0, 0, offsetDistance);
    const matr4 = this.tempMatr4.setRotationFromQuaternion(rotation);
    offset.applyMatrix4(matr4);
    const rayOrigin = offset.add(position);
    const rayDirection = rayOrigin.sub(this.target).normalize();
    this.cameraRay.set(this.target, rayDirection);
    const firstRaycastHit = this.collisionsManager.raycastFirst(this.cameraRay);
    if (firstRaycastHit !== null && firstRaycastHit[0] <= this.desiredDistance) {
      const distanceToCollision = firstRaycastHit[0] - 0.1;
      this.targetDistance = distanceToCollision;
      this.distance = distanceToCollision;
    } else {
      this.targetDistance = this.desiredDistance;
    }
  }
  updateFlyCameraOrbitControls() {
    const sinPhi = Math.sin(this.flyCameraPitch);
    const cosPhi = Math.cos(this.flyCameraPitch);
    const sinTheta = Math.sin(this.flyCameraYaw);
    const cosTheta = Math.cos(this.flyCameraYaw);
    const x = this.flyCameraLookAt.x + this.flyCameraDistance * sinPhi * sinTheta;
    const y = this.flyCameraLookAt.y + this.flyCameraDistance * cosPhi;
    const z = this.flyCameraLookAt.z + this.flyCameraDistance * sinPhi * cosTheta;
    this.flyCameraState.position.set(x, y, z);
    const direction = new Vect3().copy(this.flyCameraLookAt).sub(this.flyCameraState.position).normalize();
    const up = new Vect3(0, 1, 0);
    const right = new Vect3().copy(direction).cross(up).normalize();
    const correctedUp = new Vect3().copy(right).cross(direction).normalize();
    const lookAtMatrix = this.tempMatr4.set(
      right.x,
      correctedUp.x,
      -direction.x,
      0,
      right.y,
      correctedUp.y,
      -direction.y,
      0,
      right.z,
      correctedUp.z,
      -direction.z,
      0,
      0,
      0,
      0,
      1
    );
    this.flyCameraState.rotation.setFromRotationMatrix(lookAtMatrix);
  }
  dispose() {
    this.disposeEventHandlers();
    this.disposeFlyCameraEventHandlers();
    document.body.style.cursor = "";
  }
  easeOutExpo(x) {
    return x === 1 ? 1 : 1 - Math.pow(2, -10 * x);
  }
  updateAspect(aspect) {
    this.aspect = aspect;
    this.cameraState.aspect = aspect;
    this.flyCameraState.aspect = aspect;
  }
  recomputeFoV(immediately = false) {
    this.targetFOV = remap(
      this.targetDistance,
      this.minDistance,
      this.maxDistance,
      this.invertFOVMapping ? this.minFOV : this.maxFOV,
      this.invertFOVMapping ? this.maxFOV : this.minFOV
    );
    if (immediately) {
      this.fov = this.targetFOV;
    }
  }
  isFlyCameraOn() {
    return this.isMainCameraActive === false;
  }
  toggleFlyCamera() {
    this.isMainCameraActive = !this.isMainCameraActive;
    if (!this.isMainCameraActive) {
      this.updateAspect(window.innerWidth / window.innerHeight);
      this.flyCameraState.position.copy(this.cameraState.position);
      this.flyCameraState.rotation.copy(this.cameraState.rotation);
      this.flyCameraState.fov = this.cameraState.fov;
      this.flyCameraLookAt.copy(this.target);
      const toCamera = new Vect3().copy(this.flyCameraState.position).sub(this.flyCameraLookAt);
      this.flyCameraDistance = toCamera.length();
      if (this.flyCameraDistance > 1e-3) {
        this.flyCameraPitch = Math.acos(toCamera.y / this.flyCameraDistance);
        this.flyCameraYaw = Math.atan2(toCamera.x, toCamera.z);
      } else {
        this.flyCameraDistance = this.distance;
        this.flyCameraPitch = Math.PI * 0.4;
        this.flyCameraYaw = 0;
      }
      this.updateFlyCameraOrbitControls();
      this.disposeEventHandlers();
      this.createFlyCameraEventHandlers();
    } else {
      this.disposeFlyCameraEventHandlers();
      this.createEventHandlers();
    }
  }
  getCameraState() {
    return this.isMainCameraActive ? this.cameraState : this.flyCameraState;
  }
  getMainCameraState() {
    return this.cameraState;
  }
  getFlyCameraState() {
    return this.flyCameraState;
  }
  getCameraPosition() {
    const state = this.getCameraState();
    return state.position;
  }
  getCameraRotation() {
    const state = this.getCameraState();
    return state.rotation;
  }
  getCameraFOV() {
    const state = this.getCameraState();
    return state.fov;
  }
  update(onFlyCameraUpdate) {
    if (!this.isMainCameraActive) {
      this.updateFlyCameraOrbitControls();
      if (onFlyCameraUpdate) {
        onFlyCameraUpdate(this.flyCameraState);
      }
      return;
    }
    if (this.isLerping && this.lerpFactor < 1) {
      this.lerpFactor += 0.01 / this.lerpDuration;
      this.lerpFactor = Math.min(1, this.lerpFactor);
      this.target.lerpVectors(this.lerpTarget, this.finalTarget, this.easeOutExpo(this.lerpFactor));
    } else {
      this.adjustCameraPosition(this.cameraState.position, this.cameraState.rotation);
    }
    this.distance += (this.targetDistance - this.distance) * this.zoomDamping;
    this.theta += (this.targetTheta - this.theta) * this.damping;
    this.phi += (this.targetPhi - this.phi) * this.damping;
    const x = this.target.x + this.distance * Math.sin(this.phi) * Math.cos(this.theta);
    const y = this.target.y + this.distance * Math.cos(this.phi);
    const z = this.target.z + this.distance * Math.sin(this.phi) * Math.sin(this.theta);
    this.recomputeFoV();
    this.fov += (this.targetFOV - this.fov) * this.zoomDamping;
    this.cameraState.position.set(x, y, z);
    this.cameraState.fov = this.fov;
    const lookAtTarget = new Vect3(this.target.x, this.target.y, this.target.z);
    const direction = new Vect3().copy(lookAtTarget).sub(this.cameraState.position).normalize();
    const up = new Vect3(0, 1, 0);
    const right = new Vect3().copy(direction).cross(up).normalize();
    const correctedUp = new Vect3().copy(right).cross(direction).normalize();
    const lookAtMatrix = this.tempMatr4.set(
      right.x,
      correctedUp.x,
      -direction.x,
      0,
      right.y,
      correctedUp.y,
      -direction.y,
      0,
      right.z,
      correctedUp.z,
      -direction.z,
      0,
      0,
      0,
      0,
      1
    );
    this.cameraState.rotation.setFromRotationMatrix(lookAtMatrix);
    if (this.isLerping && this.lerpFactor >= 1) {
      this.isLerping = false;
    }
  }
  hasActiveInput() {
    return this.activePointers.size > 0;
  }
};

// src/character/CharacterManager.ts
import { radToDeg as radToDeg2 } from "@mml-io/mml-web";

// src/character/CharacterState.ts
var AnimationState = /* @__PURE__ */ ((AnimationState2) => {
  AnimationState2[AnimationState2["idle"] = 0] = "idle";
  AnimationState2[AnimationState2["walking"] = 1] = "walking";
  AnimationState2[AnimationState2["running"] = 2] = "running";
  AnimationState2[AnimationState2["jumpToAir"] = 3] = "jumpToAir";
  AnimationState2[AnimationState2["air"] = 4] = "air";
  AnimationState2[AnimationState2["airToGround"] = 5] = "airToGround";
  AnimationState2[AnimationState2["doubleJump"] = 6] = "doubleJump";
  return AnimationState2;
})(AnimationState || {});

// src/character/AnimationMixer.ts
var AnimationMixer = class {
  currentState;
  targetState;
  transitionProgress = 1;
  // 0 to 1, where 1 means transition complete
  transitionDuration = 0.15;
  // Default transition time in seconds
  weights;
  animationTimes;
  constructor(initialState = 0 /* idle */) {
    this.currentState = initialState;
    this.targetState = initialState;
    this.weights = this.createZeroWeights();
    this.weights[initialState] = 1;
    this.animationTimes = this.createZeroTimes();
  }
  /**
   * Set the target animation state. If different from current, begins a transition.
   */
  setTargetState(state) {
    if (this.targetState === state) {
      return;
    }
    if (this.transitionProgress < 1) {
      this.currentState = this.targetState;
    }
    this.targetState = state;
    this.transitionProgress = 0;
    this.animationTimes[state] = 0;
    this.updateWeights();
  }
  /**
   * Update the animation mixer, progressing any active transitions.
   */
  update(deltaTime) {
    for (const state of [
      0 /* idle */,
      1 /* walking */,
      2 /* running */,
      3 /* jumpToAir */,
      4 /* air */,
      5 /* airToGround */,
      6 /* doubleJump */
    ]) {
      if (this.weights[state] > 0) {
        this.animationTimes[state] += deltaTime;
      }
    }
    if (this.transitionProgress >= 1) {
      return;
    }
    this.transitionProgress += deltaTime / this.transitionDuration;
    if (this.transitionProgress >= 1) {
      this.transitionProgress = 1;
      this.currentState = this.targetState;
    }
    this.updateWeights();
  }
  /**
   * Get the current animation weights for rendering.
   */
  getWeights() {
    return this.weights;
  }
  /**
   * Get the animation times for each animation state.
   */
  getAnimationTimes() {
    return this.animationTimes;
  }
  /**
   * Get the primary animation state (the target we're transitioning to, or current if no transition).
   */
  getPrimaryState() {
    return this.targetState;
  }
  /**
   * Returns true if currently transitioning between animations.
   */
  isTransitioning() {
    return this.transitionProgress < 1;
  }
  /**
   * Immediately snap to a state without transitioning.
   */
  snapToState(state) {
    this.currentState = state;
    this.targetState = state;
    this.transitionProgress = 1;
    this.weights = this.createZeroWeights();
    this.weights[state] = 1;
    this.animationTimes = this.createZeroTimes();
  }
  updateWeights() {
    this.weights = this.createZeroWeights();
    if (this.transitionProgress >= 1) {
      this.weights[this.targetState] = 1;
    } else {
      const t = this.easeInOut(this.transitionProgress);
      this.weights[this.currentState] = 1 - t;
      this.weights[this.targetState] = t;
    }
  }
  createZeroWeights() {
    return {
      [0 /* idle */]: 0,
      [1 /* walking */]: 0,
      [2 /* running */]: 0,
      [3 /* jumpToAir */]: 0,
      [4 /* air */]: 0,
      [5 /* airToGround */]: 0,
      [6 /* doubleJump */]: 0
    };
  }
  createZeroTimes() {
    return {
      [0 /* idle */]: 0,
      [1 /* walking */]: 0,
      [2 /* running */]: 0,
      [3 /* jumpToAir */]: 0,
      [4 /* air */]: 0,
      [5 /* airToGround */]: 0,
      [6 /* doubleJump */]: 0
    };
  }
  easeInOut(t) {
    return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
  }
};

// src/character/url-position.ts
var tempQuat = new Quat();
function encodeCharacterAndCamera(character, camera) {
  return [
    ...toArray(character.position),
    ...toArray(tempQuat.setFromEulerXYZ(character.rotation)),
    ...toArray(camera.position),
    ...toArray(tempQuat.setFromEulerXYZ(camera.rotation))
  ].join(",");
}
function decodeCharacterAndCamera(hash) {
  const values = hash.split(",").map(Number);
  return {
    character: {
      position: new Vect3(values[0], values[1], values[2]),
      quaternion: new Quat(values[3], values[4], values[5], values[6])
    },
    camera: {
      position: new Vect3(values[7], values[8], values[9]),
      quaternion: new Quat(values[10], values[11], values[12], values[13])
    }
  };
}

// src/character/Spawning.ts
function randomWithVariance(value, variance) {
  const min = value - variance;
  const max = value + variance;
  return Math.random() * (max - min) + min;
}
function getSpawnData(config, useLocationHash = false) {
  const spawnPosition = new Vect3();
  spawnPosition.set(
    randomWithVariance(config.spawnPosition.x, config.spawnPositionVariance.x),
    randomWithVariance(config.spawnPosition.y, config.spawnPositionVariance.y),
    randomWithVariance(config.spawnPosition.z, config.spawnPositionVariance.z)
  );
  const spawnRotation = new EulXYZ(0, -config.spawnYRotation * (Math.PI / 180), 0);
  let cameraPosition = null;
  const offset = new Vect3(0, 0, 3.3);
  offset.applyEulerXYZ(new EulXYZ(0, spawnRotation.y, 0));
  cameraPosition = spawnPosition.clone().sub(offset).add(CharacterManager.headTargetOffset);
  if (useLocationHash && window.location.hash && window.location.hash.length > 1) {
    const urlParams = decodeCharacterAndCamera(window.location.hash.substring(1));
    spawnPosition.copy(urlParams.character.position);
    spawnRotation.setFromQuaternion(urlParams.character.quaternion);
    cameraPosition = new Vect3().copy(urlParams.camera.position);
  }
  return {
    spawnPosition,
    spawnRotation,
    cameraPosition
  };
}

// src/character/LocalController.ts
var downVector = new Vect3(0, -1, 0);
var LocalController = class {
  capsuleInfo = {
    radius: 0.45,
    segment: new Line(new Vect3(), new Vect3(0, 1.05, 0))
  };
  gravity;
  jumpForce;
  doubleJumpForce;
  coyoteTimeThreshold;
  canJump = true;
  canDoubleJump = true;
  coyoteJumped = false;
  doubleJumpUsed = false;
  jumpCounter = 0;
  airResistance;
  groundResistance;
  airControlModifier;
  groundWalkControl;
  groundRunControl;
  baseControl;
  minimumSurfaceAngle;
  latestPosition = new Vect3();
  characterOnGround = false;
  coyoteTime = false;
  collisionDetectionSteps = 15;
  characterWasOnGround = false;
  characterAirborneSince = 0;
  currentHeight = 0;
  currentSurfaceAngle = new Vect3();
  characterVelocity = new Vect3();
  vectorUp = new Vect3(0, 1, 0);
  vectorDown = new Vect3(0, -1, 0);
  rotationOffset = 0;
  azimuthalAngle = 0;
  tempSegment = new Line();
  tempQuat = new Quat();
  tempEulXYZ = new EulXYZ();
  tempVector = new Vect3();
  tempVector2 = new Vect3();
  tempVect3 = new Vect3();
  tempRay = new Ray();
  tempCameraPos = new Vect3();
  tempPositionCopy = new Vect3();
  surfaceTempQuat = new Quat();
  surfaceTempQuat2 = new Quat();
  surfaceTempVector1 = new Vect3();
  surfaceTempVector2 = new Vect3();
  surfaceTempVect3 = new Vect3();
  surfaceTempVector4 = new Vect3();
  surfaceTempVector5 = new Vect3();
  surfaceTempRay = new Ray();
  lastMatrixTemp = new Matr4();
  lastFrameSurfaceState = null;
  surfaceIsMoving = false;
  jumpReleased = true;
  // Indicates if the jump button has been released
  /** Returns true if the character is currently on a moving surface (e.g., a rotating platform) */
  isOnMovingSurface() {
    return this.surfaceIsMoving;
  }
  networkState;
  config;
  controlState = null;
  minimumX;
  maximumX;
  minimumY;
  maximumY;
  minimumZ;
  maximumZ;
  constructor(config) {
    this.config = config;
    this.gravity = -config.characterControllerValues.gravity;
    this.jumpForce = config.characterControllerValues.jumpForce;
    this.doubleJumpForce = config.characterControllerValues.doubleJumpForce;
    this.coyoteTimeThreshold = config.characterControllerValues.coyoteJump;
    this.airResistance = config.characterControllerValues.airResistance;
    this.groundResistance = 0.99999999 + config.characterControllerValues.groundResistance * 1e-7;
    this.airControlModifier = config.characterControllerValues.airControlModifier;
    this.groundWalkControl = config.characterControllerValues.groundWalkControl;
    this.groundRunControl = config.characterControllerValues.groundRunControl;
    this.baseControl = config.characterControllerValues.baseControlMultiplier;
    this.minimumSurfaceAngle = config.characterControllerValues.minimumSurfaceAngle;
    this.networkState = {
      position: { x: 0, y: 0, z: 0 },
      rotation: { quaternionY: 0, quaternionW: 1 },
      state: 0 /* idle */
    };
    this.minimumX = this.config.spawnConfiguration.respawnTrigger.minX;
    this.maximumX = this.config.spawnConfiguration.respawnTrigger.maxX;
    this.minimumY = this.config.spawnConfiguration.respawnTrigger.minY;
    this.maximumY = this.config.spawnConfiguration.respawnTrigger.maxY;
    this.minimumZ = this.config.spawnConfiguration.respawnTrigger.minZ;
    this.maximumZ = this.config.spawnConfiguration.respawnTrigger.maxZ;
    const maxAbsSpawnX = Math.abs(this.config.spawnConfiguration.spawnPosition.x) + Math.abs(this.config.spawnConfiguration.spawnPositionVariance.x);
    const maxAbsSpawnY = Math.abs(this.config.spawnConfiguration.spawnPosition.y) + Math.abs(this.config.spawnConfiguration.spawnPositionVariance.y);
    const maxAbsSpawnZ = Math.abs(this.config.spawnConfiguration.spawnPosition.z) + Math.abs(this.config.spawnConfiguration.spawnPositionVariance.z);
    if (Math.abs(this.minimumX) < maxAbsSpawnX || Math.abs(this.maximumX) < maxAbsSpawnX) {
      this.minimumX = -maxAbsSpawnX - 1;
      this.maximumX = maxAbsSpawnX + 1;
      console.warn(
        "The respawnTrigger X values are out of the bounds of the spawnPosition + spawnPositionVariance. Please check your respawnTrigger config."
      );
    }
    if (Math.abs(this.minimumY) < maxAbsSpawnY || Math.abs(this.maximumY) < maxAbsSpawnY) {
      this.minimumY = -maxAbsSpawnY - 1;
      this.maximumY = maxAbsSpawnY + 1;
      console.warn(
        "The respawnTrigger Y values are out of the bounds of the spawnPosition + spawnPositionVariance. Please check your respawnTrigger config."
      );
    }
    if (Math.abs(this.minimumZ) < maxAbsSpawnZ) {
      this.minimumZ = -maxAbsSpawnZ - 1;
      this.maximumZ = maxAbsSpawnZ + 1;
      console.warn(
        "The respawnTrigger Z values are out of the bounds of the spawnPosition + spawnPositionVariance. Please check your respawnTrigger config."
      );
    }
  }
  updateSpawnConfig(spawnConfig) {
    this.config.spawnConfiguration = spawnConfig;
    this.minimumX = spawnConfig.respawnTrigger.minX;
    this.maximumX = spawnConfig.respawnTrigger.maxX;
    this.minimumY = spawnConfig.respawnTrigger.minY;
    this.maximumY = spawnConfig.respawnTrigger.maxY;
    this.minimumZ = spawnConfig.respawnTrigger.minZ;
    this.maximumZ = spawnConfig.respawnTrigger.maxZ;
  }
  update(deltaTime) {
    var _a;
    this.controlState = this.config.keyInputManager.getOutput() || ((_a = this.config.virtualJoystick) == null ? void 0 : _a.getOutput()) || null;
    this.tempRay.set(this.config.position, this.vectorDown);
    this.tempRay.origin.y += this.capsuleInfo.radius;
    const firstRaycastHit = this.config.collisionsManager.raycastFirst(this.tempRay);
    if (firstRaycastHit !== null) {
      this.currentHeight = firstRaycastHit[0];
      this.currentSurfaceAngle.copy(firstRaycastHit[1]);
    } else {
      this.currentHeight = Number.POSITIVE_INFINITY;
    }
    if (this.controlState) {
      this.updateRotation(deltaTime);
    }
    for (let i = 0; i < this.collisionDetectionSteps; i++) {
      this.updatePosition(deltaTime, deltaTime / this.collisionDetectionSteps, i);
    }
    const outOfBounds = this.config.position.x < this.minimumX || // left
    this.config.position.x > this.maximumX || // right
    this.config.position.z < this.minimumZ || // back
    this.config.position.z > this.maximumZ || // front
    this.config.position.y < this.minimumY || // down
    this.config.position.y > this.maximumY;
    if (outOfBounds) {
      this.resetPosition();
    }
    this.updateNetworkState();
  }
  getTargetAnimation() {
    const jumpHeight = this.characterVelocity.y > 0 ? 0.2 : 1.8;
    if (this.currentHeight > jumpHeight && !this.characterOnGround) {
      if (this.doubleJumpUsed) {
        return 6 /* doubleJump */;
      }
      return 4 /* air */;
    }
    if (!this.controlState || this.controlState.direction === null) {
      return 0 /* idle */;
    }
    if (this.controlState.isSprinting) {
      return 2 /* running */;
    }
    return 1 /* walking */;
  }
  updateRotationOffset() {
    if (this.controlState && this.controlState.direction !== null) {
      this.rotationOffset = this.controlState.direction;
    }
  }
  updateAzimuthalAngle() {
    const cameraPos = this.tempCameraPos.copy(this.config.cameraManager.getCameraPosition());
    const camToModelDistance = cameraPos.distanceTo(
      this.tempPositionCopy.copy(this.config.position)
    );
    const isCameraFirstPerson = camToModelDistance < 2;
    if (isCameraFirstPerson) {
      const cameraRotation = this.config.cameraManager.getCameraRotation();
      const cameraForward = this.tempVector.set(0, 0, 1).applyQuat(cameraRotation);
      this.azimuthalAngle = Math.atan2(cameraForward.x, cameraForward.z);
    } else {
      const cameraPos2 = this.config.cameraManager.getCameraPosition();
      this.azimuthalAngle = Math.atan2(
        cameraPos2.x - this.config.position.x,
        cameraPos2.z - this.config.position.z
      );
    }
  }
  computeAngularDifference(rotationQuat) {
    const rotation = new Quat().copy(this.config.quaternion);
    return 2 * Math.acos(Math.abs(rotation.dot(rotationQuat)));
  }
  updateRotation(deltaTime) {
    this.updateRotationOffset();
    this.updateAzimuthalAngle();
    const rotationQuat = this.tempQuat.setFromAxisAngle(
      this.vectorUp,
      this.azimuthalAngle + this.rotationOffset
    );
    const angularDifference = this.computeAngularDifference(rotationQuat);
    const desiredTime = 0.07;
    const angularSpeed = angularDifference / desiredTime;
    const frameRotation = angularSpeed * deltaTime;
    this.config.quaternion.rotateTowards(rotationQuat, frameRotation);
  }
  processJump(currentAcceleration, deltaTime) {
    var _a;
    const jump = (_a = this.controlState) == null ? void 0 : _a.jump;
    if (this.characterOnGround) {
      this.coyoteJumped = false;
      this.canDoubleJump = false;
      this.doubleJumpUsed = false;
      this.jumpCounter = 0;
      if (!jump) {
        this.canDoubleJump = !this.doubleJumpUsed && this.jumpReleased && this.jumpCounter === 1;
        this.canJump = true;
        this.jumpReleased = true;
      }
      if (jump && this.canJump && this.jumpReleased) {
        currentAcceleration.y += this.jumpForce / deltaTime;
        this.canJump = false;
        this.jumpReleased = false;
        this.jumpCounter++;
      } else {
        if (this.currentSurfaceAngle.y < this.minimumSurfaceAngle) {
          currentAcceleration.y += this.gravity;
        }
      }
    } else {
      if (jump && !this.coyoteJumped && this.coyoteTime) {
        this.coyoteJumped = true;
        currentAcceleration.y += this.jumpForce / deltaTime;
        this.canJump = false;
        this.jumpReleased = false;
        this.jumpCounter++;
      } else if (jump && this.canDoubleJump) {
        currentAcceleration.y += this.doubleJumpForce / deltaTime;
        this.doubleJumpUsed = true;
        this.jumpReleased = false;
        this.jumpCounter++;
      } else {
        currentAcceleration.y += this.gravity;
        this.canJump = false;
      }
    }
    if (!jump) {
      this.jumpReleased = true;
      if (!this.characterOnGround) {
        currentAcceleration.y += this.gravity;
      }
    }
  }
  applyControls(stepDeltaTime) {
    var _a;
    const resistance = this.characterOnGround ? this.groundResistance : this.airResistance;
    const speedFactor = Math.pow(1 - resistance, stepDeltaTime);
    this.characterVelocity.multiplyScalar(speedFactor);
    const acceleration = this.tempVector.set(0, 0, 0);
    this.canDoubleJump = !this.doubleJumpUsed && this.jumpReleased && this.jumpCounter === 1;
    this.processJump(acceleration, stepDeltaTime);
    const control = (this.characterOnGround ? ((_a = this.controlState) == null ? void 0 : _a.isSprinting) ? this.groundRunControl : this.groundWalkControl : this.airControlModifier) * this.baseControl;
    const controlAcceleration = this.tempVector2.set(0, 0, 0);
    if (this.controlState && this.controlState.direction !== null) {
      const heading = this.controlState.direction;
      const headingVector = this.tempVect3.set(0, 0, 1).applyAxisAngle(this.vectorUp, this.azimuthalAngle + heading);
      controlAcceleration.add(headingVector);
    }
    if (controlAcceleration.lengthSquared() > 0) {
      controlAcceleration.normalize();
      controlAcceleration.multiplyScalar(control);
    }
    acceleration.add(controlAcceleration);
    this.characterVelocity.addScaledVector(acceleration, stepDeltaTime);
    this.config.position.addScaledVector(this.characterVelocity, stepDeltaTime);
  }
  updatePosition(deltaTime, stepDeltaTime, iter) {
    var _a;
    this.applyControls(stepDeltaTime);
    if (iter === 0) {
      const lastMovement = this.getMovementFromSurfaces(this.config.position, deltaTime);
      if (lastMovement) {
        const newPosition = this.tempVector.copy(this.config.position);
        newPosition.add(lastMovement.position);
        this.config.position.set(newPosition.x, newPosition.y, newPosition.z);
        const asQuat = this.config.quaternion;
        const lastMovementEulXYZ = this.tempEulXYZ.setFromQuaternion(lastMovement.rotation);
        lastMovementEulXYZ.x = 0;
        lastMovementEulXYZ.z = 0;
        lastMovement.rotation.setFromEulerXYZ(lastMovementEulXYZ);
        asQuat.multiply(lastMovement.rotation);
      }
    }
    const avatarSegment = this.tempSegment;
    avatarSegment.copy(this.capsuleInfo.segment);
    avatarSegment.start.add(this.config.position);
    avatarSegment.start.y += this.capsuleInfo.radius;
    avatarSegment.end.add(this.config.position);
    avatarSegment.end.y += this.capsuleInfo.radius;
    const positionBeforeCollisions = this.tempVector.copy(avatarSegment.start);
    this.config.collisionsManager.applyColliders(avatarSegment, this.capsuleInfo.radius);
    const capsuleLength = this.capsuleInfo.segment.end.y - this.capsuleInfo.segment.start.y + this.capsuleInfo.radius * 2;
    this.tempRay.set(avatarSegment.start, this.vectorDown);
    const endIgnoreLength = 0.1;
    this.tempRay.origin.y += -this.capsuleInfo.radius + capsuleLength - endIgnoreLength;
    const withinCapsuleRayHit = this.config.collisionsManager.raycastFirst(
      this.tempRay,
      capsuleLength - endIgnoreLength * 2
    );
    if (withinCapsuleRayHit !== null) {
      const rayHitPosition = withinCapsuleRayHit[3];
      avatarSegment.start.copy(rayHitPosition);
      avatarSegment.start.y += this.capsuleInfo.radius;
    }
    this.config.position.set(
      avatarSegment.start.x,
      avatarSegment.start.y - this.capsuleInfo.radius,
      avatarSegment.start.z
    );
    const deltaCollisionPosition = avatarSegment.start.sub(positionBeforeCollisions);
    this.characterOnGround = deltaCollisionPosition.y > 0;
    if (this.characterOnGround) {
      this.doubleJumpUsed = false;
      this.jumpCounter = 0;
    }
    if (this.characterWasOnGround && !this.characterOnGround) {
      this.characterAirborneSince = Date.now();
    }
    if (!((_a = this.controlState) == null ? void 0 : _a.jump)) {
      this.jumpReleased = true;
    }
    this.coyoteTime = this.characterVelocity.y < 0 && !this.characterOnGround && Date.now() - this.characterAirborneSince < this.coyoteTimeThreshold;
    this.latestPosition.copy(this.config.position);
    this.characterWasOnGround = this.characterOnGround;
  }
  getMovementFromSurfaces(userPosition, deltaTime) {
    let lastMovement = null;
    if (this.lastFrameSurfaceState !== null) {
      const meshState = this.lastFrameSurfaceState[0];
      const currentFrameMatrix = meshState.matrix;
      const lastFrameMatrix = this.lastFrameSurfaceState[1].lastMatrix;
      if (lastFrameMatrix.equals(currentFrameMatrix)) {
        this.surfaceIsMoving = false;
      } else {
        this.surfaceIsMoving = true;
        const lastMeshPosition = this.surfaceTempVector1;
        const lastMeshRotation = this.surfaceTempQuat;
        lastFrameMatrix.decompose(lastMeshPosition, lastMeshRotation, this.surfaceTempVect3);
        const currentMeshPosition = this.surfaceTempVector2;
        const currentMeshRotation = this.surfaceTempQuat2;
        currentFrameMatrix.decompose(
          currentMeshPosition,
          currentMeshRotation,
          this.surfaceTempVect3
        );
        const meshTranslationDelta = this.surfaceTempVector5.copy(currentMeshPosition).sub(lastMeshPosition);
        const lastFrameRelativeUserPosition = this.surfaceTempVect3.copy(userPosition).sub(lastMeshPosition);
        const meshRotationDelta = currentMeshRotation.multiply(lastMeshRotation.invert());
        const translationDueToRotation = this.surfaceTempVector4.copy(lastFrameRelativeUserPosition).applyQuat(meshRotationDelta).sub(lastFrameRelativeUserPosition);
        const translationAndRotationPositionDelta = this.surfaceTempVector1.copy(meshTranslationDelta).add(translationDueToRotation);
        lastMovement = {
          position: translationAndRotationPositionDelta,
          rotation: meshRotationDelta
        };
        lastFrameMatrix.copy(currentFrameMatrix);
      }
    }
    const newPosition = this.surfaceTempVect3.copy(userPosition);
    if (lastMovement) {
      newPosition.add(lastMovement.position);
    }
    newPosition.y = newPosition.y + 0.05;
    const ray = this.surfaceTempRay.set(newPosition, downVector);
    const hit = this.config.collisionsManager.raycastFirst(ray);
    if (hit && hit[0] < 0.8) {
      const currentCollisionMeshState = hit[2];
      this.lastFrameSurfaceState = [
        currentCollisionMeshState,
        { lastMatrix: this.lastMatrixTemp.copy(currentCollisionMeshState.matrix) }
      ];
    } else {
      if (this.lastFrameSurfaceState !== null && lastMovement) {
        this.characterVelocity.add(
          lastMovement.position.clone().multiplyScalar(1 / deltaTime)
          // The position delta is the result of one tick which is deltaTime seconds, so we need to divide by deltaTime to get the velocity per second
        );
      }
      this.lastFrameSurfaceState = null;
      this.surfaceIsMoving = false;
    }
    return lastMovement;
  }
  updateNetworkState() {
    const characterPosition = this.config.position;
    const characterQuat = this.config.quaternion;
    this.networkState = {
      position: {
        x: characterPosition.x,
        y: characterPosition.y,
        z: characterPosition.z
      },
      rotation: { quaternionY: characterQuat.y, quaternionW: characterQuat.w },
      state: this.getTargetAnimation()
    };
  }
  resetPosition() {
    this.characterVelocity.x = 0;
    this.characterVelocity.y = 0;
    this.characterVelocity.z = 0;
    this.characterOnGround = false;
    this.doubleJumpUsed = false;
    this.jumpReleased = true;
    this.jumpCounter = 0;
    const spawnData = getSpawnData(this.config.spawnConfiguration, false);
    this.config.position.set(
      spawnData.spawnPosition.x,
      spawnData.spawnPosition.y,
      spawnData.spawnPosition.z
    );
    this.config.quaternion.setFromEulerXYZ(spawnData.spawnRotation);
  }
};

// src/character/RemoteController.ts
var tempQuaternion2 = new Quat();
var RemoteController = class {
  // Current interpolated state
  position;
  rotation;
  animationState;
  hasReceivedInitialUpdate = false;
  interpolationRate = 8;
  // How quickly to interpolate (higher = faster)
  cachedTargetPos = new Vect3();
  constructor(initialPosition, initialRotation, initialAnimation) {
    this.position = new Vect3(initialPosition.x, initialPosition.y, initialPosition.z);
    this.rotation = new Quat().setFromEulerXYZ(initialRotation);
    this.animationState = initialAnimation;
  }
  update(networkUpdate, deltaTime) {
    const { position, rotation, state } = networkUpdate;
    const targetPos = this.cachedTargetPos.set(position.x, position.y, position.z);
    const targetRotQuat = tempQuaternion2.set(0, rotation.quaternionY, 0, rotation.quaternionW);
    if (!this.hasReceivedInitialUpdate) {
      this.position.set(targetPos.x, targetPos.y, targetPos.z);
      this.rotation.set(targetRotQuat.x, targetRotQuat.y, targetRotQuat.z, targetRotQuat.w);
      this.animationState = state;
      this.hasReceivedInitialUpdate = true;
    } else {
      const distSq = this.position.distanceToSquared(targetPos);
      if (distSq > 5 * 5) {
        this.position.set(targetPos.x, targetPos.y, targetPos.z);
      } else {
        const lerpFactor2 = Math.min(1, 1 - Math.exp(-this.interpolationRate * deltaTime));
        this.position.lerp(targetPos, lerpFactor2);
      }
      const lerpFactor = Math.min(1, 1 - Math.exp(-this.interpolationRate * deltaTime));
      this.rotation.slerp(targetRotQuat, lerpFactor);
      this.animationState = state;
    }
  }
  getRotationEuler() {
    return new EulXYZ().setFromQuaternion(this.rotation);
  }
};

// src/character/CharacterManager.ts
var CharacterManager = class _CharacterManager {
  constructor(config) {
    this.config = config;
  }
  static headTargetOffset = new Vect3(0, 1.75, 0);
  localClientId = 0;
  remoteCharacters = /* @__PURE__ */ new Map();
  localController = null;
  localRenderState = null;
  localAnimationMixer = null;
  lastUpdateSentTime = 0;
  tempCameraTarget = new Vect3();
  cachedCharacterStates = /* @__PURE__ */ new Map();
  pendingDescriptionUpdates = /* @__PURE__ */ new Set();
  pendingRemovals = /* @__PURE__ */ new Set();
  /**
   * Sets the local client ID early to prevent the local character from being
   * spawned as a remote character when network updates arrive before spawnLocalCharacter is called.
   */
  setLocalClientId(id) {
    this.localClientId = id;
  }
  spawnLocalCharacter(id, spawnPosition = new Vect3(), spawnRotation = new EulXYZ()) {
    const position = new Vect3(spawnPosition.x, spawnPosition.y, spawnPosition.z);
    const quaternion = new Quat().setFromEulerXYZ(spawnRotation);
    this.config.sendUpdate({
      position: {
        x: spawnPosition.x,
        y: spawnPosition.y,
        z: spawnPosition.z
      },
      rotation: { quaternionY: quaternion.y, quaternionW: quaternion.w },
      state: 0 /* idle */
    });
    this.localClientId = id;
    this.localController = new LocalController({
      id: this.localClientId,
      position,
      quaternion,
      collisionsManager: this.config.collisionsManager,
      keyInputManager: this.config.keyInputManager,
      virtualJoystick: this.config.virtualJoystick,
      cameraManager: this.config.cameraManager,
      spawnConfiguration: this.config.spawnConfiguration,
      characterControllerValues: this.config.characterControllerValues
    });
    const characterInfo = this.config.characterResolve(this.localClientId);
    const rotation = new EulXYZ().setFromQuaternion(quaternion);
    this.localAnimationMixer = new AnimationMixer(0 /* idle */);
    this.localRenderState = {
      id: this.localClientId,
      position: new Vect3(position.x, position.y, position.z),
      rotation,
      animationState: 0 /* idle */,
      animationWeights: this.localAnimationMixer.getWeights(),
      animationTimes: this.localAnimationMixer.getAnimationTimes(),
      username: characterInfo.username ?? `Unknown User ${this.localClientId}`,
      characterDescription: characterInfo.characterDescription,
      colors: characterInfo.colors,
      isLocal: true
    };
    this.cachedCharacterStates.set(this.localClientId, this.localRenderState);
  }
  setupTweakPane(tweakPane) {
    if (this.localController) {
      tweakPane.setupCharacterController(this.localController);
    }
  }
  getLocalCharacterPositionAndRotation() {
    if (this.localController) {
      const rotation = this.localController.config.quaternion;
      return {
        position: this.localController.config.position,
        rotation: {
          x: radToDeg2(rotation.x),
          y: radToDeg2(rotation.y),
          z: radToDeg2(rotation.z)
        }
      };
    }
    return {
      position: { x: 0, y: 0, z: 0 },
      rotation: { x: 0, y: 0, z: 0 }
    };
  }
  clear() {
    for (const [id] of this.remoteCharacters) {
      this.pendingRemovals.add(id);
    }
    if (this.localClientId !== 0) {
      this.pendingRemovals.add(this.localClientId);
    }
    this.remoteCharacters.clear();
    this.cachedCharacterStates.clear();
    this.localRenderState = null;
    if (this.localController) {
      this.localController = null;
    }
  }
  dispose() {
    this.clear();
    this.localController = null;
  }
  networkCharacterInfoUpdated(id) {
    const remoteChar = this.remoteCharacters.get(id);
    if (remoteChar) {
      const characterInfo = this.config.characterResolve(id);
      const newUsername = characterInfo.username ?? `Unknown User ${id}`;
      const descriptionChanged = remoteChar.lastUsername !== newUsername || remoteChar.lastCharacterDescription !== characterInfo.characterDescription || remoteChar.lastColors !== characterInfo.colors;
      remoteChar.lastUsername = newUsername;
      remoteChar.lastCharacterDescription = characterInfo.characterDescription;
      remoteChar.lastColors = characterInfo.colors;
      if (remoteChar.renderState) {
        remoteChar.renderState.username = remoteChar.lastUsername;
        remoteChar.renderState.characterDescription = remoteChar.lastCharacterDescription;
        remoteChar.renderState.colors = remoteChar.lastColors;
      }
      if (descriptionChanged) {
        this.pendingDescriptionUpdates.add(id);
      }
    }
    if (id === this.localClientId && this.localRenderState) {
      const characterInfo = this.config.characterResolve(id);
      const newUsername = characterInfo.username ?? `Unknown User ${id}`;
      const descriptionChanged = this.localRenderState.username !== newUsername || this.localRenderState.characterDescription !== characterInfo.characterDescription || this.localRenderState.colors !== characterInfo.colors;
      this.localRenderState.username = newUsername;
      this.localRenderState.characterDescription = characterInfo.characterDescription;
      this.localRenderState.colors = characterInfo.colors;
      if (descriptionChanged) {
        this.pendingDescriptionUpdates.add(id);
      }
    }
  }
  update(deltaTime, frameCounter) {
    const updatedCharacterDescriptions = [];
    const removedUserIds = [];
    for (const id of this.pendingRemovals) {
      removedUserIds.push(id);
    }
    this.pendingRemovals.clear();
    for (const id of this.pendingDescriptionUpdates) {
      updatedCharacterDescriptions.push(id);
    }
    this.pendingDescriptionUpdates.clear();
    if (this.localController && this.localRenderState && this.localAnimationMixer) {
      this.localController.update(deltaTime);
      this.localRenderState.position.set(
        this.localController.config.position.x,
        this.localController.config.position.y,
        this.localController.config.position.z
      );
      const quat = this.localController.config.quaternion;
      this.localRenderState.rotation.setFromQuaternion(new Quat(quat.x, quat.y, quat.z, quat.w));
      const targetAnimation = this.localController.getTargetAnimation();
      this.localAnimationMixer.setTargetState(targetAnimation);
      this.localAnimationMixer.update(deltaTime);
      this.localRenderState.animationState = this.localAnimationMixer.getPrimaryState();
      this.localRenderState.animationWeights = this.localAnimationMixer.getWeights();
      this.localRenderState.animationTimes = this.localAnimationMixer.getAnimationTimes();
      const characterInfo = this.config.characterResolve(this.localClientId);
      const newUsername = characterInfo.username ?? `Unknown User ${this.localClientId}`;
      if (this.localRenderState.username !== newUsername || this.localRenderState.characterDescription !== characterInfo.characterDescription || this.localRenderState.colors !== characterInfo.colors) {
        this.localRenderState.username = newUsername;
        this.localRenderState.characterDescription = characterInfo.characterDescription;
        this.localRenderState.colors = characterInfo.colors;
        updatedCharacterDescriptions.push(this.localClientId);
      }
      const currentTime = (/* @__PURE__ */ new Date()).getTime();
      const timeSinceLastUpdate = currentTime - this.lastUpdateSentTime;
      if (timeSinceLastUpdate > 30) {
        this.lastUpdateSentTime = currentTime;
        this.config.sendUpdate(this.localController.networkState);
      }
      const targetOffset = this.tempCameraTarget.set(0, 0, 0).add(_CharacterManager.headTargetOffset).applyQuat(this.localController.config.quaternion).add(this.localController.config.position);
      this.config.cameraManager.setTarget(targetOffset);
      if (this.config.updateURLLocation && frameCounter % 60 === 0 && document.hasFocus() && !this.config.cameraManager.hasActiveInput() && !this.localController.isOnMovingSurface()) {
        const cameraState = this.config.cameraManager.getCameraState();
        const cameraRotation = new EulXYZ().setFromQuaternion(cameraState.rotation);
        const hash = encodeCharacterAndCamera(
          {
            position: this.localController.config.position,
            rotation: new EulXYZ().setFromQuaternion(this.localController.config.quaternion)
          },
          {
            position: cameraState.position,
            rotation: cameraRotation
          }
        );
        const url = new URL(window.location.href);
        url.hash = hash;
        window.history.replaceState({}, "", url);
      }
    }
    for (const [id, networkUpdate] of this.config.remoteUserStates) {
      if (id === this.localClientId) {
        continue;
      }
      let existingCharacter = this.remoteCharacters.get(id);
      if (!existingCharacter) {
        const { position } = networkUpdate;
        const initialRotation = new EulXYZ().setFromQuaternion(
          new Quat(0, networkUpdate.rotation.quaternionY, 0, networkUpdate.rotation.quaternionW)
        );
        const characterInfo = this.config.characterResolve(id);
        const controller = new RemoteController(
          new Vect3(position.x, position.y, position.z),
          initialRotation,
          networkUpdate.state
        );
        const animationMixer = new AnimationMixer(networkUpdate.state);
        const cachedRotation = new EulXYZ();
        cachedRotation.setFromQuaternion(controller.rotation);
        const renderState = {
          id,
          position: new Vect3(controller.position.x, controller.position.y, controller.position.z),
          rotation: cachedRotation,
          animationState: controller.animationState,
          animationWeights: animationMixer.getWeights(),
          animationTimes: animationMixer.getAnimationTimes(),
          username: characterInfo.username ?? `Unknown User ${id}`,
          characterDescription: characterInfo.characterDescription,
          colors: characterInfo.colors,
          isLocal: false
        };
        existingCharacter = {
          id,
          controller,
          animationMixer,
          lastUsername: renderState.username,
          lastCharacterDescription: renderState.characterDescription,
          lastColors: renderState.colors,
          renderState
        };
        this.remoteCharacters.set(id, existingCharacter);
        this.cachedCharacterStates.set(id, renderState);
      } else {
        existingCharacter.controller.update(networkUpdate, deltaTime);
        existingCharacter.animationMixer.setTargetState(
          existingCharacter.controller.animationState
        );
        existingCharacter.animationMixer.update(deltaTime);
        existingCharacter.renderState.position.set(
          existingCharacter.controller.position.x,
          existingCharacter.controller.position.y,
          existingCharacter.controller.position.z
        );
        existingCharacter.renderState.rotation.setFromQuaternion(
          existingCharacter.controller.rotation
        );
        existingCharacter.renderState.animationState = existingCharacter.animationMixer.getPrimaryState();
        existingCharacter.renderState.animationWeights = existingCharacter.animationMixer.getWeights();
        existingCharacter.renderState.animationTimes = existingCharacter.animationMixer.getAnimationTimes();
        const characterInfo = this.config.characterResolve(id);
        const newUsername = characterInfo.username ?? `Unknown User ${id}`;
        if (existingCharacter.lastUsername !== newUsername || existingCharacter.lastCharacterDescription !== characterInfo.characterDescription || existingCharacter.lastColors !== characterInfo.colors) {
          existingCharacter.lastUsername = newUsername;
          existingCharacter.lastCharacterDescription = characterInfo.characterDescription;
          existingCharacter.lastColors = characterInfo.colors;
          existingCharacter.renderState.username = newUsername;
          existingCharacter.renderState.characterDescription = characterInfo.characterDescription;
          existingCharacter.renderState.colors = characterInfo.colors;
          updatedCharacterDescriptions.push(id);
        }
      }
    }
    for (const [id] of this.remoteCharacters) {
      if (!this.config.remoteUserStates.has(id)) {
        removedUserIds.push(id);
        this.remoteCharacters.delete(id);
        this.cachedCharacterStates.delete(id);
      }
    }
    return {
      updatedCharacterDescriptions,
      removedUserIds
    };
  }
  getAllCharacterStates() {
    return this.cachedCharacterStates;
  }
  getLocalClientId() {
    return this.localClientId;
  }
};

// src/input/KeyInputManager.ts
var Key = /* @__PURE__ */ ((Key2) => {
  Key2["W"] = "w";
  Key2["A"] = "a";
  Key2["S"] = "s";
  Key2["D"] = "d";
  Key2["SHIFT"] = "shift";
  Key2["SPACE"] = " ";
  Key2["C"] = "c";
  return Key2;
})(Key || {});
var KeyInputManager = class {
  constructor(shouldCaptureKeyPress = () => true) {
    this.shouldCaptureKeyPress = shouldCaptureKeyPress;
    this.eventHandlerCollection.add(document, "keydown", this.onKeyDown.bind(this));
    this.eventHandlerCollection.add(document, "keyup", this.onKeyUp.bind(this));
    this.eventHandlerCollection.add(window, "blur", this.handleUnfocus.bind(this));
  }
  keys = /* @__PURE__ */ new Map();
  eventHandlerCollection = new EventHandlerCollection();
  bindings = /* @__PURE__ */ new Map();
  handleUnfocus(_event) {
    this.keys.clear();
  }
  onKeyDown(event) {
    if (this.shouldCaptureKeyPress()) {
      if (event.key.length === 2 && event.key[0] === "F") {
        return;
      }
      if (event.metaKey) {
        return;
      }
      this.keys.set(event.key.toLowerCase(), true);
      event.preventDefault();
    }
  }
  onKeyUp(event) {
    this.keys.set(event.key.toLowerCase(), false);
    if (this.bindings.has(event.key.toLowerCase())) {
      this.bindings.get(event.key.toLowerCase())();
    }
  }
  isKeyPressed(key) {
    return this.keys.get(key) || false;
  }
  createKeyBinding(key, callback) {
    if (this.bindings.has(key)) {
      return;
    }
    this.bindings.set(key, callback);
  }
  removeKeyBinding(key) {
    if (!this.bindings.has(key)) {
      return;
    }
    this.bindings.delete(key);
  }
  isMovementKeyPressed() {
    return ["w" /* W */, "a" /* A */, "s" /* S */, "d" /* D */].some((key) => this.isKeyPressed(key));
  }
  getForward() {
    return this.isKeyPressed("w" /* W */);
  }
  getBackward() {
    return this.isKeyPressed("s" /* S */);
  }
  getLeft() {
    return this.isKeyPressed("a" /* A */);
  }
  getRight() {
    return this.isKeyPressed("d" /* D */);
  }
  getRun() {
    return this.isKeyPressed("shift" /* SHIFT */);
  }
  getJump() {
    return this.isKeyPressed(" " /* SPACE */);
  }
  getOutput() {
    const dx = (this.getRight() ? 1 : 0) - (this.getLeft() ? 1 : 0);
    const dy = (this.getBackward() ? 1 : 0) - (this.getForward() ? 1 : 0);
    const jump = this.getJump();
    if (dx === 0 && dy === 0) {
      if (this.getJump()) {
        return { direction: null, isSprinting: false, jump };
      }
      return null;
    }
    const direction = Math.atan2(dx, dy);
    return { direction, isSprinting: this.getRun(), jump };
  }
  dispose() {
    this.eventHandlerCollection.clear();
    this.bindings.clear();
  }
};

// src/input/VirtualJoystick.ts
var sprintingThreshold = 0.6;
var VirtualJoystick = class _VirtualJoystick {
  constructor(holderElement, config) {
    this.holderElement = holderElement;
    this.config = config;
    this.radius = config.radius || 50;
    this.innerRadius = config.innerRadius || this.radius / 2;
    this.mouseSupport = this.checkTouch() || config.mouseSupport === true;
    this.element = document.createElement("div");
    const style = this.element.style;
    style.display = this.mouseSupport ? "flex" : "none";
    style.position = "absolute";
    style.width = `100%`;
    style.height = `200px`;
    style.bottom = "50px";
    style.zIndex = "10000";
    style.alignItems = "center";
    style.justifyContent = "space-between";
    style.pointerEvents = "none";
    style.padding = "20px";
    style.boxSizing = "border-box";
    style.userSelect = "none";
    this.holderElement.appendChild(this.element);
    this.joystickBaseElement = this.createBase();
    this.element.appendChild(this.joystickBaseElement);
    this.joystickCenterElement = this.createCenter();
    this.joystickBaseElement.appendChild(this.joystickCenterElement);
    this.jumpButton = this.createJumpButton();
    this.element.appendChild(this.jumpButton);
    this.bindEvents();
    this.clearJoystickState();
  }
  radius;
  innerRadius;
  mouseSupport;
  element;
  joystickBaseElement;
  joystickCenterElement;
  joystickPointerId = null;
  joystickOutput = null;
  jumpButton;
  jumpPointerId = null;
  static checkForTouch() {
    try {
      document.createEvent("TouchEvent");
      return true;
    } catch (e) {
      return false;
    }
  }
  checkTouch() {
    return _VirtualJoystick.checkForTouch();
  }
  createBase() {
    const base = document.createElement("span");
    const style = base.style;
    style.touchAction = "pinch-zoom";
    style.width = `${this.radius * 2}px`;
    style.height = `${this.radius * 2}px`;
    style.position = "relative";
    style.display = "block";
    style.borderRadius = "50%";
    style.borderColor = "rgba(200,200,200,0.5)";
    style.borderWidth = "2px";
    style.borderStyle = "solid";
    style.pointerEvents = "auto";
    style.userSelect = "none";
    return base;
  }
  createCenter() {
    const center = document.createElement("div");
    const style = center.style;
    style.width = `${this.innerRadius * 2}px`;
    style.height = `${this.innerRadius * 2}px`;
    style.position = "absolute";
    style.borderRadius = "50%";
    style.backgroundColor = "rgba(200,200,200,0.3)";
    style.borderWidth = "1px";
    style.borderColor = "rgba(200,200,200,0.8)";
    style.borderStyle = "solid";
    style.userSelect = "none";
    return center;
  }
  createJumpButton() {
    const button = document.createElement("button");
    button.textContent = "JUMP";
    const style = button.style;
    style.touchAction = "pinch-zoom";
    style.width = `100px`;
    style.height = `100px`;
    style.borderRadius = "20px";
    style.color = "white";
    style.font = "Helvetica, sans-serif";
    style.fontSize = "16px";
    style.backgroundColor = "rgba(200,200,200,0.3)";
    style.color = "rgba(220,220,220,1)";
    style.borderWidth = "1px";
    style.borderColor = "rgba(200,200,200,0.8)";
    style.borderStyle = "solid";
    style.pointerEvents = "auto";
    style.userSelect = "none";
    return button;
  }
  bindEvents() {
    this.joystickBaseElement.addEventListener("pointerdown", this.onJoystickPointerDown.bind(this));
    this.joystickBaseElement.addEventListener(
      "contextmenu",
      this.preventDefaultAndStopPropagation.bind(this)
    );
    this.joystickBaseElement.addEventListener(
      "touchstart",
      this.preventDefaultAndStopPropagation.bind(this)
    );
    this.jumpButton.addEventListener("pointerdown", this.onJumpPointerDown.bind(this));
    this.jumpButton.addEventListener(
      "contextmenu",
      this.preventDefaultAndStopPropagation.bind(this)
    );
    this.jumpButton.addEventListener(
      "touchstart",
      this.preventDefaultAndStopPropagation.bind(this)
    );
    document.addEventListener("pointermove", this.onPointerMove.bind(this));
    document.addEventListener("pointerup", this.onPointerUp.bind(this));
    document.addEventListener("pointercancel", this.onPointerUp.bind(this));
  }
  preventDefaultAndStopPropagation(evt) {
    evt.preventDefault();
    evt.stopPropagation();
  }
  onJumpPointerDown(evt) {
    if (this.jumpPointerId === null) {
      this.jumpPointerId = evt.pointerId;
    }
  }
  onJoystickPointerDown(evt) {
    evt.preventDefault();
    evt.stopPropagation();
    if (evt.buttons !== 1) {
      return;
    }
    if (this.joystickPointerId === null) {
      this.joystickPointerId = evt.pointerId;
      this.updateControlAndDirection(evt);
    }
  }
  onPointerMove(evt) {
    evt.preventDefault();
    evt.stopPropagation();
    if (evt.pointerId !== this.joystickPointerId) {
      return;
    }
    this.updateControlAndDirection(evt);
  }
  onPointerUp(evt) {
    evt.preventDefault();
    evt.stopPropagation();
    if (evt.pointerId === this.jumpPointerId) {
      this.jumpPointerId = null;
    }
    if (evt.pointerId === this.joystickPointerId) {
      this.joystickPointerId = null;
      this.clearJoystickState();
    }
  }
  clearJoystickState = () => {
    this.joystickOutput = null;
    this.joystickCenterElement.style.left = `${this.radius - this.innerRadius}px`;
    this.joystickCenterElement.style.top = `${this.radius - this.innerRadius}px`;
  };
  updateControlAndDirection(input) {
    const rect = this.joystickBaseElement.getBoundingClientRect();
    const dx = input.clientX - (rect.left + this.radius);
    const dy = input.clientY - (rect.top + this.radius);
    const distance = Math.min(Math.sqrt(dx * dx + dy * dy), this.radius);
    const angle = Math.atan2(dy, dx);
    const constrainedX = distance * Math.cos(angle);
    const constrainedY = distance * Math.sin(angle);
    this.joystickCenterElement.style.left = `${constrainedX + this.radius - this.innerRadius}px`;
    this.joystickCenterElement.style.top = `${constrainedY + this.radius - this.innerRadius}px`;
    const direction = Math.atan2(dx, dy);
    const speed = distance / this.radius;
    const isSprinting = speed > sprintingThreshold;
    this.joystickOutput = { direction, isSprinting };
  }
  getOutput() {
    const jump = this.jumpPointerId !== null;
    if (!this.joystickOutput) {
      if (jump) {
        return { direction: null, isSprinting: false, jump };
      }
      return null;
    }
    return {
      ...this.joystickOutput,
      jump
    };
  }
};

// src/collisions/CollisionsManager.ts
import { MMLCollisionTrigger } from "@mml-io/mml-web";

// src/collisions/getRelativePositionAndRotationRelativeToObject.ts
var tempContainerMatrix = new Matr4();
var tempTargetMatrix = new Matr4();
var tempPositionVector = new Vect3();
var tempRotationEuler = new EulXYZ();
var tempRotationQuaternion = new Quat();
var tempScaleVector = new Vect3();
function getRelativePositionAndRotationRelativeToObject(positionAndRotation, matrix, localScale) {
  const { x, y, z } = positionAndRotation.position;
  const { x: rx, y: ry, z: rz } = positionAndRotation.rotation;
  tempContainerMatrix.copy(matrix).invert();
  tempPositionVector.set(x, y, z);
  tempRotationEuler.set(rx, ry, rz);
  tempRotationQuaternion.setFromEulerXYZ(tempRotationEuler);
  tempScaleVector.set(1, 1, 1);
  tempTargetMatrix.compose(tempPositionVector, tempRotationQuaternion, tempScaleVector);
  tempTargetMatrix.premultiply(tempContainerMatrix);
  tempTargetMatrix.decompose(tempPositionVector, tempRotationQuaternion, tempScaleVector);
  tempRotationEuler.setFromQuaternion(tempRotationQuaternion);
  tempPositionVector.multiply(localScale);
  return {
    position: {
      x: tempPositionVector.x,
      y: tempPositionVector.y,
      z: tempPositionVector.z
    },
    rotation: {
      x: tempRotationEuler.x,
      y: tempRotationEuler.y,
      z: tempRotationEuler.z
    }
  };
}

// src/collisions/CollisionsManager.ts
var CollisionsManager = class {
  tempVector = new Vect3();
  tempVector2 = new Vect3();
  tempVect3 = new Vect3();
  tempQuat = new Quat();
  tempRay = new Ray();
  tempMatrix = new Matr4();
  tempBox = new Box();
  tempEulXYZ = new EulXYZ();
  tempSegment = new Line();
  tempSegment2 = new Line();
  tempCollisionPosition = new Vect3();
  tempMinimalNormal = new Vect3();
  tempMinimalPoint = new Vect3();
  collisionMeshState = /* @__PURE__ */ new Map();
  collisionTrigger;
  previouslyCollidingElements;
  debugEnabled = false;
  onDebugChange;
  constructor() {
    this.collisionTrigger = MMLCollisionTrigger.init();
    this.toggleDebug = this.toggleDebug.bind(this);
  }
  isDebugEnabled() {
    return this.debugEnabled;
  }
  toggleDebug(enabled) {
    this.debugEnabled = enabled;
    if (this.onDebugChange) {
      this.onDebugChange(enabled);
    }
  }
  raycastFirst(ray, maximumDistance = null) {
    let minimumDistance = null;
    let minimumHit = null;
    let minimumNormal = this.tempMinimalNormal;
    let minimumPoint = this.tempMinimalPoint;
    for (const [, collisionMeshState] of this.collisionMeshState) {
      const invertedMatrix = this.tempMatrix.copy(collisionMeshState.matrix).invert();
      const originalRay = this.tempRay.copy(ray);
      originalRay.applyMatrix4(invertedMatrix);
      const hit = collisionMeshState.meshBVH.raycastFirst(
        originalRay,
        2
        // DoubleSide
      );
      if (hit) {
        this.tempSegment.start.copy(originalRay.origin);
        this.tempSegment.end.copy(hit.point);
        this.tempSegment.applyMatrix4(collisionMeshState.matrix);
        const dist = this.tempSegment.distance();
        if ((maximumDistance === null || dist < maximumDistance) && (minimumDistance === null || dist < minimumDistance)) {
          minimumDistance = dist;
          minimumHit = collisionMeshState;
          minimumNormal = (hit.normal ? minimumNormal.copy(hit.normal) : minimumNormal.set(0, 1, 0)).applyQuat(this.tempQuat.setFromRotationMatrix(collisionMeshState.matrix)).normalize();
          minimumPoint = minimumPoint.copy(hit.point).applyMatrix4(collisionMeshState.matrix);
        }
      }
    }
    if (minimumDistance === null || minimumHit === null) {
      return null;
    }
    return [minimumDistance, minimumNormal, minimumHit, minimumPoint];
  }
  addMeshesGroup(group, creationResult, mElement) {
    if (mElement) {
      this.collisionTrigger.addCollider(group, mElement);
    }
    const { meshBVH, matrix, localScale } = creationResult;
    const meshState = {
      source: group,
      meshBVH,
      matrix,
      localScale,
      trackCollisions: mElement !== void 0
    };
    this.collisionMeshState.set(group, meshState);
  }
  updateMeshesGroup(group, matrix, localScale) {
    const meshState = this.collisionMeshState.get(group);
    if (meshState) {
      meshState.matrix.copy(matrix);
      meshState.localScale.x = localScale.x;
      meshState.localScale.y = localScale.y;
      meshState.localScale.z = localScale.z;
    }
  }
  removeMeshesGroup(group) {
    this.collisionTrigger.removeCollider(group);
    const meshState = this.collisionMeshState.get(group);
    if (meshState) {
      this.collisionMeshState.delete(group);
    }
  }
  applyCollider(worldBasedCapsuleSegment, capsuleRadius, meshState) {
    const meshMatrix = this.tempMatrix.copy(meshState.matrix).invert();
    const meshRelativeCapsuleBoundingBox = this.tempBox;
    meshRelativeCapsuleBoundingBox.makeEmpty();
    meshRelativeCapsuleBoundingBox.expandByPoint(worldBasedCapsuleSegment.start);
    meshRelativeCapsuleBoundingBox.expandByPoint(worldBasedCapsuleSegment.end);
    meshRelativeCapsuleBoundingBox.min.subScalar(capsuleRadius);
    meshRelativeCapsuleBoundingBox.max.addScalar(capsuleRadius);
    meshRelativeCapsuleBoundingBox.applyMatrix4(meshMatrix);
    const meshRelativeCapsuleSegment = this.tempSegment;
    meshRelativeCapsuleSegment.start.copy(worldBasedCapsuleSegment.start);
    meshRelativeCapsuleSegment.end.copy(worldBasedCapsuleSegment.end);
    meshRelativeCapsuleSegment.applyMatrix4(meshMatrix);
    const initialMeshRelativeCapsuleSegmentStart = this.tempVect3.copy(
      meshRelativeCapsuleSegment.start
    );
    let collisionPosition = null;
    let currentCollisionDistance = -1;
    meshState.meshBVH.shapecast({
      intersectsBounds: (meshBox) => {
        return meshBox.intersectsBox(meshRelativeCapsuleBoundingBox);
      },
      intersectsTriangle: (meshTriangle) => {
        const closestPointOnTriangle = this.tempVector;
        const closestPointOnSegment = this.tempVector2;
        meshTriangle.closestPointToSegment(
          meshRelativeCapsuleSegment,
          closestPointOnTriangle,
          closestPointOnSegment
        );
        const intersectionSegment = this.tempSegment2;
        intersectionSegment.start.copy(closestPointOnTriangle);
        intersectionSegment.end.copy(closestPointOnSegment);
        const modelReferenceDistance = intersectionSegment.distance();
        intersectionSegment.applyMatrix4(meshState.matrix);
        const realDistance = intersectionSegment.distance();
        if (realDistance < capsuleRadius) {
          if (!collisionPosition) {
            collisionPosition = this.tempCollisionPosition.copy(closestPointOnTriangle).applyMatrix4(meshState.matrix);
            currentCollisionDistance = realDistance;
          } else if (realDistance < currentCollisionDistance) {
            collisionPosition.copy(closestPointOnTriangle).applyMatrix4(meshState.matrix);
            currentCollisionDistance = realDistance;
          }
          const ratio = realDistance / modelReferenceDistance;
          const realDepth = capsuleRadius - realDistance;
          const modelDepth = realDepth / ratio;
          const direction = closestPointOnSegment.sub(closestPointOnTriangle).normalize();
          meshRelativeCapsuleSegment.start.addScaledVector(direction, modelDepth);
          meshRelativeCapsuleSegment.end.addScaledVector(direction, modelDepth);
        }
      }
    });
    if (collisionPosition) {
      const delta = this.tempVector.copy(meshRelativeCapsuleSegment.start).sub(initialMeshRelativeCapsuleSegmentStart);
      this.tempMatrix.copy(meshState.matrix).setPosition(0, 0, 0);
      delta.applyMatrix4(this.tempMatrix);
      if (!(isNaN(delta.x) && isNaN(delta.y) && isNaN(delta.z))) {
        worldBasedCapsuleSegment.start.add(delta);
        worldBasedCapsuleSegment.end.add(delta);
      }
    }
    return collisionPosition;
  }
  applyColliders(tempSegment, radius) {
    const collidedElements = /* @__PURE__ */ new Map();
    for (const meshState of this.collisionMeshState.values()) {
      const collisionPosition = this.applyCollider(tempSegment, radius, meshState);
      if (collisionPosition && meshState.trackCollisions) {
        const relativePosition = getRelativePositionAndRotationRelativeToObject(
          {
            position: collisionPosition,
            rotation: this.tempEulXYZ.set(0, 0, 0)
          },
          meshState.matrix,
          meshState.localScale
        );
        collidedElements.set(meshState.source, {
          position: relativePosition.position
        });
      }
    }
    const reportedCollidingElements = new Map(collidedElements);
    if (this.previouslyCollidingElements) {
      for (const [element, position] of this.previouslyCollidingElements) {
        if (!reportedCollidingElements.has(element)) {
          reportedCollidingElements.set(element, position);
        }
      }
    }
    this.previouslyCollidingElements = collidedElements;
    this.collisionTrigger.setCurrentCollisions(reportedCollidingElements);
  }
};

// src/loading-screen/LoadingScreen.ts
import { LoadingProgressManager } from "@mml-io/mml-web";
var LoadingScreen = class {
  constructor(loadingProgressManager, config) {
    this.loadingProgressManager = loadingProgressManager;
    this.config = config;
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
    const defaultBackground = "linear-gradient(45deg, #28284B 0%, #303056 100%)";
    this.element = document.createElement("div");
    this.element.id = "loading-screen";
    this.element.style.position = "absolute";
    this.element.style.top = "0";
    this.element.style.left = "0";
    this.element.style.width = "100%";
    this.element.style.height = "100%";
    this.element.style.backgroundColor = ((_a = this.config) == null ? void 0 : _a.background) || defaultBackground;
    this.element.style.background = ((_b = this.config) == null ? void 0 : _b.background) || defaultBackground;
    this.element.style.zIndex = "10001";
    this.backgroundBlur = document.createElement("div");
    this.backgroundBlur.id = "loading-screen-blur";
    this.backgroundBlur.style.position = "absolute";
    this.backgroundBlur.style.top = "0";
    this.backgroundBlur.style.left = "0";
    this.backgroundBlur.style.width = "100%";
    this.backgroundBlur.style.height = "100%";
    this.backgroundBlur.style.display = "flex";
    if ((_c = this.config) == null ? void 0 : _c.backgroundBlurAmount) {
      this.backgroundBlur.style.backdropFilter = `blur(${this.config.backgroundBlurAmount}px)`;
    }
    this.element.append(this.backgroundBlur);
    if ((_d = this.config) == null ? void 0 : _d.backgroundImageUrl) {
      this.element.style.backgroundImage = `url(${this.config.backgroundImageUrl})`;
      this.element.style.backgroundPosition = "center";
      this.element.style.backgroundSize = "cover";
    }
    if ((_e = this.config) == null ? void 0 : _e.overlayLayers) {
      const logLoadError = (imageUrl) => {
        console.error(`Failed to load overlay image: ${imageUrl}`);
      };
      for (const layer of this.config.overlayLayers) {
        const overlayLayer = document.createElement("div");
        overlayLayer.style.position = "absolute";
        overlayLayer.style.background = `url(${layer.overlayImageUrl}) no-repeat`;
        overlayLayer.style.backgroundSize = "contain";
        const anchor = layer.overlayAnchor;
        const offsetX = ((_f = layer.overlayOffset) == null ? void 0 : _f.x) || 0;
        const offsetY = ((_g = layer.overlayOffset) == null ? void 0 : _g.y) || 0;
        if (anchor.includes("top")) {
          overlayLayer.style.top = `${offsetY}px`;
        } else if (anchor.includes("bottom")) {
          overlayLayer.style.bottom = `${offsetY}px`;
        }
        if (anchor.includes("left")) {
          overlayLayer.style.left = `${offsetX}px`;
        } else if (anchor.includes("right")) {
          overlayLayer.style.right = `${offsetX}px`;
        }
        const image = new Image();
        image.src = layer.overlayImageUrl;
        image.onload = () => {
          const naturalWidth = image.naturalWidth;
          const naturalHeight = image.naturalHeight;
          overlayLayer.style.width = `${naturalWidth}px`;
          overlayLayer.style.height = `${naturalHeight}px`;
        };
        image.onerror = () => logLoadError(layer.overlayImageUrl);
        this.overlayLayers.push(overlayLayer);
        this.backgroundBlur.append(overlayLayer);
      }
    }
    this.element.style.color = ((_h = this.config) == null ? void 0 : _h.color) || "white";
    this.loadingBanner = document.createElement("div");
    this.loadingBanner.style.position = "absolute";
    this.loadingBanner.style.display = "flex";
    this.loadingBanner.style.flexDirection = "column";
    this.loadingBanner.style.left = "0";
    this.loadingBanner.style.bottom = "0";
    this.loadingBanner.style.padding = "0";
    this.loadingBanner.style.width = "100%";
    this.loadingBanner.style.justifyContent = "flex-end";
    this.backgroundBlur.append(this.loadingBanner);
    if ((_i = this.config) == null ? void 0 : _i.title) {
      this.loadingBannerTitle = document.createElement("div");
      this.loadingBannerTitle.textContent = this.config.title;
      this.loadingBannerTitle.style.color = ((_j = this.config) == null ? void 0 : _j.color) || "white";
      this.loadingBannerTitle.style.paddingLeft = "40px";
      this.loadingBannerTitle.style.paddingRight = "40px";
      this.loadingBannerTitle.style.fontSize = "42px";
      this.loadingBannerTitle.style.fontWeight = "bold";
      this.loadingBannerTitle.style.fontFamily = "sans-serif";
      if ((_k = this.config) == null ? void 0 : _k.background) {
        this.loadingBannerTitle.style.textShadow = `0px 0px 80px ${this.config.background}`;
      }
      this.loadingBanner.append(this.loadingBannerTitle);
    }
    if ((_l = this.config) == null ? void 0 : _l.subtitle) {
      this.loadingBannerSubtitle = document.createElement("div");
      this.loadingBannerSubtitle.style.color = ((_m = this.config) == null ? void 0 : _m.color) || "white";
      this.loadingBannerSubtitle.style.paddingLeft = "40px";
      this.loadingBannerSubtitle.style.paddingRight = "40px";
      this.loadingBannerSubtitle.style.fontSize = "16px";
      this.loadingBannerSubtitle.style.fontWeight = "400";
      this.loadingBannerSubtitle.style.fontFamily = "sans-serif";
      this.loadingBannerSubtitle.style.marginTop = "12px";
      if ((_n = this.config) == null ? void 0 : _n.background) {
        this.loadingBannerSubtitle.style.textShadow = `0px 0px 40px ${this.config.background}`;
      }
      this.loadingBannerSubtitle.textContent = this.config.subtitle;
      this.loadingBanner.append(this.loadingBannerSubtitle);
    }
    this.progressDebugViewHolder = document.createElement("div");
    this.progressDebugViewHolder.style.display = "none";
    this.progressDebugViewHolder.style.position = "absolute";
    this.progressDebugViewHolder.style.width = "calc(100% - 80px)";
    this.progressDebugViewHolder.style.maxHeight = "calc(100% - 120px)";
    this.progressDebugViewHolder.style.left = "40px";
    this.progressDebugViewHolder.style.bottom = "60px";
    this.progressDebugViewHolder.style.alignItems = "center";
    this.progressDebugViewHolder.style.justifyContent = "center";
    this.progressDebugViewHolder.style.zIndex = "10003";
    this.element.append(this.progressDebugViewHolder);
    this.progressDebugView = document.createElement("div");
    this.progressDebugView.style.backgroundColor = "rgba(128, 128, 128, 0.5)";
    this.progressDebugView.style.border = "1px solid black";
    this.progressDebugView.style.borderRadius = "7px";
    this.progressDebugView.style.width = "100%";
    this.progressDebugView.style.maxWidth = "100%";
    this.progressDebugView.style.overflow = "auto";
    this.progressDebugViewHolder.append(this.progressDebugView);
    this.debugCheckbox = document.createElement("input");
    this.debugCheckbox.type = "checkbox";
    this.debugCheckbox.checked = false;
    this.debugCheckbox.addEventListener("change", () => {
      this.progressDebugElement.style.display = this.debugCheckbox.checked ? "block" : "none";
      this.loadingBannerTitle.style.display = this.debugCheckbox.checked ? "none" : "flex";
      this.loadingBannerSubtitle.style.display = this.debugCheckbox.checked ? "none" : "flex";
      if (this.hasCompleted) {
        this.dispose();
      }
    });
    this.debugLabel = document.createElement("label");
    this.debugLabel.textContent = "Debug loading";
    this.debugLabel.style.fontFamily = "sans-serif";
    this.debugLabel.style.padding = "5px";
    this.debugLabel.style.display = "inline-block";
    this.debugLabel.style.userSelect = "none";
    this.debugLabel.append(this.debugCheckbox);
    this.progressDebugView.append(this.debugLabel);
    this.progressDebugElement = document.createElement("pre");
    this.progressDebugElement.style.margin = "0";
    this.progressDebugElement.style.display = this.debugCheckbox.checked ? "block" : "none";
    this.progressDebugView.append(this.progressDebugElement);
    this.progressBarHolder = document.createElement("div");
    this.progressBarHolder.style.display = "flex";
    this.progressBarHolder.style.alignItems = "start";
    this.progressBarHolder.style.justifyContent = "flex-start";
    this.progressBarHolder.style.width = "100%";
    this.progressBarHolder.style.marginLeft = "40px";
    this.progressBarHolder.style.marginBottom = "40px";
    this.progressBarHolder.style.cursor = "pointer";
    this.progressBarHolder.style.marginTop = "24px";
    this.loadingBanner.append(this.progressBarHolder);
    this.progressBarBackground = document.createElement("div");
    this.progressBarBackground.style.position = "relative";
    this.progressBarBackground.style.width = "80%";
    this.progressBarBackground.style.maxWidth = "400px";
    this.progressBarBackground.style.minWidth = "240px";
    this.progressBarBackground.style.backgroundColor = "rgba(32,32,32, 0.25)";
    this.progressBarBackground.style.backdropFilter = "blur(4px)";
    this.progressBarBackground.style.height = "16px";
    this.progressBarBackground.style.lineHeight = "16px";
    this.progressBarBackground.style.borderRadius = "16px";
    this.progressBarBackground.style.overflow = "hidden";
    this.progressBarBackground.addEventListener("click", () => {
      const display = this.progressDebugViewHolder.style.display;
      if (display === "none") {
        this.progressDebugViewHolder.style.display = "flex";
      } else {
        this.progressDebugViewHolder.style.display = "none";
        this.debugCheckbox.checked = false;
        this.progressDebugElement.style.display = this.debugCheckbox.checked ? "block" : "none";
        this.loadingBannerTitle.style.display = this.debugCheckbox.checked ? "none" : "flex";
      }
    });
    this.progressBarHolder.append(this.progressBarBackground);
    this.progressBar = document.createElement("div");
    this.progressBar.style.position = "absolute";
    this.progressBar.style.top = "0";
    this.progressBar.style.left = "0";
    this.progressBar.style.width = "0";
    this.progressBar.style.height = "100%";
    this.progressBar.style.pointerEvents = "none";
    this.progressBar.style.backgroundColor = ((_o = this.config) == null ? void 0 : _o.color) || "#0050a4";
    this.progressBarBackground.append(this.progressBar);
    this.loadingStatusText = document.createElement("div");
    this.loadingStatusText.style.position = "absolute";
    this.loadingStatusText.style.top = "0";
    this.loadingStatusText.style.left = "0";
    this.loadingStatusText.style.width = "100%";
    this.loadingStatusText.style.height = "100%";
    this.loadingStatusText.style.color = "rgba(200,200,200,0.9)";
    this.loadingStatusText.style.fontSize = "10px";
    this.loadingStatusText.style.textAlign = "center";
    this.loadingStatusText.style.verticalAlign = "middle";
    this.loadingStatusText.style.mixBlendMode = "difference";
    this.loadingStatusText.style.fontFamily = "sans-serif";
    this.loadingStatusText.style.fontWeight = "bold";
    this.loadingStatusText.style.userSelect = "none";
    this.loadingStatusText.textContent = "Loading...";
    this.progressBarBackground.append(this.loadingStatusText);
    this.loadingCallback = () => {
      const [loadingRatio, completedLoading] = this.loadingProgressManager.toRatio();
      if (completedLoading) {
        if (!this.hasCompleted) {
          this.hasCompleted = true;
          if (!this.debugCheckbox.checked) {
            this.dispose();
          }
        }
        this.loadingStatusText.textContent = "Completed";
        this.progressBar.style.width = "100%";
      } else {
        this.loadingStatusText.textContent = `${(loadingRatio * 100).toFixed(2)}%`;
        this.progressBar.style.width = `${loadingRatio * 100}%`;
      }
      this.progressDebugElement.textContent = LoadingProgressManager.LoadingProgressSummaryToString(
        this.loadingProgressManager.toSummary()
      );
    };
    this.loadingProgressManager.addProgressCallback(this.loadingCallback);
  }
  element;
  backgroundBlur;
  overlayLayers = [];
  loadingBanner;
  loadingBannerTitle;
  loadingBannerSubtitle;
  progressBarBackground;
  progressBarHolder;
  progressBar;
  loadingStatusText;
  progressDebugViewHolder;
  progressDebugView;
  progressDebugElement;
  debugLabel;
  debugCheckbox;
  hasCompleted = false;
  loadingCallback;
  disposed = false;
  dispose() {
    if (this.disposed) {
      return;
    }
    this.disposed = true;
    this.loadingProgressManager.removeProgressCallback(this.loadingCallback);
    this.element.remove();
  }
};

// src/error-screen/ErrorScreen.ts
var ErrorScreen = class {
  element;
  titleBannerText;
  messageText;
  constructor(title, message) {
    this.element = document.createElement("div");
    this.element.style.position = "absolute";
    this.element.style.top = "0";
    this.element.style.left = "0";
    this.element.style.display = "flex";
    this.element.style.alignItems = "center";
    this.element.style.justifyContent = "center";
    this.element.style.flexDirection = "column";
    this.element.style.width = "100%";
    this.element.style.height = "100%";
    this.element.style.zIndex = "10000";
    this.element.style.background = "linear-gradient(45deg, #111111 0%, #444444 100%)";
    this.element.style.color = "white";
    this.titleBannerText = document.createElement("div");
    this.titleBannerText.textContent = title;
    this.titleBannerText.style.fontSize = "40px";
    this.titleBannerText.style.fontWeight = "bold";
    this.titleBannerText.style.fontFamily = "sans-serif";
    this.element.append(this.titleBannerText);
    this.messageText = document.createElement("div");
    this.messageText.style.textAlign = "center";
    this.messageText.style.fontFamily = "sans-serif";
    this.messageText.style.fontWeight = "bold";
    this.messageText.textContent = message;
    this.element.append(this.messageText);
  }
  dispose() {
    this.element.remove();
  }
};

// src/tweakpane/TweakPane.ts
import * as EssentialsPlugin from "@tweakpane/plugin-essentials";
import { Pane } from "tweakpane";

// src/tweakpane/blades/cameraFolder.ts
function createDefaultCameraValues() {
  return {
    initialDistance: 3.3,
    minDistance: 0.1,
    maxDistance: 5,
    initialFOV: 60,
    maxFOV: 70,
    minFOV: 60,
    invertFOVMapping: false,
    damping: 0.21,
    zoomScale: 0.04,
    zoomDamping: 0.04
  };
}
var camOptions = {
  initialDistance: { min: 1, max: 5, step: 0.1 },
  minDistance: { min: 0.1, max: 2, step: 0.1 },
  maxDistance: { min: 5, max: 20, step: 0.5 },
  initialFOV: { min: 60, max: 85, step: 1 },
  maxFOV: { min: 50, max: 100, step: 1 },
  minFOV: { min: 50, max: 100, step: 1 },
  damping: { min: 0.01, max: 1, step: 1e-3 },
  zoomScale: { min: 5e-3, max: 0.3, step: 1e-3 },
  zoomDamping: { min: 0, max: 2, step: 0.01 }
};
var CameraFolder = class {
  constructor(parentFolder, cameraValues) {
    this.cameraValues = cameraValues;
    this.folder = parentFolder.addFolder({ title: "camera", expanded: false });
    this.folder.addBinding(this.camData, "distance", { readonly: true });
    this.folder.addBinding(this.camData, "FoV", { readonly: true });
    this.folder.addBinding(this.cameraValues, "initialDistance", camOptions.initialDistance);
    this.folder.addBinding(this.cameraValues, "minDistance", camOptions.minDistance);
    this.folder.addBinding(this.cameraValues, "maxDistance", camOptions.maxDistance);
    this.folder.addBinding(this.cameraValues, "minFOV", camOptions.minFOV);
    this.folder.addBinding(this.cameraValues, "maxFOV", camOptions.maxFOV);
    this.folder.addBinding(this.cameraValues, "invertFOVMapping");
    this.folder.addBinding(this.cameraValues, "damping", camOptions.damping);
    this.folder.addBinding(this.cameraValues, "zoomScale", camOptions.zoomScale);
    this.folder.addBinding(this.cameraValues, "zoomDamping", camOptions.zoomDamping);
  }
  folder;
  camData = {
    distance: "0",
    FoV: "0"
  };
  setupChangeEvent(cameraManager) {
    this.folder.on("change", (e) => {
      const target = e.target.key;
      if (!target) return;
      switch (target) {
        case "initialDistance": {
          const value = e.value;
          cameraManager.initialDistance = value;
          cameraManager.distance = value;
          cameraManager.targetDistance = value;
          cameraManager.desiredDistance = value;
          cameraManager.recomputeFoV();
          break;
        }
        case "minDistance": {
          const value = e.value;
          cameraManager.minDistance = value;
          cameraManager.distance = value;
          cameraManager.targetDistance = value;
          cameraManager.desiredDistance = value;
          cameraManager.recomputeFoV();
          break;
        }
        case "maxDistance": {
          const value = e.value;
          cameraManager.maxDistance = value;
          cameraManager.distance = value;
          cameraManager.targetDistance = value;
          cameraManager.desiredDistance = value;
          cameraManager.recomputeFoV();
          break;
        }
        case "minFOV": {
          const value = e.value;
          cameraManager.minFOV = value;
          cameraManager.recomputeFoV();
          break;
        }
        case "maxFOV": {
          const value = e.value;
          cameraManager.maxFOV = value;
          cameraManager.recomputeFoV();
          break;
        }
        case "invertFOVMapping": {
          const boolValue = e.value;
          cameraManager.invertFOVMapping = boolValue;
          break;
        }
        case "damping": {
          const value = e.value;
          cameraManager.damping = value;
          break;
        }
        case "zoomScale": {
          const value = e.value;
          cameraManager.zoomScale = value;
          break;
        }
        case "zoomDamping": {
          const value = e.value;
          cameraManager.zoomDamping = value;
          break;
        }
        default:
          break;
      }
    });
  }
  update(cameraManager) {
    this.camData.distance = cameraManager.distance.toFixed(2);
    this.camData.FoV = cameraManager.fov.toFixed(2);
  }
};

// src/tweakpane/blades/characterControlsFolder.ts
function createDefaultCharacterControllerValues() {
  return {
    gravity: 37,
    jumpForce: 17,
    doubleJumpForce: 16.7,
    coyoteJump: 120,
    airResistance: 0.5,
    groundResistance: 0,
    airControlModifier: 0.05,
    groundWalkControl: 0.625,
    groundRunControl: 0.8,
    baseControlMultiplier: 200,
    minimumSurfaceAngle: 0.905
  };
}
var characterControllerOptions = {
  gravity: { min: 1, max: 100, step: 0.05 },
  jumpForce: { min: 1, max: 50, step: 0.05 },
  doubleJumpForce: { min: 1, max: 50, step: 0.05 },
  coyoteJump: { min: 60, max: 200, step: 1 },
  airResistance: { min: 0.01, max: 0.9, step: 0.01 },
  groundResistance: { min: -100, max: 0, step: 1 },
  airControlModifier: { min: 1e-3, max: 0.15, step: 0.01 },
  groundWalkControl: { min: 0.1, max: 1.5, step: 0.01 },
  groundRunControl: { min: 0.5, max: 2, step: 0.01 },
  baseControlMultiplier: { min: 150, max: 300, step: 1 },
  minimumSurfaceAngle: { min: 0.254, max: 1, step: 1e-3 }
};
var CharacterControlsFolder = class {
  constructor(parentFolder, controllerValues, expand = false) {
    this.controllerValues = controllerValues;
    this.folder = parentFolder.addFolder({ title: "character", expanded: expand });
    this.folder.addBinding(this.characterData, "position", { readonly: true });
    this.folder.addBinding(this.characterData, "onGround", { readonly: true });
    this.folder.addBinding(this.characterData, "canJump", { readonly: true });
    this.folder.addBinding(this.characterData, "canDoubleJump", { readonly: true });
    this.folder.addBinding(this.characterData, "jumpCount", { readonly: true });
    this.folder.addBinding(this.characterData, "coyoteTime", { readonly: true });
    this.folder.addBinding(this.characterData, "coyoteJumped", { readonly: true });
    this.folder.addBinding(this.controllerValues, "gravity", characterControllerOptions.gravity);
    this.folder.addBinding(
      this.controllerValues,
      "jumpForce",
      characterControllerOptions.jumpForce
    );
    this.folder.addBinding(
      this.controllerValues,
      "doubleJumpForce",
      characterControllerOptions.doubleJumpForce
    );
    this.folder.addBinding(
      this.controllerValues,
      "coyoteJump",
      characterControllerOptions.coyoteJump
    );
    this.folder.addBinding(
      this.controllerValues,
      "airResistance",
      characterControllerOptions.airResistance
    );
    this.folder.addBinding(
      this.controllerValues,
      "groundResistance",
      characterControllerOptions.groundResistance
    );
    this.folder.addBinding(
      this.controllerValues,
      "airControlModifier",
      characterControllerOptions.airControlModifier
    );
    this.folder.addBinding(
      this.controllerValues,
      "groundWalkControl",
      characterControllerOptions.groundWalkControl
    );
    this.folder.addBinding(
      this.controllerValues,
      "groundRunControl",
      characterControllerOptions.groundRunControl
    );
    this.folder.addBinding(
      this.controllerValues,
      "baseControlMultiplier",
      characterControllerOptions.baseControlMultiplier
    );
    this.folder.addBinding(
      this.controllerValues,
      "minimumSurfaceAngle",
      characterControllerOptions.minimumSurfaceAngle
    );
  }
  folder;
  characterData = {
    position: "(0, 0, 0)",
    onGround: "false",
    canJump: "false",
    canDoubleJump: "false",
    jumpCount: "0",
    coyoteTime: "false",
    coyoteJumped: "false"
  };
  setupChangeEvent(localController) {
    this.folder.on("change", (e) => {
      const target = e.target.key;
      if (!target) return;
      switch (target) {
        case "gravity": {
          const value = e.value;
          localController.gravity = value * -1;
          break;
        }
        case "jumpForce": {
          const value = e.value;
          localController.jumpForce = value;
          break;
        }
        case "doubleJumpForce": {
          const value = e.value;
          localController.doubleJumpForce = value;
          break;
        }
        case "coyoteJump": {
          const value = e.value;
          localController.coyoteTimeThreshold = value;
          break;
        }
        case "airResistance": {
          const value = e.value;
          localController.airResistance = value;
          break;
        }
        case "groundResistance": {
          const value = e.value;
          localController.groundResistance = 0.99999999 + value * 1e-6;
          break;
        }
        case "airControlModifier": {
          const value = e.value;
          localController.airControlModifier = value;
          break;
        }
        case "groundWalkControl": {
          const value = e.value;
          localController.groundWalkControl = value;
          break;
        }
        case "groundRunControl": {
          const value = e.value;
          localController.groundRunControl = value;
          break;
        }
        case "baseControlMultiplier": {
          const value = e.value;
          localController.baseControl = value;
          break;
        }
        case "minimumSurfaceAngle": {
          const value = e.value;
          localController.minimumSurfaceAngle = value;
          break;
        }
        default:
          break;
      }
    });
  }
  update(localController) {
    const { x, y, z } = localController.latestPosition;
    this.characterData.position = `(${x.toFixed(2)}, ${y.toFixed(2)}, ${z.toFixed(2)})`;
    this.characterData.onGround = `${localController.characterOnGround}`;
    this.characterData.canJump = `${localController.canJump || localController.coyoteTime ? "true" : "false"}`;
    this.characterData.canDoubleJump = `${localController.canDoubleJump}`;
    this.characterData.jumpCount = `${localController.jumpCounter}`;
    this.characterData.coyoteTime = `${localController.coyoteTime}`;
    this.characterData.coyoteJumped = `${localController.coyoteJumped}`;
  }
};

// src/tweakpane/tweakPaneStyle.ts
var tweakPaneStyle = `
:root {
  --tp-base-background-color: rgba(12, 12, 12, 0.6);
  --tp-base-shadow-color: hsla(0, 0%, 0%, 0.2);
  --tp-button-background-color: hsla(0, 0%, 80%, 1);
  --tp-button-background-color-active: hsla(0, 0%, 100%, 1);
  --tp-button-background-color-focus: hsla(0, 0%, 95%, 1);
  --tp-button-background-color-hover: hsla(0, 0%, 85%, 1);
  --tp-button-foreground-color: hsla(0, 0%, 0%, 0.7);
  --tp-container-background-color: hsla(0, 0%, 0%, 0.3);
  --tp-container-background-color-active: hsla(0, 0%, 0%, 0.6);
  --tp-container-background-color-focus: hsla(0, 0%, 0%, 0.5);
  --tp-container-background-color-hover: hsla(0, 0%, 0%, 0.4);
  --tp-container-foreground-color: hsla(0, 0%, 90%, 0.6);
  --tp-groove-foreground-color: hsla(0, 0%, 0%, 0.2);
  --tp-input-background-color: hsla(0, 0%, 30%, 0.3);
  --tp-input-background-color-active: hsla(0, 0%, 0%, 0.6);
  --tp-input-background-color-focus: hsla(0, 0%, 0%, 0.5);
  --tp-input-background-color-hover: hsla(0, 0%, 0%, 0.4);
  --tp-input-foreground-color: hsla(0, 0%, 100%, 0.6);
  --tp-label-foreground-color: hsla(0, 0%, 100%, 0.6);
  --tp-monitor-background-color: hsla(0, 0%, 0%, 0.3);
  --tp-monitor-foreground-color: hsla(0, 0%, 100%, 0.3);
}

.tp-brkv {
  -webkit-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.tp-dfwv {
  z-index: 100;
  color: white;
  width: 600px !important;
  display: none;
  -webkit-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.tp-fldv {
  margin: 1px 0px 0px 0px !important;
}

.tp-fldv_b {
  overflow: visible !important;
}

.tp-fldv_t {
  font-size: 13px;
  font-weight: 900;
  color: #ffffff;
  background-color: rgba(70, 70, 70, 0.3);
  border-top: 1px solid rgba(210, 210, 210, 0.1);
  border-radius: 3px;
}

.tp-lblv_l {
  font-size: 12px;
  padding-left: 0px !important;
  padding-right: 0px !important;
}

.tp-lblv_v {
  width: 150px;
}

.tp-sldtxtv_t {
    max-width: 50px;
}

.tp-sglv_i {
  font-size: 12px;
  color: rgba(255, 255, 255, 0.7);
}

.tp-ckbv_w {
  border: 1px solid rgba(200, 200, 250, 0.2);
}
`;

// src/tweakpane/TweakPane.ts
var TweakPane = class {
  constructor(holderElement, config, guiVisible = false) {
    this.guiVisible = guiVisible;
    this.tweakPaneWrapper = document.createElement("div");
    this.tweakPaneWrapper.style.position = "fixed";
    this.tweakPaneWrapper.style.width = "400px";
    this.tweakPaneWrapper.style.height = "100%";
    this.tweakPaneWrapper.style.top = "0px";
    this.tweakPaneWrapper.style.right = "calc(-50vw)";
    this.tweakPaneWrapper.style.zIndex = "99";
    this.tweakPaneWrapper.style.overflow = "auto";
    this.tweakPaneWrapper.style.backgroundColor = "rgba(0, 0, 0, 0.66)";
    this.tweakPaneWrapper.style.paddingLeft = "5px";
    this.tweakPaneWrapper.style.boxShadow = "-7px 0px 12px rgba(0, 0, 0, 0.5)";
    this.tweakPaneWrapper.style.transition = "right cubic-bezier(0.83, 0, 0.17, 1) 0.7s";
    holderElement.appendChild(this.tweakPaneWrapper);
    this.gui = new Pane({ container: this.tweakPaneWrapper });
    this.gui.registerPlugin(EssentialsPlugin);
    if (this.saveVisibilityInLocalStorage) {
      const localStorageGuiVisible = localStorage.getItem("guiVisible");
      if (localStorageGuiVisible !== null) {
        if (localStorageGuiVisible === "true") {
          this.guiVisible = true;
        } else if (localStorageGuiVisible === "false") {
          this.guiVisible = false;
        }
      }
    }
    const styleElement = document.createElement("style");
    styleElement.type = "text/css";
    styleElement.appendChild(document.createTextNode(tweakPaneStyle));
    document.head.appendChild(styleElement);
    this.camera = new CameraFolder(this.gui, config.cameraValues);
    this.characterControls = new CharacterControlsFolder(
      this.gui,
      config.characterControllerValues,
      false
    );
    const exportFolder = this.gui.addFolder({ title: "import / export", expanded: false });
    const exportButton = exportFolder.addButton({ title: "export" });
    exportButton.on("click", () => {
      this.downloadSettingsAsJSON(this.gui.exportState());
    });
    const importButton = exportFolder.addButton({ title: "import" });
    importButton.on("click", () => {
      this.importSettingsFromJSON((settings) => {
        this.gui.importState(settings);
      });
    });
    this.eventHandlerCollection = new EventHandlerCollection();
    const gui = this.gui;
    const paneElement = gui.containerElem_;
    paneElement.style.right = this.guiVisible ? "0px" : "-450px";
    this.eventHandlerCollection.add(this.gui.element, "mouseenter", () => setTweakpaneActive(true));
    this.eventHandlerCollection.add(this.gui.element, "mousemove", () => setTweakpaneActive(true));
    this.eventHandlerCollection.add(this.gui.element, "mousedown", () => setTweakpaneActive(true));
    this.eventHandlerCollection.add(
      this.gui.element,
      "mouseleave",
      () => setTweakpaneActive(false)
    );
    this.eventHandlerCollection.add(this.gui.element, "mouseup", () => setTweakpaneActive(false));
    this.eventHandlerCollection.add(window, "keydown", (e) => {
      this.processKey(e);
    });
    this.updateVisibility();
  }
  gui;
  camera;
  characterControls;
  saveVisibilityInLocalStorage = true;
  tweakPaneWrapper;
  eventHandlerCollection;
  processKey(e) {
    if (e.key === "p") {
      this.toggleGUI();
    }
  }
  dispose() {
    this.eventHandlerCollection.clear();
    this.gui.dispose();
    this.tweakPaneWrapper.remove();
  }
  setupCamPane(cameraManager) {
    this.camera.setupChangeEvent(cameraManager);
  }
  setupCharacterController(localController) {
    this.characterControls.setupChangeEvent(localController);
  }
  updateCameraData(cameraManager) {
    this.camera.update(cameraManager);
  }
  updateCharacterData(localController) {
    this.characterControls.update(localController);
  }
  formatDateForFilename() {
    const date = /* @__PURE__ */ new Date();
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const day = String(date.getDate()).padStart(2, "0");
    const hours = String(date.getHours()).padStart(2, "0");
    const minutes = String(date.getMinutes()).padStart(2, "0");
    const seconds = String(date.getSeconds()).padStart(2, "0");
    return `${year}-${month}-${day} ${hours}-${minutes}-${seconds}`;
  }
  downloadSettingsAsJSON(settings) {
    const jsonString = JSON.stringify(settings, null, 2);
    const blob = new Blob([jsonString], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.download = `settings ${this.formatDateForFilename()}.json`;
    a.href = url;
    a.click();
    URL.revokeObjectURL(url);
  }
  importSettingsFromJSON(callback) {
    const input = document.createElement("input");
    input.type = "file";
    input.accept = ".json";
    input.addEventListener("change", (event) => {
      var _a;
      const file = (_a = event.target.files) == null ? void 0 : _a[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = (loadEvent) => {
          var _a2;
          try {
            const settings = JSON.parse((_a2 = loadEvent.target) == null ? void 0 : _a2.result);
            callback(settings);
          } catch (err) {
            console.error("Error parsing JSON:", err);
          }
        };
        reader.readAsText(file);
      }
    });
    input.click();
  }
  toggleGUI() {
    this.guiVisible = !this.guiVisible;
    this.updateVisibility();
  }
  setVisible(visible) {
    this.guiVisible = visible;
    this.updateVisibility();
  }
  updateVisibility() {
    const gui = this.gui;
    const paneElement = gui.containerElem_;
    paneElement.style.right = this.guiVisible ? "0px" : "-450px";
    if (this.saveVisibilityInLocalStorage) {
      localStorage.setItem("guiVisible", this.guiVisible === true ? "true" : "false");
    }
  }
};
export {
  AnimationMixer,
  AnimationState,
  Box,
  CameraManager,
  CharacterManager,
  CollisionsManager,
  ErrorScreen,
  EulXYZ,
  Key,
  KeyInputManager,
  Line,
  LoadingScreen,
  Matr4,
  Quat,
  Ray,
  TweakPane,
  Vect3,
  VirtualJoystick,
  clamp,
  createDefaultCameraValues,
  createDefaultCharacterControllerValues,
  decodeCharacterAndCamera,
  degToRad,
  ease,
  encodeCharacterAndCamera,
  getSpawnData,
  getSpawnPositionInsideCircle,
  radToDeg,
  remap,
  round,
  roundToDecimalPlaces,
  toArray
};
//# sourceMappingURL=index.js.map
