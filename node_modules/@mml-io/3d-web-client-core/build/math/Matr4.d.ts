import { Quat } from "./Quat";
import { IVect3, Vect3 } from "./Vect3";
export type Matr4Data = [
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number
];
export declare class Matr4 {
    static tempMatr4: Matr4;
    static tempVect3: Vect3;
    static tempQuat: Quat;
    data: Matr4Data;
    constructor();
    constructor(n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number);
    identity(): this;
    copy(m: Matr4): Matr4;
    fromArray(data: [
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number
    ] | Float32Array): this;
    set(n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number): this;
    setRotationFromQuaternion(q: {
        x: number;
        y: number;
        z: number;
        w: number;
    }): this;
    clone(): Matr4;
    determinant(): number;
    makeRotationX(theta: number): this;
    makeRotationY(theta: number): this;
    makeRotationZ(theta: number): this;
    makeTranslation(x: number, y: number, z: number): this;
    makeScale(x: number, y: number, z: number): this;
    compose(position: {
        x: number;
        y: number;
        z: number;
    }, quaternion: {
        x: number;
        y: number;
        z: number;
        w: number;
    }, scale: {
        x: number;
        y: number;
        z: number;
    }): this;
    decompose(position: {
        x: number;
        y: number;
        z: number;
    }, quaternion: {
        x: number;
        y: number;
        z: number;
        w: number;
    }, scale: {
        x: number;
        y: number;
        z: number;
    }): this;
    getScale(vect3: IVect3): IVect3;
    multiply(m: Matr4): this;
    premultiply(m: Matr4): this;
    multiplyMatrices(a: Matr4, b: Matr4): this;
    invert(): this;
    equals(other: Matr4): boolean;
    setPosition(x: number, y: number, z: number): this;
}
//# sourceMappingURL=Matr4.d.ts.map