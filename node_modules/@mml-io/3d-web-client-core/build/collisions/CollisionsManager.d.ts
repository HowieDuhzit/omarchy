import { MElement } from "@mml-io/mml-web";
import type { MeshBVH } from "three-mesh-bvh";
import { Line } from "../math/Line";
import { Matr4 } from "../math/Matr4";
import { Ray } from "../math/Ray";
import { IVect3, Vect3 } from "../math/Vect3";
type CollisionSourceRef = unknown;
export type CollisionMeshState = {
    matrix: Matr4;
    localScale: IVect3;
    source: CollisionSourceRef;
    meshBVH: MeshBVH;
    trackCollisions: boolean;
};
export type CollisionMesh = {
    meshBVH: MeshBVH;
    matrix: Matr4;
    localScale: IVect3;
};
export declare class CollisionsManager {
    private tempVector;
    private tempVector2;
    private tempVect3;
    private tempQuat;
    private tempRay;
    private tempMatrix;
    private tempBox;
    private tempEulXYZ;
    private tempSegment;
    private tempSegment2;
    private tempCollisionPosition;
    private tempMinimalNormal;
    private tempMinimalPoint;
    collisionMeshState: Map<CollisionSourceRef, CollisionMeshState>;
    private collisionTrigger;
    private previouslyCollidingElements;
    private debugEnabled;
    onDebugChange?: (enabled: boolean) => void;
    constructor();
    isDebugEnabled(): boolean;
    toggleDebug(enabled: boolean): void;
    raycastFirst(ray: Ray, maximumDistance?: number | null): [number, Vect3, CollisionMeshState, Vect3] | null;
    addMeshesGroup(group: CollisionSourceRef, creationResult: CollisionMesh, mElement?: MElement): void;
    updateMeshesGroup(group: CollisionSourceRef, matrix: Matr4, localScale: IVect3): void;
    removeMeshesGroup(group: CollisionSourceRef): void;
    private applyCollider;
    applyColliders(tempSegment: Line, radius: number): void;
}
export {};
//# sourceMappingURL=CollisionsManager.d.ts.map