// src/networked-dom-v0.1/constants.ts
var networkedDOMProtocolSubProtocol_v0_1 = "networked-dom-v0.1";

// src/networked-dom-v0.2/BufferReader.ts
var textDecoder = new TextDecoder();
var BufferReader = class {
  constructor(buffer) {
    this.buffer = buffer;
    this.offset = 0;
  }
  readUInt8() {
    return this.buffer[this.offset++];
  }
  readBoolean() {
    return this.readUInt8() === 1;
  }
  readUVarint(signed = false) {
    let lo = 0;
    let hi = 0;
    let i = 0;
    for (; i < 4; ++i) {
      lo = (lo | (this.buffer[this.offset] & 127) << i * 7) >>> 0;
      if (this.buffer[this.offset++] < 128) {
        return signed ? loAndHiAsSigned(lo, hi) : loAndHiAsUnsigned(lo, hi);
      }
    }
    lo = (lo | (this.buffer[this.offset] & 127) << 28) >>> 0;
    hi = (hi | (this.buffer[this.offset] & 127) >> 4) >>> 0;
    if (this.buffer[this.offset++] < 128) {
      return signed ? loAndHiAsSigned(lo, hi) : loAndHiAsUnsigned(lo, hi);
    }
    i = 0;
    for (; i < 5; ++i) {
      hi = (hi | (this.buffer[this.offset] & 127) << i * 7 + 3) >>> 0;
      if (this.buffer[this.offset++] < 128) {
        return signed ? loAndHiAsSigned(lo, hi) : loAndHiAsUnsigned(lo, hi);
      }
    }
    throw Error("invalid varint encoding");
  }
  readUVarintPrefixedString() {
    const readLength = this.readUVarint();
    let string = "";
    let hasNonAscii = false;
    for (let i = 0; i < readLength; i++) {
      const charValue = this.buffer[this.offset + i];
      if (charValue < 128) {
        string += String.fromCharCode(charValue);
      } else {
        hasNonAscii = true;
        break;
      }
    }
    if (!hasNonAscii) {
      this.offset += readLength;
      return string;
    }
    const result = textDecoder.decode(this.buffer.subarray(this.offset, this.offset + readLength));
    this.offset += readLength;
    return result;
  }
  // returns the string and a boolean indicating if the string was negative length
  readVarintPrefixedString() {
    const length = this.readVarint();
    const negativeLength = length < 0;
    const readLength = negativeLength ? -length : length;
    let string = "";
    let hasNonAscii = false;
    for (let i = 0; i < readLength; i++) {
      const charValue = this.buffer[this.offset + i];
      if (charValue < 128) {
        string += String.fromCharCode(charValue);
      } else {
        hasNonAscii = true;
        break;
      }
    }
    if (!hasNonAscii) {
      this.offset += readLength;
      return [string, negativeLength];
    }
    const result = textDecoder.decode(this.buffer.subarray(this.offset, this.offset + readLength));
    this.offset += readLength;
    return [result, negativeLength];
  }
  readVarint() {
    return this.readUVarint(true);
  }
  isEnd() {
    return this.offset >= this.buffer.length;
  }
};
function loAndHiAsSigned(lo, hi) {
  const value = lo + hi * 4294967296;
  if (value & 1) {
    return -(value + 1) / 2;
  }
  return value / 2;
}
function loAndHiAsUnsigned(lo, hi) {
  return lo + hi * 4294967296;
}

// src/networked-dom-v0.2/BufferWriter.ts
var textEncoder = new TextEncoder();
var BufferWriter = class {
  constructor(initialLength) {
    this.buffer = new Uint8Array(initialLength);
    this.offset = 0;
  }
  // Write an unsigned 8-bit integer
  writeUint8(value) {
    this.ensureCapacity(1);
    this.buffer[this.offset] = value & 255;
    this.offset += 1;
  }
  writeBoolean(bool) {
    this.writeUint8(bool ? 1 : 0);
  }
  // Write an array of bytes
  writeBytes(bytes) {
    this.ensureCapacity(bytes.byteLength);
    this.buffer.set(bytes, this.offset);
    this.offset += bytes.byteLength;
  }
  // Get the written bytes as a Uint8Array
  getBuffer() {
    return this.buffer.subarray(0, this.offset);
  }
  getWrittenLength() {
    return this.offset;
  }
  // Ensure there is enough capacity in the buffer
  ensureCapacity(neededSpace) {
    while (this.offset + neededSpace > this.buffer.length) {
      this.expandBuffer();
    }
  }
  // Expand the buffer by doubling its current length
  expandBuffer() {
    const newBuffer = new Uint8Array(this.buffer.length * 2);
    newBuffer.set(this.buffer);
    this.buffer = newBuffer;
  }
  writeUVarint(x) {
    if (x <= 268435455) {
      this.ensureCapacity(4);
      while (x >= 128) {
        this.buffer[this.offset] = x & 127 | 128;
        this.offset++;
        x >>>= 7;
      }
      this.buffer[this.offset] = x & 127;
      this.offset++;
      return;
    }
    this.ensureCapacity(10);
    let lo = 0;
    let hi = 0;
    if (x !== 0) {
      lo = x >>> 0;
      hi = (x - lo) / 4294967296 >>> 0;
    }
    while (hi) {
      this.buffer[this.offset++] = lo & 127 | 128;
      lo = (lo >>> 7 | hi << 25) >>> 0;
      hi >>>= 7;
    }
    while (lo > 127) {
      this.buffer[this.offset++] = lo & 127 | 128;
      lo = lo >>> 7;
    }
    this.buffer[this.offset++] = lo;
  }
  writeVarint(x) {
    if (x >= 0) {
      this.writeUVarint(x * 2);
    } else {
      this.writeUVarint(-x * 2 - 1);
    }
  }
  writeLengthPrefixedString(value, varint = false, negativeLength = false) {
    const originalOffset = this.offset;
    if (varint) {
      this.writeVarint(negativeLength ? -value.length : value.length);
    } else {
      this.writeUVarint(value.length);
    }
    this.ensureCapacity(value.length);
    let nonAscii = false;
    for (let i = 0; i < value.length; i++) {
      const charCode = value.charCodeAt(i);
      if (charCode > 127) {
        nonAscii = true;
        break;
      }
      this.buffer[this.offset++] = charCode;
    }
    if (!nonAscii) {
      return;
    }
    this.offset = originalOffset;
    let encodedLength = value.length;
    this.ensureCapacity(encodedLength);
    while (true) {
      this.offset = originalOffset;
      if (varint) {
        this.writeVarint(negativeLength ? -encodedLength : encodedLength);
      } else {
        this.writeUVarint(encodedLength);
      }
      const offsetAfterVarint = this.offset;
      const varintLength = offsetAfterVarint - originalOffset;
      const writeBuffer = new Uint8Array(this.buffer.buffer, this.offset);
      const { read, written } = textEncoder.encodeInto(value, writeBuffer);
      if (read !== value.length) {
        this.expandBuffer();
        continue;
      }
      if (written !== encodedLength) {
        encodedLength = written;
        this.offset = originalOffset;
        if (varint) {
          this.writeVarint(negativeLength ? -encodedLength : encodedLength);
        } else {
          this.writeUVarint(encodedLength);
        }
        const newOffsetAfterVarint = this.offset;
        const actualVarintLength = newOffsetAfterVarint - originalOffset;
        if (actualVarintLength !== varintLength) {
          continue;
        } else {
        }
      }
      this.offset += written;
      return;
    }
  }
};

// src/networked-dom-v0.2/common-structs/attributes.ts
function encodeAttribute(writer, key, value) {
  if (value === null) {
    writer.writeLengthPrefixedString(key, true, true);
  } else {
    writer.writeLengthPrefixedString(key, true, false);
    writer.writeLengthPrefixedString(value);
  }
}
function encodeAttributes(writer, attributes) {
  writer.writeUVarint(attributes.length);
  for (let i = 0; i < attributes.length; i++) {
    encodeAttribute(writer, attributes[i][0], attributes[i][1]);
  }
}
function decodeAttributes(buffer) {
  const attributesLength = buffer.readUVarint();
  const attributes = [];
  for (let i = 0; i < attributesLength; i++) {
    const [key, negativeLength] = buffer.readVarintPrefixedString();
    if (negativeLength) {
      attributes.push([key, null]);
      continue;
    }
    const value = buffer.readUVarintPrefixedString();
    attributes.push([key, value]);
  }
  return attributes;
}

// src/networked-dom-v0.2/common-structs/nodeDescription.ts
function encodeNodeDescription(writer, nodeDescription) {
  writer.writeUVarint(nodeDescription.nodeId);
  if (nodeDescription.type === "text") {
    writer.writeLengthPrefixedString("");
    writer.writeLengthPrefixedString(nodeDescription.text);
    return;
  }
  writer.writeLengthPrefixedString(nodeDescription.tag);
  encodeAttributes(writer, nodeDescription.attributes);
  if (!nodeDescription.visibleTo) {
    writer.writeUVarint(0);
  } else {
    writer.writeUVarint(nodeDescription.visibleTo.length);
    for (let i = 0; i < nodeDescription.visibleTo.length; i++) {
      writer.writeUVarint(nodeDescription.visibleTo[i]);
    }
  }
  if (!nodeDescription.hiddenFrom) {
    writer.writeUVarint(0);
  } else {
    writer.writeUVarint(nodeDescription.hiddenFrom.length);
    for (let i = 0; i < nodeDescription.hiddenFrom.length; i++) {
      writer.writeUVarint(nodeDescription.hiddenFrom[i]);
    }
  }
  writer.writeUVarint(nodeDescription.children.length);
  for (let i = 0; i < nodeDescription.children.length; i++) {
    encodeNodeDescription(writer, nodeDescription.children[i]);
  }
}
function decodeNodeDescription(buffer) {
  const nodeId = buffer.readUVarint();
  const tag = buffer.readUVarintPrefixedString();
  if (tag === "") {
    const text = buffer.readUVarintPrefixedString();
    return { type: "text", nodeId, text };
  }
  const attributes = decodeAttributes(buffer);
  const visibleToLength = buffer.readUVarint();
  let visibleTo;
  if (visibleToLength !== 0) {
    visibleTo = [];
    for (let i = 0; i < visibleToLength; i++) {
      visibleTo.push(buffer.readUVarint());
    }
  }
  const hiddenFromLength = buffer.readUVarint();
  let hiddenFrom;
  if (hiddenFromLength !== 0) {
    hiddenFrom = [];
    for (let i = 0; i < hiddenFromLength; i++) {
      hiddenFrom.push(buffer.readUVarint());
    }
  }
  const childrenLength = buffer.readUVarint();
  const children = [];
  for (let i = 0; i < childrenLength; i++) {
    children.push(decodeNodeDescription(buffer));
  }
  const node = {
    type: "element",
    nodeId,
    tag,
    attributes,
    children
  };
  if (visibleTo) {
    node.visibleTo = visibleTo;
  }
  if (hiddenFrom) {
    node.hiddenFrom = hiddenFrom;
  }
  return node;
}

// src/networked-dom-v0.2/constants.ts
var networkedDOMProtocolSubProtocol_v0_2 = "networked-dom-v0.2";
var networkedDOMProtocolSubProtocol_v0_2_1 = "networked-dom-v0.2.1";
var networkedDOMProtocolSubProtocol_v0_2_SubVersionsList = [
  networkedDOMProtocolSubProtocol_v0_2_1,
  networkedDOMProtocolSubProtocol_v0_2
];
var protocolSubVersionMap = {
  [networkedDOMProtocolSubProtocol_v0_2]: 0,
  [networkedDOMProtocolSubProtocol_v0_2_1]: 1
};
function getNetworkedDOMProtocolSubProtocol_v0_2Subversion(protocol) {
  return protocolSubVersionMap[protocol] ?? null;
}
function getNetworkedDOMProtocolSubProtocol_v0_2SubversionOrThrow(protocol) {
  const subversion = getNetworkedDOMProtocolSubProtocol_v0_2Subversion(protocol);
  if (subversion === null) {
    throw new Error(`Unrecognized networked-dom-v0.2 protocol subversion: ${protocol}`);
  }
  return subversion;
}
function isNetworkedDOMProtocolSubProtocol_v0_2(protocol) {
  return networkedDOMProtocolSubProtocol_v0_2_SubVersionsList.includes(protocol);
}

// src/networked-dom-v0.2/featureDetection.ts
function protocolSubversionHasConnectionTokens(protocolSubversion) {
  return protocolSubversion >= 1;
}

// src/networked-dom-v0.2/messageTypes.ts
var SnapshotMessageType = 1;
var BatchStartMessageType = 2;
var DocumentTimeMessageType = 3;
var ChildrenAddedMessageType = 4;
var ChildrenRemovedMessageType = 5;
var AttributesChangedMessageType = 6;
var ChangeVisibleToMessageType = 7;
var ChangeHiddenFromMessageType = 8;
var TextChangedMessageType = 9;
var BatchEndMessageType = 10;
var PingMessageType = 11;
var WarningMessageType = 12;
var ErrorMessageType = 13;
var ConnectUsersMessageType = 14;
var DisconnectUsersMessageType = 15;
var EventMessageType = 16;
var PongMessageType = 17;

// src/networked-dom-v0.2/messages/from-client/connectUsers.ts
function encodeConnectUsers(connectUsersMessage, writer, protocolSubversion) {
  const connectionIdsLength = connectUsersMessage.connectionIds.length;
  writer.writeUint8(ConnectUsersMessageType);
  writer.writeUVarint(connectionIdsLength);
  for (let i = 0; i < connectionIdsLength; i++) {
    writer.writeUVarint(connectUsersMessage.connectionIds[i]);
  }
  if (protocolSubversionHasConnectionTokens(protocolSubversion)) {
    if (connectUsersMessage.connectionTokens.length !== connectionIdsLength) {
      throw new Error(
        `connectionTokens length (${connectUsersMessage.connectionTokens.length}) does not match connectionIds length (${connectionIdsLength})`
      );
    }
    for (let i = 0; i < connectionIdsLength; i++) {
      const token = connectUsersMessage.connectionTokens[i];
      if (token === null || token === void 0) {
        writer.writeUVarint(0);
      } else {
        writer.writeLengthPrefixedString(token);
      }
    }
  }
}
function decodeConnectUsers(buffer, protocolSubversion) {
  const connectionIds = [];
  const connectionIdsLength = buffer.readUVarint();
  for (let i = 0; i < connectionIdsLength; i++) {
    connectionIds.push(buffer.readUVarint());
  }
  const connectionTokens = [];
  if (protocolSubversionHasConnectionTokens(protocolSubversion)) {
    for (let i = 0; i < connectionIdsLength; i++) {
      const token = buffer.readUVarintPrefixedString();
      if (token === "") {
        connectionTokens.push(null);
      } else {
        connectionTokens.push(token);
      }
    }
  } else {
    for (let i = 0; i < connectionIdsLength; i++) {
      connectionTokens.push(null);
    }
  }
  return {
    type: "connectUsers",
    connectionIds,
    connectionTokens
  };
}

// src/networked-dom-v0.2/messages/from-client/disconnectUsers.ts
function encodeDisconnectUsers(disconnectUsersMessage, writer) {
  const connectionIdsLength = disconnectUsersMessage.connectionIds.length;
  writer.writeUint8(DisconnectUsersMessageType);
  writer.writeUVarint(connectionIdsLength);
  for (let i = 0; i < connectionIdsLength; i++) {
    writer.writeUVarint(disconnectUsersMessage.connectionIds[i]);
  }
}
function decodeDisconnectUsers(buffer) {
  const connectionIds = [];
  const connectionIdsLength = buffer.readUVarint();
  for (let i = 0; i < connectionIdsLength; i++) {
    connectionIds.push(buffer.readUVarint());
  }
  return {
    type: "disconnectUsers",
    connectionIds
  };
}

// src/networked-dom-v0.2/messages/from-client/event.ts
function encodeEvent(event, writer) {
  writer.writeUint8(EventMessageType);
  writer.writeUVarint(event.nodeId);
  writer.writeUVarint(event.connectionId);
  writer.writeLengthPrefixedString(event.name);
  writer.writeBoolean(event.bubbles);
  writer.writeLengthPrefixedString(JSON.stringify(event.params));
}
function decodeEvent(buffer) {
  const nodeId = buffer.readUVarint();
  const connectionId = buffer.readUVarint();
  const name = buffer.readUVarintPrefixedString();
  const bubbles = buffer.readBoolean();
  const paramsJSONString = buffer.readUVarintPrefixedString();
  const params = JSON.parse(paramsJSONString);
  return {
    type: "event",
    nodeId,
    connectionId,
    name,
    bubbles,
    params
  };
}

// src/networked-dom-v0.2/messages/from-client/pong.ts
function encodePong(pongMessage, writer) {
  writer.writeUint8(PongMessageType);
  writer.writeUVarint(pongMessage.pong);
}
function decodePong(buffer) {
  const pong = buffer.readUVarint();
  return {
    type: "pong",
    pong
  };
}

// src/networked-dom-v0.2/decodeClientMessages.ts
function decodeClientMessages(buffer, protocolSubversion) {
  const messages = [];
  while (!buffer.isEnd()) {
    const messageType = buffer.readUInt8();
    switch (messageType) {
      case ConnectUsersMessageType:
        messages.push(decodeConnectUsers(buffer, protocolSubversion));
        break;
      case DisconnectUsersMessageType:
        messages.push(decodeDisconnectUsers(buffer));
        break;
      case EventMessageType:
        messages.push(decodeEvent(buffer));
        break;
      case PongMessageType:
        messages.push(decodePong(buffer));
        break;
      default:
        throw new Error(`Unknown message type: ${messageType}`);
    }
  }
  return messages;
}

// src/networked-dom-v0.2/messages/from-server/attributesChanged.ts
function encodeAttributesChanged(msg, writer = new BufferWriter(64)) {
  writer.writeUint8(AttributesChangedMessageType);
  writer.writeUVarint(msg.nodeId);
  encodeAttributes(writer, msg.attributes);
  return writer;
}
function decodeAttributesChanged(buffer) {
  const nodeId = buffer.readUVarint();
  const attributes = decodeAttributes(buffer);
  return {
    type: "attributesChanged",
    nodeId,
    attributes
  };
}

// src/networked-dom-v0.2/messages/from-server/batchEnd.ts
function encodeBatchEnd(writer = new BufferWriter(1)) {
  writer.writeUint8(BatchEndMessageType);
  return writer;
}
var batchEndMessage = {
  type: "batchEnd"
};

// src/networked-dom-v0.2/messages/from-server/batchStart.ts
function encodeBatchStart(writer = new BufferWriter(1)) {
  writer.writeUint8(BatchStartMessageType);
  return writer;
}
var batchStartMessage = {
  type: "batchStart"
};

// src/networked-dom-v0.2/messages/from-server/changeHiddenFrom.ts
function encodeChangeHiddenFrom(msg, writer = new BufferWriter(64)) {
  writer.writeUint8(ChangeHiddenFromMessageType);
  writer.writeUVarint(msg.nodeId);
  if (msg.addHiddenFrom) {
    writer.writeUVarint(msg.addHiddenFrom.length);
    for (const key of msg.addHiddenFrom) {
      writer.writeUVarint(key);
    }
  } else {
    writer.writeUVarint(0);
  }
  if (msg.removeHiddenFrom) {
    writer.writeUVarint(msg.removeHiddenFrom.length);
    for (const key of msg.removeHiddenFrom) {
      writer.writeUVarint(key);
    }
  } else {
    writer.writeUVarint(0);
  }
  return writer;
}
function decodeChangeHiddenFrom(buffer) {
  const nodeId = buffer.readUVarint();
  const addHiddenFromLength = buffer.readUVarint();
  const addHiddenFrom = [];
  for (let i = 0; i < addHiddenFromLength; i++) {
    addHiddenFrom.push(buffer.readUVarint());
  }
  const removeHiddenFromLength = buffer.readUVarint();
  const removeHiddenFrom = [];
  for (let i = 0; i < removeHiddenFromLength; i++) {
    removeHiddenFrom.push(buffer.readUVarint());
  }
  return {
    type: "changeHiddenFrom",
    nodeId,
    addHiddenFrom,
    removeHiddenFrom
  };
}

// src/networked-dom-v0.2/messages/from-server/changeVisibleTo.ts
function encodeChangeVisibleTo(msg, writer = new BufferWriter(64)) {
  writer.writeUint8(ChangeVisibleToMessageType);
  writer.writeUVarint(msg.nodeId);
  if (msg.addVisibleTo) {
    writer.writeUVarint(msg.addVisibleTo.length);
    for (const key of msg.addVisibleTo) {
      writer.writeUVarint(key);
    }
  } else {
    writer.writeUVarint(0);
  }
  if (msg.removeVisibleTo) {
    writer.writeUVarint(msg.removeVisibleTo.length);
    for (const key of msg.removeVisibleTo) {
      writer.writeUVarint(key);
    }
  } else {
    writer.writeUVarint(0);
  }
  return writer;
}
function decodeChangeVisibleTo(buffer) {
  const nodeId = buffer.readUVarint();
  const addVisibleToLength = buffer.readUVarint();
  const addVisibleTo = [];
  for (let i = 0; i < addVisibleToLength; i++) {
    addVisibleTo.push(buffer.readUVarint());
  }
  const removeVisibleToLength = buffer.readUVarint();
  const removeVisibleTo = [];
  for (let i = 0; i < removeVisibleToLength; i++) {
    removeVisibleTo.push(buffer.readUVarint());
  }
  return {
    type: "changeVisibleTo",
    nodeId,
    addVisibleTo,
    removeVisibleTo
  };
}

// src/networked-dom-v0.2/messages/from-server/childrenAdded.ts
function encodeChildrenAdded(msg, writer = new BufferWriter(64)) {
  writer.writeUint8(ChildrenAddedMessageType);
  writer.writeUVarint(msg.nodeId);
  writer.writeUVarint(msg.previousNodeId ?? 0);
  writer.writeUVarint(msg.addedNodes.length);
  for (let i = 0; i < msg.addedNodes.length; i++) {
    encodeNodeDescription(writer, msg.addedNodes[i]);
  }
  return writer;
}
function decodeChildrenAdded(buffer) {
  const nodeId = buffer.readUVarint();
  const previousNodeId = buffer.readUVarint();
  const childrenLength = buffer.readUVarint();
  const children = [];
  for (let i = 0; i < childrenLength; i++) {
    children.push(decodeNodeDescription(buffer));
  }
  return {
    type: "childrenAdded",
    nodeId,
    previousNodeId: previousNodeId === 0 ? null : previousNodeId,
    addedNodes: children
  };
}

// src/networked-dom-v0.2/messages/from-server/childrenRemoved.ts
function encodeChildrenRemoved(msg, writer = new BufferWriter(64)) {
  writer.writeUint8(ChildrenRemovedMessageType);
  writer.writeUVarint(msg.nodeId);
  writer.writeUVarint(msg.removedNodes.length);
  for (const nodeId of msg.removedNodes) {
    writer.writeUVarint(nodeId);
  }
  return writer;
}
function decodeChildrenRemoved(buffer) {
  const nodeId = buffer.readUVarint();
  const removedNodesLength = buffer.readUVarint();
  const removedNodes = [];
  for (let i = 0; i < removedNodesLength; i++) {
    removedNodes.push(buffer.readUVarint());
  }
  return {
    type: "childrenRemoved",
    nodeId,
    removedNodes
  };
}

// src/networked-dom-v0.2/messages/from-server/documentTime.ts
function encodeDocumentTime(msg, writer = new BufferWriter(8)) {
  writer.writeUint8(DocumentTimeMessageType);
  writer.writeUVarint(msg.documentTime);
  return writer;
}
function decodeDocumentTime(buffer) {
  return {
    type: "documentTime",
    documentTime: buffer.readUVarint()
  };
}

// src/networked-dom-v0.2/messages/from-server/error.ts
function encodeError(msg, writer = new BufferWriter(64)) {
  writer.writeUint8(ErrorMessageType);
  writer.writeLengthPrefixedString(msg.message);
  return writer;
}
function decodeError(buffer) {
  const message = buffer.readUVarintPrefixedString();
  return {
    type: "error",
    message
  };
}

// src/networked-dom-v0.2/messages/from-server/ping.ts
function encodePing(pingMessage, writer = new BufferWriter(8)) {
  writer.writeUint8(PingMessageType);
  writer.writeUVarint(pingMessage.ping);
  writer.writeUVarint(pingMessage.documentTime);
  return writer;
}
function decodePing(buffer) {
  const ping = buffer.readUVarint();
  const documentTime = buffer.readUVarint();
  return {
    type: "ping",
    ping,
    documentTime
  };
}

// src/networked-dom-v0.2/messages/from-server/snapshot.ts
function encodeSnapshot(msg, writer = new BufferWriter(64)) {
  writer.writeUint8(SnapshotMessageType);
  encodeNodeDescription(writer, msg.snapshot);
  writer.writeUVarint(msg.documentTime);
  return writer;
}
function decodeSnapshot(buffer) {
  return {
    type: "snapshot",
    snapshot: decodeNodeDescription(buffer),
    documentTime: buffer.readUVarint()
  };
}

// src/networked-dom-v0.2/messages/from-server/textChanged.ts
function encodeTextChanged(msg, writer = new BufferWriter(64)) {
  writer.writeUint8(TextChangedMessageType);
  writer.writeUVarint(msg.nodeId);
  writer.writeLengthPrefixedString(msg.text);
  return writer;
}
function decodeTextChanged(buffer) {
  const nodeId = buffer.readUVarint();
  const text = buffer.readUVarintPrefixedString();
  return {
    type: "textChanged",
    nodeId,
    text
  };
}

// src/networked-dom-v0.2/messages/from-server/warning.ts
function encodeWarning(msg, writer = new BufferWriter(64)) {
  writer.writeUint8(WarningMessageType);
  writer.writeLengthPrefixedString(msg.message);
  return writer;
}
function decodeWarning(buffer) {
  const message = buffer.readUVarintPrefixedString();
  return {
    type: "warning",
    message
  };
}

// src/networked-dom-v0.2/decodeServerMessages.ts
function decodeServerMessages(buffer) {
  const messages = [];
  while (!buffer.isEnd()) {
    const messageType = buffer.readUInt8();
    switch (messageType) {
      case SnapshotMessageType:
        messages.push(decodeSnapshot(buffer));
        break;
      case DocumentTimeMessageType:
        messages.push(decodeDocumentTime(buffer));
        break;
      case ChildrenAddedMessageType:
        messages.push(decodeChildrenAdded(buffer));
        break;
      case ChildrenRemovedMessageType:
        messages.push(decodeChildrenRemoved(buffer));
        break;
      case AttributesChangedMessageType:
        messages.push(decodeAttributesChanged(buffer));
        break;
      case TextChangedMessageType:
        messages.push(decodeTextChanged(buffer));
        break;
      case ChangeVisibleToMessageType:
        messages.push(decodeChangeVisibleTo(buffer));
        break;
      case ChangeHiddenFromMessageType:
        messages.push(decodeChangeHiddenFrom(buffer));
        break;
      case BatchStartMessageType:
        messages.push(batchStartMessage);
        break;
      case BatchEndMessageType:
        messages.push(batchEndMessage);
        break;
      case PingMessageType:
        messages.push(decodePing(buffer));
        break;
      case WarningMessageType:
        messages.push(decodeWarning(buffer));
        break;
      case ErrorMessageType:
        messages.push(decodeError(buffer));
        break;
      default:
        throw new Error(`Unknown message type: ${messageType}`);
    }
  }
  return messages;
}

// src/networked-dom-v0.2/encodeClientMessage.ts
function encodeClientMessage(message, writer, protocolSubversion) {
  const type = message.type;
  switch (type) {
    case "connectUsers":
      return encodeConnectUsers(message, writer, protocolSubversion);
    case "disconnectUsers":
      return encodeDisconnectUsers(message, writer);
    case "event":
      return encodeEvent(message, writer);
    case "pong":
      return encodePong(message, writer);
    default:
      throw new Error(`Unknown message type: ${type}`);
  }
}

// src/networked-dom-v0.2/encodeServerMessage.ts
function encodeServerMessage(message, writer) {
  switch (message.type) {
    case "snapshot":
      return encodeSnapshot(message, writer);
    case "documentTime":
      return encodeDocumentTime(message, writer);
    case "childrenAdded":
      return encodeChildrenAdded(message, writer);
    case "childrenRemoved":
      return encodeChildrenRemoved(message, writer);
    case "attributesChanged":
      return encodeAttributesChanged(message, writer);
    case "textChanged":
      return encodeTextChanged(message, writer);
    case "changeVisibleTo":
      return encodeChangeVisibleTo(message, writer);
    case "changeHiddenFrom":
      return encodeChangeHiddenFrom(message, writer);
    case "batchStart":
      return encodeBatchStart(writer);
    case "batchEnd":
      return encodeBatchEnd(writer);
    case "ping":
      return encodePing(message, writer);
    case "warning":
      return encodeWarning(message, writer);
    case "error":
      return encodeError(message, writer);
    default:
      throw new Error(`Unknown message type: ${message.type}`);
  }
}
export {
  AttributesChangedMessageType,
  BatchEndMessageType,
  BatchStartMessageType,
  BufferReader,
  BufferWriter,
  ChangeHiddenFromMessageType,
  ChangeVisibleToMessageType,
  ChildrenAddedMessageType,
  ChildrenRemovedMessageType,
  ConnectUsersMessageType,
  DisconnectUsersMessageType,
  DocumentTimeMessageType,
  ErrorMessageType,
  EventMessageType,
  PingMessageType,
  PongMessageType,
  SnapshotMessageType,
  TextChangedMessageType,
  WarningMessageType,
  batchEndMessage,
  batchStartMessage,
  decodeAttributes,
  decodeAttributesChanged,
  decodeChangeHiddenFrom,
  decodeChangeVisibleTo,
  decodeChildrenAdded,
  decodeChildrenRemoved,
  decodeClientMessages,
  decodeConnectUsers,
  decodeDisconnectUsers,
  decodeDocumentTime,
  decodeError,
  decodeEvent,
  decodeNodeDescription,
  decodePing,
  decodePong,
  decodeServerMessages,
  decodeSnapshot,
  decodeTextChanged,
  decodeWarning,
  encodeAttribute,
  encodeAttributes,
  encodeAttributesChanged,
  encodeBatchEnd,
  encodeBatchStart,
  encodeChangeHiddenFrom,
  encodeChangeVisibleTo,
  encodeChildrenAdded,
  encodeChildrenRemoved,
  encodeClientMessage,
  encodeConnectUsers,
  encodeDisconnectUsers,
  encodeDocumentTime,
  encodeError,
  encodeEvent,
  encodeNodeDescription,
  encodePing,
  encodePong,
  encodeServerMessage,
  encodeSnapshot,
  encodeTextChanged,
  encodeWarning,
  getNetworkedDOMProtocolSubProtocol_v0_2Subversion,
  getNetworkedDOMProtocolSubProtocol_v0_2SubversionOrThrow,
  isNetworkedDOMProtocolSubProtocol_v0_2,
  networkedDOMProtocolSubProtocol_v0_1,
  networkedDOMProtocolSubProtocol_v0_2,
  networkedDOMProtocolSubProtocol_v0_2_1,
  networkedDOMProtocolSubProtocol_v0_2_SubVersionsList
};
//# sourceMappingURL=index.js.map
