{
  "version": 3,
  "sources": ["../src/networked-dom-v0.1/constants.ts", "../src/networked-dom-v0.2/BufferReader.ts", "../src/networked-dom-v0.2/BufferWriter.ts", "../src/networked-dom-v0.2/common-structs/attributes.ts", "../src/networked-dom-v0.2/common-structs/nodeDescription.ts", "../src/networked-dom-v0.2/constants.ts", "../src/networked-dom-v0.2/featureDetection.ts", "../src/networked-dom-v0.2/messageTypes.ts", "../src/networked-dom-v0.2/messages/from-client/connectUsers.ts", "../src/networked-dom-v0.2/messages/from-client/disconnectUsers.ts", "../src/networked-dom-v0.2/messages/from-client/event.ts", "../src/networked-dom-v0.2/messages/from-client/pong.ts", "../src/networked-dom-v0.2/decodeClientMessages.ts", "../src/networked-dom-v0.2/messages/from-server/attributesChanged.ts", "../src/networked-dom-v0.2/messages/from-server/batchEnd.ts", "../src/networked-dom-v0.2/messages/from-server/batchStart.ts", "../src/networked-dom-v0.2/messages/from-server/changeHiddenFrom.ts", "../src/networked-dom-v0.2/messages/from-server/changeVisibleTo.ts", "../src/networked-dom-v0.2/messages/from-server/childrenAdded.ts", "../src/networked-dom-v0.2/messages/from-server/childrenRemoved.ts", "../src/networked-dom-v0.2/messages/from-server/documentTime.ts", "../src/networked-dom-v0.2/messages/from-server/error.ts", "../src/networked-dom-v0.2/messages/from-server/ping.ts", "../src/networked-dom-v0.2/messages/from-server/snapshot.ts", "../src/networked-dom-v0.2/messages/from-server/textChanged.ts", "../src/networked-dom-v0.2/messages/from-server/warning.ts", "../src/networked-dom-v0.2/decodeServerMessages.ts", "../src/networked-dom-v0.2/encodeClientMessage.ts", "../src/networked-dom-v0.2/encodeServerMessage.ts"],
  "sourcesContent": ["export const networkedDOMProtocolSubProtocol_v0_1 = \"networked-dom-v0.1\";\n", "const textDecoder = new TextDecoder();\n\nexport class BufferReader {\n  private buffer: Uint8Array;\n  private offset: number;\n\n  constructor(buffer: Uint8Array) {\n    this.buffer = buffer;\n    this.offset = 0;\n  }\n\n  public readUInt8(): number {\n    return this.buffer[this.offset++];\n  }\n\n  public readBoolean(): boolean {\n    return this.readUInt8() === 1;\n  }\n\n  public readUVarint(signed = false): number {\n    let lo = 0;\n    let hi = 0;\n    let i = 0;\n    for (; i < 4; ++i) {\n      lo = (lo | ((this.buffer[this.offset] & 127) << (i * 7))) >>> 0;\n      if (this.buffer[this.offset++] < 128) {\n        return signed ? loAndHiAsSigned(lo, hi) : loAndHiAsUnsigned(lo, hi);\n      }\n    }\n    lo = (lo | ((this.buffer[this.offset] & 127) << 28)) >>> 0;\n    hi = (hi | ((this.buffer[this.offset] & 127) >> 4)) >>> 0;\n    if (this.buffer[this.offset++] < 128) {\n      return signed ? loAndHiAsSigned(lo, hi) : loAndHiAsUnsigned(lo, hi);\n    }\n    i = 0;\n    for (; i < 5; ++i) {\n      hi = (hi | ((this.buffer[this.offset] & 127) << (i * 7 + 3))) >>> 0;\n      if (this.buffer[this.offset++] < 128) {\n        return signed ? loAndHiAsSigned(lo, hi) : loAndHiAsUnsigned(lo, hi);\n      }\n    }\n\n    throw Error(\"invalid varint encoding\");\n  }\n\n  public readUVarintPrefixedString(): string {\n    const readLength = this.readUVarint();\n\n    let string = \"\";\n    let hasNonAscii = false;\n    for (let i = 0; i < readLength; i++) {\n      const charValue = this.buffer[this.offset + i];\n      if (charValue < 0x80) {\n        string += String.fromCharCode(charValue);\n      } else {\n        hasNonAscii = true;\n        break;\n      }\n    }\n    if (!hasNonAscii) {\n      this.offset += readLength;\n      return string;\n    }\n\n    // Slow path - decode the string using TextDecoder\n    const result = textDecoder.decode(this.buffer.subarray(this.offset, this.offset + readLength));\n    this.offset += readLength;\n    return result;\n  }\n\n  // returns the string and a boolean indicating if the string was negative length\n  public readVarintPrefixedString(): [string, boolean] {\n    const length = this.readVarint();\n    const negativeLength = length < 0;\n    const readLength = negativeLength ? -length : length;\n\n    let string = \"\";\n    let hasNonAscii = false;\n    for (let i = 0; i < readLength; i++) {\n      const charValue = this.buffer[this.offset + i];\n      if (charValue < 0x80) {\n        string += String.fromCharCode(charValue);\n      } else {\n        hasNonAscii = true;\n        break;\n      }\n    }\n    if (!hasNonAscii) {\n      this.offset += readLength;\n      return [string, negativeLength];\n    }\n\n    // Slow path - decode the string using TextDecoder\n    const result = textDecoder.decode(this.buffer.subarray(this.offset, this.offset + readLength));\n    this.offset += readLength;\n    return [result, negativeLength];\n  }\n\n  public readVarint(): number {\n    return this.readUVarint(true);\n  }\n\n  public isEnd() {\n    return this.offset >= this.buffer.length;\n  }\n}\n\nfunction loAndHiAsSigned(lo: number, hi: number) {\n  const value = lo + hi * 4294967296;\n  if (value & 1) {\n    return -(value + 1) / 2;\n  }\n  return value / 2;\n}\n\nfunction loAndHiAsUnsigned(lo: number, hi: number) {\n  return lo + hi * 4294967296;\n}\n", "const textEncoder = new TextEncoder();\n\nexport class BufferWriter {\n  private buffer: Uint8Array;\n  private offset: number;\n\n  constructor(initialLength: number) {\n    this.buffer = new Uint8Array(initialLength);\n    this.offset = 0;\n  }\n\n  // Write an unsigned 8-bit integer\n  public writeUint8(value: number): void {\n    this.ensureCapacity(1);\n    this.buffer[this.offset] = value & 0xff;\n    this.offset += 1;\n  }\n\n  public writeBoolean(bool: boolean) {\n    this.writeUint8(bool ? 1 : 0);\n  }\n\n  // Write an array of bytes\n  public writeBytes(bytes: Uint8Array): void {\n    this.ensureCapacity(bytes.byteLength);\n    this.buffer.set(bytes, this.offset);\n    this.offset += bytes.byteLength;\n  }\n\n  // Get the written bytes as a Uint8Array\n  public getBuffer(): Uint8Array {\n    return this.buffer.subarray(0, this.offset);\n  }\n\n  public getWrittenLength(): number {\n    return this.offset;\n  }\n\n  // Ensure there is enough capacity in the buffer\n  private ensureCapacity(neededSpace: number): void {\n    while (this.offset + neededSpace > this.buffer.length) {\n      this.expandBuffer();\n    }\n  }\n\n  // Expand the buffer by doubling its current length\n  private expandBuffer(): void {\n    const newBuffer = new Uint8Array(this.buffer.length * 2);\n    newBuffer.set(this.buffer);\n    this.buffer = newBuffer;\n  }\n\n  public writeUVarint(x: number) {\n    if (x <= 268435455) {\n      // Simple case that can be handled without hi and lo\n      this.ensureCapacity(4);\n      while (x >= 0x80) {\n        this.buffer[this.offset] = (x & 0x7f) | 0x80; // Extract least significant 7 bits and set continuation bit\n        this.offset++;\n        x >>>= 7; // Use unsigned shift here\n      }\n      this.buffer[this.offset] = x & 0x7f; // No need for 0xff here since we're limiting it to 7 bits\n      this.offset++;\n      return;\n    }\n    this.ensureCapacity(10);\n\n    let lo = 0;\n    let hi = 0;\n    if (x !== 0) {\n      lo = x >>> 0;\n      hi = ((x - lo) / 4294967296) >>> 0;\n    }\n\n    while (hi) {\n      this.buffer[this.offset++] = (lo & 127) | 128;\n      lo = ((lo >>> 7) | (hi << 25)) >>> 0;\n      hi >>>= 7;\n    }\n    while (lo > 127) {\n      this.buffer[this.offset++] = (lo & 127) | 128;\n      lo = lo >>> 7;\n    }\n    this.buffer[this.offset++] = lo;\n  }\n\n  public writeVarint(x: number) {\n    if (x >= 0) {\n      this.writeUVarint(x * 2);\n    } else {\n      this.writeUVarint(-x * 2 - 1);\n    }\n  }\n\n  public writeLengthPrefixedString(value: string, varint = false, negativeLength = false) {\n    /*\n     Try fast case first - no non-ascii characters and byte length is string length.\n\n     Even if this case fails (non-ascii character found) the data will always be\n     shorter so it can be overwritten\n    */\n    const originalOffset = this.offset; // store this in case we need to overwrite from here\n    // Just write the length of the string (not the known encoded length)\n    if (varint) {\n      this.writeVarint(negativeLength ? -value.length : value.length);\n    } else {\n      this.writeUVarint(value.length);\n    }\n    this.ensureCapacity(value.length); // Ensure we have enough space for the string\n    let nonAscii = false;\n    for (let i = 0; i < value.length; i++) {\n      const charCode = value.charCodeAt(i);\n      if (charCode > 0x7f) {\n        nonAscii = true;\n        break;\n      }\n      this.buffer[this.offset++] = charCode;\n    }\n\n    if (!nonAscii) {\n      return;\n    }\n\n    /*\n     If we have non-ascii characters, we need to encode the string respecting\n     utf-8 and overwrite the buffer from the original offset\n    */\n    this.offset = originalOffset; // overwrite the length\n    let encodedLength = value.length; // This will be overwritten once we know the actual length\n    this.ensureCapacity(encodedLength); // This will be at least the required length, but it gives the chance of initially creating a large enough buffer\n    while (true) {\n      this.offset = originalOffset;\n      if (varint) {\n        this.writeVarint(negativeLength ? -encodedLength : encodedLength);\n      } else {\n        this.writeUVarint(encodedLength);\n      }\n      const offsetAfterVarint = this.offset;\n      const varintLength = offsetAfterVarint - originalOffset;\n\n      const writeBuffer = new Uint8Array(this.buffer.buffer, this.offset);\n      const { read, written } = textEncoder.encodeInto(value, writeBuffer);\n      if (read !== value.length) {\n        // Need more space and try again\n        this.expandBuffer();\n        continue;\n      }\n      if (written !== encodedLength) {\n        encodedLength = written;\n        // We need to overwrite the varint with the correct length\n        this.offset = originalOffset;\n        if (varint) {\n          this.writeVarint(negativeLength ? -encodedLength : encodedLength);\n        } else {\n          this.writeUVarint(encodedLength);\n        }\n        const newOffsetAfterVarint = this.offset;\n        const actualVarintLength = newOffsetAfterVarint - originalOffset;\n        if (actualVarintLength !== varintLength) {\n          // The varint length changed and it has overwritten the string\n          // We need to write the string again\n          continue;\n        } else {\n          // The varint length is the same so the string is intact\n        }\n      }\n      // String written successfully - update the offset\n      this.offset += written;\n      return;\n    }\n  }\n}\n", "import { BufferReader } from \"../BufferReader\";\nimport { BufferWriter } from \"../BufferWriter\";\n\nexport function encodeAttribute(writer: BufferWriter, key: string, value: string | null) {\n  if (value === null) {\n    writer.writeLengthPrefixedString(key, true, true);\n  } else {\n    writer.writeLengthPrefixedString(key, true, false);\n    writer.writeLengthPrefixedString(value);\n  }\n}\n\nexport function encodeAttributes(writer: BufferWriter, attributes: Array<[string, string | null]>) {\n  writer.writeUVarint(attributes.length);\n\n  for (let i = 0; i < attributes.length; i++) {\n    encodeAttribute(writer, attributes[i][0], attributes[i][1]);\n  }\n}\n\nexport function decodeAttributes(buffer: BufferReader): Array<[string, string | null]> {\n  const attributesLength = buffer.readUVarint();\n  const attributes: Array<[string, string | null]> = [];\n  for (let i = 0; i < attributesLength; i++) {\n    const [key, negativeLength] = buffer.readVarintPrefixedString();\n    if (negativeLength) {\n      attributes.push([key, null]);\n      continue;\n    }\n    const value = buffer.readUVarintPrefixedString();\n    attributes.push([key, value]);\n  }\n  return attributes;\n}\n", "import { BufferReader } from \"../BufferReader\";\nimport { BufferWriter } from \"../BufferWriter\";\nimport { decodeAttributes, encodeAttributes } from \"./attributes\";\n\nexport type NetworkedDOMV02TextNodeDescription = {\n  type: \"text\";\n  nodeId: number;\n  text: string;\n};\n\nexport type NetworkedDOMV02ElementNodeDescription = {\n  type: \"element\";\n  nodeId: number;\n  tag: string;\n  attributes: Array<[string, string | null]>;\n  children: Array<NetworkedDOMV02NodeDescription>;\n  visibleTo?: Array<number>;\n  hiddenFrom?: Array<number>;\n  text?: string;\n};\n\nexport type NetworkedDOMV02NodeDescription =\n  | NetworkedDOMV02ElementNodeDescription\n  | NetworkedDOMV02TextNodeDescription;\n\nexport function encodeNodeDescription(\n  writer: BufferWriter,\n  nodeDescription: NetworkedDOMV02NodeDescription,\n): void {\n  writer.writeUVarint(nodeDescription.nodeId);\n\n  if (nodeDescription.type === \"text\") {\n    writer.writeLengthPrefixedString(\"\"); // Empty tag indicates text node\n    writer.writeLengthPrefixedString(nodeDescription.text);\n    return;\n  }\n\n  writer.writeLengthPrefixedString(nodeDescription.tag);\n\n  encodeAttributes(writer, nodeDescription.attributes);\n\n  if (!nodeDescription.visibleTo) {\n    writer.writeUVarint(0);\n  } else {\n    writer.writeUVarint(nodeDescription.visibleTo.length);\n    for (let i = 0; i < nodeDescription.visibleTo.length; i++) {\n      writer.writeUVarint(nodeDescription.visibleTo[i]);\n    }\n  }\n\n  if (!nodeDescription.hiddenFrom) {\n    writer.writeUVarint(0);\n  } else {\n    writer.writeUVarint(nodeDescription.hiddenFrom.length);\n    for (let i = 0; i < nodeDescription.hiddenFrom.length; i++) {\n      writer.writeUVarint(nodeDescription.hiddenFrom[i]);\n    }\n  }\n\n  writer.writeUVarint(nodeDescription.children.length);\n  for (let i = 0; i < nodeDescription.children.length; i++) {\n    encodeNodeDescription(writer, nodeDescription.children[i]);\n  }\n}\n\nexport function decodeNodeDescription(buffer: BufferReader): NetworkedDOMV02NodeDescription {\n  const nodeId = buffer.readUVarint();\n  const tag = buffer.readUVarintPrefixedString();\n  if (tag === \"\") {\n    // Text node\n    const text = buffer.readUVarintPrefixedString();\n    return { type: \"text\", nodeId, text };\n  }\n\n  const attributes = decodeAttributes(buffer);\n\n  const visibleToLength = buffer.readUVarint();\n  let visibleTo: number[] | undefined;\n  if (visibleToLength !== 0) {\n    visibleTo = [];\n    for (let i = 0; i < visibleToLength; i++) {\n      visibleTo.push(buffer.readUVarint());\n    }\n  }\n\n  const hiddenFromLength = buffer.readUVarint();\n  let hiddenFrom: number[] | undefined;\n  if (hiddenFromLength !== 0) {\n    hiddenFrom = [];\n    for (let i = 0; i < hiddenFromLength; i++) {\n      hiddenFrom.push(buffer.readUVarint());\n    }\n  }\n\n  const childrenLength = buffer.readUVarint();\n  const children: NetworkedDOMV02NodeDescription[] = [];\n  for (let i = 0; i < childrenLength; i++) {\n    children.push(decodeNodeDescription(buffer));\n  }\n\n  const node: NetworkedDOMV02ElementNodeDescription = {\n    type: \"element\",\n    nodeId,\n    tag,\n    attributes,\n    children,\n  };\n\n  if (visibleTo) {\n    node.visibleTo = visibleTo;\n  }\n  if (hiddenFrom) {\n    node.hiddenFrom = hiddenFrom;\n  }\n\n  return node;\n}\n", "export const networkedDOMProtocolSubProtocol_v0_2 = \"networked-dom-v0.2\";\nexport const networkedDOMProtocolSubProtocol_v0_2_1 = \"networked-dom-v0.2.1\";\n\n// In priority order, from most preferred to least preferred\nexport const networkedDOMProtocolSubProtocol_v0_2_SubVersionsList = [\n  networkedDOMProtocolSubProtocol_v0_2_1,\n  networkedDOMProtocolSubProtocol_v0_2,\n] as const;\n\nexport type networkedDOMProtocolSubProtocol_v0_2_Subversion =\n  (typeof networkedDOMProtocolSubProtocol_v0_2_SubVersionsList)[number];\n\nexport type networkedDOMProtocolSubProtocol_v0_2_SubversionNumber = 0 | 1;\n\nconst protocolSubVersionMap: Record<\n  networkedDOMProtocolSubProtocol_v0_2_Subversion,\n  networkedDOMProtocolSubProtocol_v0_2_SubversionNumber\n> = {\n  [networkedDOMProtocolSubProtocol_v0_2]: 0,\n  [networkedDOMProtocolSubProtocol_v0_2_1]: 1,\n};\n\nexport function getNetworkedDOMProtocolSubProtocol_v0_2Subversion(\n  protocol: networkedDOMProtocolSubProtocol_v0_2_Subversion,\n): networkedDOMProtocolSubProtocol_v0_2_SubversionNumber | null {\n  return protocolSubVersionMap[protocol] ?? null;\n}\n\nexport function getNetworkedDOMProtocolSubProtocol_v0_2SubversionOrThrow(\n  protocol: networkedDOMProtocolSubProtocol_v0_2_Subversion,\n): networkedDOMProtocolSubProtocol_v0_2_SubversionNumber {\n  const subversion = getNetworkedDOMProtocolSubProtocol_v0_2Subversion(protocol);\n  if (subversion === null) {\n    throw new Error(`Unrecognized networked-dom-v0.2 protocol subversion: ${protocol}`);\n  }\n  return subversion;\n}\n\nexport function isNetworkedDOMProtocolSubProtocol_v0_2(\n  protocol: string,\n): protocol is (typeof networkedDOMProtocolSubProtocol_v0_2_SubVersionsList)[number] {\n  return networkedDOMProtocolSubProtocol_v0_2_SubVersionsList.includes(protocol as any);\n}\n", "import { networkedDOMProtocolSubProtocol_v0_2_SubversionNumber } from \"./constants\";\n\n// Whether the given protocol subversion supports the `connectionTokens` field in the `connectUsers` message\nexport function protocolSubversionHasConnectionTokens(\n  protocolSubversion: networkedDOMProtocolSubProtocol_v0_2_SubversionNumber,\n) {\n  return protocolSubversion >= 1;\n}\n", "// Server -> Client\nexport const SnapshotMessageType = 1;\nexport const BatchStartMessageType = 2;\nexport const DocumentTimeMessageType = 3;\nexport const ChildrenAddedMessageType = 4;\nexport const ChildrenRemovedMessageType = 5;\nexport const AttributesChangedMessageType = 6;\nexport const ChangeVisibleToMessageType = 7;\nexport const ChangeHiddenFromMessageType = 8;\nexport const TextChangedMessageType = 9;\nexport const BatchEndMessageType = 10;\nexport const PingMessageType = 11;\nexport const WarningMessageType = 12;\nexport const ErrorMessageType = 13;\n\n// Client -> Server\nexport const ConnectUsersMessageType = 14;\nexport const DisconnectUsersMessageType = 15;\nexport const EventMessageType = 16;\nexport const PongMessageType = 17;\n", "import { BufferReader } from \"../../BufferReader\";\nimport { BufferWriter } from \"../../BufferWriter\";\nimport { networkedDOMProtocolSubProtocol_v0_2_SubversionNumber } from \"../../constants\";\nimport { protocolSubversionHasConnectionTokens } from \"../../featureDetection\";\nimport { ConnectUsersMessageType } from \"../../messageTypes\";\n\nexport type NetworkedDOMV02ConnectUsersMessage = {\n  type: \"connectUsers\";\n  connectionIds: Array<number>;\n  // Enabled in networked-dom-v0.2.1 and above\n  connectionTokens: Array<string | null>; // Optional tokens for each connection ID. On decoding empty string will be interpreted as null\n};\n\nexport function encodeConnectUsers(\n  connectUsersMessage: NetworkedDOMV02ConnectUsersMessage,\n  writer: BufferWriter,\n  protocolSubversion: networkedDOMProtocolSubProtocol_v0_2_SubversionNumber,\n) {\n  const connectionIdsLength = connectUsersMessage.connectionIds.length;\n  writer.writeUint8(ConnectUsersMessageType);\n  writer.writeUVarint(connectionIdsLength);\n  for (let i = 0; i < connectionIdsLength; i++) {\n    writer.writeUVarint(connectUsersMessage.connectionIds[i]);\n  }\n  if (protocolSubversionHasConnectionTokens(protocolSubversion)) {\n    if (connectUsersMessage.connectionTokens.length !== connectionIdsLength) {\n      throw new Error(\n        `connectionTokens length (${connectUsersMessage.connectionTokens.length}) does not match connectionIds length (${connectionIdsLength})`,\n      );\n    }\n    for (let i = 0; i < connectionIdsLength; i++) {\n      const token = connectUsersMessage.connectionTokens[i];\n      if (token === null || token === undefined) {\n        writer.writeUVarint(0); // Length 0 means no token\n      } else {\n        writer.writeLengthPrefixedString(token);\n      }\n    }\n  }\n}\n\n// Assumes that the first byte has already been read (the message type)\nexport function decodeConnectUsers(\n  buffer: BufferReader,\n  protocolSubversion: networkedDOMProtocolSubProtocol_v0_2_SubversionNumber,\n): NetworkedDOMV02ConnectUsersMessage {\n  const connectionIds: number[] = [];\n  const connectionIdsLength = buffer.readUVarint();\n  for (let i = 0; i < connectionIdsLength; i++) {\n    connectionIds.push(buffer.readUVarint());\n  }\n  const connectionTokens: Array<string | null> = [];\n  if (protocolSubversionHasConnectionTokens(protocolSubversion)) {\n    for (let i = 0; i < connectionIdsLength; i++) {\n      const token = buffer.readUVarintPrefixedString();\n      if (token === \"\") {\n        connectionTokens.push(null);\n      } else {\n        connectionTokens.push(token);\n      }\n    }\n  } else {\n    // This client doesn't support connection tokens, so fill with nulls for the server to interpret as \"no token\"\n    for (let i = 0; i < connectionIdsLength; i++) {\n      connectionTokens.push(null);\n    }\n  }\n  return {\n    type: \"connectUsers\",\n    connectionIds,\n    connectionTokens,\n  };\n}\n", "import { BufferReader } from \"../../BufferReader\";\nimport { BufferWriter } from \"../../BufferWriter\";\nimport { DisconnectUsersMessageType } from \"../../messageTypes\";\n\nexport type NetworkedDOMV02DisconnectUsersMessage = {\n  type: \"disconnectUsers\";\n  connectionIds: Array<number>;\n};\n\nexport function encodeDisconnectUsers(\n  disconnectUsersMessage: NetworkedDOMV02DisconnectUsersMessage,\n  writer: BufferWriter,\n) {\n  const connectionIdsLength = disconnectUsersMessage.connectionIds.length;\n  writer.writeUint8(DisconnectUsersMessageType);\n  writer.writeUVarint(connectionIdsLength);\n  for (let i = 0; i < connectionIdsLength; i++) {\n    writer.writeUVarint(disconnectUsersMessage.connectionIds[i]);\n  }\n}\n\n// Assumes that the first byte has already been read (the message type)\nexport function decodeDisconnectUsers(buffer: BufferReader): NetworkedDOMV02DisconnectUsersMessage {\n  const connectionIds: number[] = [];\n  const connectionIdsLength = buffer.readUVarint();\n  for (let i = 0; i < connectionIdsLength; i++) {\n    connectionIds.push(buffer.readUVarint());\n  }\n  return {\n    type: \"disconnectUsers\",\n    connectionIds,\n  };\n}\n", "import { BufferReader } from \"../../BufferReader\";\nimport { BufferWriter } from \"../../BufferWriter\";\nimport { EventMessageType } from \"../../messageTypes\";\n\nexport type NetworkedDOMV02RemoteEvent = {\n  type: \"event\";\n  connectionId: number;\n  nodeId: number;\n  name: string;\n  bubbles: boolean;\n  params: any;\n};\n\nexport function encodeEvent(event: NetworkedDOMV02RemoteEvent, writer: BufferWriter) {\n  writer.writeUint8(EventMessageType);\n  writer.writeUVarint(event.nodeId);\n  writer.writeUVarint(event.connectionId);\n  writer.writeLengthPrefixedString(event.name);\n  writer.writeBoolean(event.bubbles);\n  writer.writeLengthPrefixedString(JSON.stringify(event.params));\n}\n\n// Assumes that the first byte has already been read (the message type)\nexport function decodeEvent(buffer: BufferReader): NetworkedDOMV02RemoteEvent {\n  const nodeId = buffer.readUVarint();\n  const connectionId = buffer.readUVarint();\n  const name = buffer.readUVarintPrefixedString();\n  const bubbles = buffer.readBoolean();\n  const paramsJSONString = buffer.readUVarintPrefixedString();\n  const params = JSON.parse(paramsJSONString);\n  return {\n    type: \"event\",\n    nodeId,\n    connectionId,\n    name,\n    bubbles,\n    params,\n  };\n}\n", "import { BufferReader } from \"../../BufferReader\";\nimport { BufferWriter } from \"../../BufferWriter\";\nimport { PongMessageType } from \"../../messageTypes\";\n\nexport type NetworkedDOMV02PongMessage = {\n  type: \"pong\";\n  pong: number;\n};\n\nexport function encodePong(pongMessage: NetworkedDOMV02PongMessage, writer: BufferWriter) {\n  writer.writeUint8(PongMessageType);\n  writer.writeUVarint(pongMessage.pong);\n}\n\n// Assumes that the first byte has already been read (the message type)\nexport function decodePong(buffer: BufferReader): NetworkedDOMV02PongMessage {\n  const pong = buffer.readUVarint();\n  return {\n    type: \"pong\",\n    pong,\n  };\n}\n", "import { BufferReader } from \"./BufferReader\";\nimport { networkedDOMProtocolSubProtocol_v0_2_SubversionNumber } from \"./constants\";\nimport { NetworkedDOMV02ClientMessage } from \"./messages\";\nimport { decodeConnectUsers } from \"./messages/from-client/connectUsers\";\nimport { decodeDisconnectUsers } from \"./messages/from-client/disconnectUsers\";\nimport { decodeEvent } from \"./messages/from-client/event\";\nimport { decodePong } from \"./messages/from-client/pong\";\nimport {\n  ConnectUsersMessageType,\n  DisconnectUsersMessageType,\n  EventMessageType,\n  PongMessageType,\n} from \"./messageTypes\";\n\nexport function decodeClientMessages(\n  buffer: BufferReader,\n  protocolSubversion: networkedDOMProtocolSubProtocol_v0_2_SubversionNumber,\n): Array<NetworkedDOMV02ClientMessage> {\n  const messages: NetworkedDOMV02ClientMessage[] = [];\n  while (!buffer.isEnd()) {\n    const messageType = buffer.readUInt8();\n    switch (messageType) {\n      case ConnectUsersMessageType:\n        messages.push(decodeConnectUsers(buffer, protocolSubversion));\n        break;\n      case DisconnectUsersMessageType:\n        messages.push(decodeDisconnectUsers(buffer));\n        break;\n      case EventMessageType:\n        messages.push(decodeEvent(buffer));\n        break;\n      case PongMessageType:\n        messages.push(decodePong(buffer));\n        break;\n      default:\n        throw new Error(`Unknown message type: ${messageType}`);\n    }\n  }\n  return messages;\n}\n", "import { BufferReader } from \"../../BufferReader\";\nimport { BufferWriter } from \"../../BufferWriter\";\nimport { decodeAttributes, encodeAttributes } from \"../../common-structs/attributes\";\nimport { AttributesChangedMessageType } from \"../../messageTypes\";\n\nexport type NetworkedDOMV02AttributesChangedDiff = {\n  type: \"attributesChanged\";\n  nodeId: number;\n  attributes: Array<[string, string | null]>;\n  documentTime?: number;\n};\n\nexport function encodeAttributesChanged(\n  msg: NetworkedDOMV02AttributesChangedDiff,\n  writer: BufferWriter = new BufferWriter(64),\n): BufferWriter {\n  writer.writeUint8(AttributesChangedMessageType);\n  writer.writeUVarint(msg.nodeId);\n  encodeAttributes(writer, msg.attributes);\n  return writer;\n}\n\n// Assumes that the first byte has already been read (the message type)\nexport function decodeAttributesChanged(\n  buffer: BufferReader,\n): NetworkedDOMV02AttributesChangedDiff {\n  const nodeId = buffer.readUVarint();\n  const attributes = decodeAttributes(buffer);\n  return {\n    type: \"attributesChanged\",\n    nodeId,\n    attributes,\n  };\n}\n", "import { BufferWriter } from \"../../BufferWriter\";\nimport { BatchEndMessageType } from \"../../messageTypes\";\n\nexport type NetworkedDOMV02BatchEndMessage = {\n  type: \"batchEnd\";\n};\n\nexport function encodeBatchEnd(writer: BufferWriter = new BufferWriter(1)): BufferWriter {\n  writer.writeUint8(BatchEndMessageType);\n  return writer;\n}\n\nexport const batchEndMessage: NetworkedDOMV02BatchEndMessage = {\n  type: \"batchEnd\",\n};\n", "import { BufferWriter } from \"../../BufferWriter\";\nimport { BatchStartMessageType } from \"../../messageTypes\";\n\nexport type NetworkedDOMV02BatchStartMessage = {\n  type: \"batchStart\";\n};\n\nexport function encodeBatchStart(writer: BufferWriter = new BufferWriter(1)): BufferWriter {\n  writer.writeUint8(BatchStartMessageType);\n  return writer;\n}\n\nexport const batchStartMessage: NetworkedDOMV02BatchStartMessage = {\n  type: \"batchStart\",\n};\n", "import { BufferReader } from \"../../BufferReader\";\nimport { BufferWriter } from \"../../BufferWriter\";\nimport { ChangeHiddenFromMessageType } from \"../../messageTypes\";\n\nexport type NetworkedDOMV02ChangeHiddenFromDiff = {\n  type: \"changeHiddenFrom\";\n  nodeId: number;\n  addHiddenFrom: Array<number>;\n  removeHiddenFrom: Array<number>;\n};\n\nexport function encodeChangeHiddenFrom(\n  msg: NetworkedDOMV02ChangeHiddenFromDiff,\n  writer: BufferWriter = new BufferWriter(64),\n): BufferWriter {\n  writer.writeUint8(ChangeHiddenFromMessageType);\n  writer.writeUVarint(msg.nodeId);\n\n  if (msg.addHiddenFrom) {\n    writer.writeUVarint(msg.addHiddenFrom.length);\n\n    for (const key of msg.addHiddenFrom) {\n      writer.writeUVarint(key);\n    }\n  } else {\n    // If there are no addHiddenFrom, we still need to send a 0 to indicate that there are no entries\n    writer.writeUVarint(0);\n  }\n  if (msg.removeHiddenFrom) {\n    writer.writeUVarint(msg.removeHiddenFrom.length);\n\n    for (const key of msg.removeHiddenFrom) {\n      writer.writeUVarint(key);\n    }\n  } else {\n    // If there are no removeHiddenFrom, we still need to send a 0 to indicate that there are no entries\n    writer.writeUVarint(0);\n  }\n  return writer;\n}\n\n// Assumes that the first byte has already been read (the message type)\nexport function decodeChangeHiddenFrom(buffer: BufferReader): NetworkedDOMV02ChangeHiddenFromDiff {\n  const nodeId = buffer.readUVarint();\n  const addHiddenFromLength = buffer.readUVarint();\n  const addHiddenFrom: number[] = [];\n  for (let i = 0; i < addHiddenFromLength; i++) {\n    addHiddenFrom.push(buffer.readUVarint());\n  }\n\n  const removeHiddenFromLength = buffer.readUVarint();\n  const removeHiddenFrom: number[] = [];\n  for (let i = 0; i < removeHiddenFromLength; i++) {\n    removeHiddenFrom.push(buffer.readUVarint());\n  }\n\n  return {\n    type: \"changeHiddenFrom\",\n    nodeId,\n    addHiddenFrom,\n    removeHiddenFrom,\n  };\n}\n", "import { BufferReader } from \"../../BufferReader\";\nimport { BufferWriter } from \"../../BufferWriter\";\nimport { ChangeVisibleToMessageType } from \"../../messageTypes\";\n\nexport type NetworkedDOMV02ChangeVisibleToDiff = {\n  type: \"changeVisibleTo\";\n  nodeId: number;\n  /*\n   The semantics are that if there are no visibleTo limitations then the node is visible to everyone.\n\n   It is advisable to apply the addVisibleTo first before the removeVisibleTo to avoid even a temporary state where a node is visible to everyone between the two operations.\n  */\n  addVisibleTo: Array<number>;\n  removeVisibleTo: Array<number>;\n};\n\nexport function encodeChangeVisibleTo(\n  msg: NetworkedDOMV02ChangeVisibleToDiff,\n  writer: BufferWriter = new BufferWriter(64),\n): BufferWriter {\n  writer.writeUint8(ChangeVisibleToMessageType);\n  writer.writeUVarint(msg.nodeId);\n\n  if (msg.addVisibleTo) {\n    writer.writeUVarint(msg.addVisibleTo.length);\n\n    for (const key of msg.addVisibleTo) {\n      writer.writeUVarint(key);\n    }\n  } else {\n    // If there are no addVisibleTo, we still need to send a 0 to indicate that there are no entries\n    writer.writeUVarint(0);\n  }\n  if (msg.removeVisibleTo) {\n    writer.writeUVarint(msg.removeVisibleTo.length);\n\n    for (const key of msg.removeVisibleTo) {\n      writer.writeUVarint(key);\n    }\n  } else {\n    // If there are no removeVisibleTo, we still need to send a 0 to indicate that there are no entries\n    writer.writeUVarint(0);\n  }\n  return writer;\n}\n\n// Assumes that the first byte has already been read (the message type)\nexport function decodeChangeVisibleTo(buffer: BufferReader): NetworkedDOMV02ChangeVisibleToDiff {\n  const nodeId = buffer.readUVarint();\n  const addVisibleToLength = buffer.readUVarint();\n  const addVisibleTo: number[] = [];\n  for (let i = 0; i < addVisibleToLength; i++) {\n    addVisibleTo.push(buffer.readUVarint());\n  }\n\n  const removeVisibleToLength = buffer.readUVarint();\n  const removeVisibleTo: number[] = [];\n  for (let i = 0; i < removeVisibleToLength; i++) {\n    removeVisibleTo.push(buffer.readUVarint());\n  }\n\n  return {\n    type: \"changeVisibleTo\",\n    nodeId,\n    addVisibleTo,\n    removeVisibleTo,\n  };\n}\n", "import { BufferReader } from \"../../BufferReader\";\nimport { BufferWriter } from \"../../BufferWriter\";\nimport {\n  decodeNodeDescription,\n  encodeNodeDescription,\n  NetworkedDOMV02NodeDescription,\n} from \"../../common-structs/nodeDescription\";\nimport { ChildrenAddedMessageType } from \"../../messageTypes\";\n\nexport type NetworkedDOMV02ChildrenAddedDiff = {\n  type: \"childrenAdded\";\n  nodeId: number;\n  previousNodeId: number | null;\n  addedNodes: Array<NetworkedDOMV02NodeDescription>;\n};\n\nexport function encodeChildrenAdded(\n  msg: NetworkedDOMV02ChildrenAddedDiff,\n  writer: BufferWriter = new BufferWriter(64),\n): BufferWriter {\n  writer.writeUint8(ChildrenAddedMessageType);\n  writer.writeUVarint(msg.nodeId);\n  writer.writeUVarint(msg.previousNodeId ?? 0);\n  writer.writeUVarint(msg.addedNodes.length);\n  for (let i = 0; i < msg.addedNodes.length; i++) {\n    encodeNodeDescription(writer, msg.addedNodes[i]);\n  }\n  return writer;\n}\n\n// Assumes that the first byte has already been read (the message type)\nexport function decodeChildrenAdded(buffer: BufferReader): NetworkedDOMV02ChildrenAddedDiff {\n  const nodeId = buffer.readUVarint();\n  const previousNodeId = buffer.readUVarint();\n  const childrenLength = buffer.readUVarint();\n  const children: NetworkedDOMV02NodeDescription[] = [];\n  for (let i = 0; i < childrenLength; i++) {\n    children.push(decodeNodeDescription(buffer));\n  }\n  return {\n    type: \"childrenAdded\",\n    nodeId,\n    previousNodeId: previousNodeId === 0 ? null : previousNodeId,\n    addedNodes: children,\n  };\n}\n", "import { BufferReader } from \"../../BufferReader\";\nimport { BufferWriter } from \"../../BufferWriter\";\nimport { ChildrenRemovedMessageType } from \"../../messageTypes\";\n\nexport type NetworkedDOMV02ChildrenRemovedDiff = {\n  type: \"childrenRemoved\";\n  nodeId: number;\n  removedNodes: Array<number>;\n  documentTime?: number;\n};\n\nexport function encodeChildrenRemoved(\n  msg: NetworkedDOMV02ChildrenRemovedDiff,\n  writer: BufferWriter = new BufferWriter(64),\n): BufferWriter {\n  writer.writeUint8(ChildrenRemovedMessageType);\n  writer.writeUVarint(msg.nodeId);\n  writer.writeUVarint(msg.removedNodes.length);\n  for (const nodeId of msg.removedNodes) {\n    writer.writeUVarint(nodeId);\n  }\n  return writer;\n}\n\n// Assumes that the first byte has already been read (the message type)\nexport function decodeChildrenRemoved(buffer: BufferReader): NetworkedDOMV02ChildrenRemovedDiff {\n  const nodeId = buffer.readUVarint();\n  const removedNodesLength = buffer.readUVarint();\n  const removedNodes: number[] = [];\n  for (let i = 0; i < removedNodesLength; i++) {\n    removedNodes.push(buffer.readUVarint());\n  }\n  return {\n    type: \"childrenRemoved\",\n    nodeId,\n    removedNodes,\n  };\n}\n", "import { BufferReader } from \"../../BufferReader\";\nimport { BufferWriter } from \"../../BufferWriter\";\nimport { DocumentTimeMessageType } from \"../../messageTypes\";\n\nexport type NetworkedDOMV02DocumentTimeMessage = {\n  type: \"documentTime\";\n  documentTime: number;\n};\n\nexport function encodeDocumentTime(\n  msg: NetworkedDOMV02DocumentTimeMessage,\n  writer: BufferWriter = new BufferWriter(8),\n): BufferWriter {\n  writer.writeUint8(DocumentTimeMessageType);\n  writer.writeUVarint(msg.documentTime);\n  return writer;\n}\n\n// Assumes that the first byte has already been read (the message type)\nexport function decodeDocumentTime(buffer: BufferReader): NetworkedDOMV02DocumentTimeMessage {\n  return {\n    type: \"documentTime\",\n    documentTime: buffer.readUVarint(),\n  };\n}\n", "import { BufferReader } from \"../../BufferReader\";\nimport { BufferWriter } from \"../../BufferWriter\";\nimport { ErrorMessageType } from \"../../messageTypes\";\n\nexport type NetworkedDOMV02ErrorMessage = {\n  type: \"error\";\n  message: string;\n};\n\nexport function encodeError(\n  msg: NetworkedDOMV02ErrorMessage,\n  writer: BufferWriter = new BufferWriter(64),\n): BufferWriter {\n  writer.writeUint8(ErrorMessageType);\n  writer.writeLengthPrefixedString(msg.message);\n  return writer;\n}\n\n// Assumes that the first byte has already been read (the message type)\nexport function decodeError(buffer: BufferReader): NetworkedDOMV02ErrorMessage {\n  const message = buffer.readUVarintPrefixedString();\n  return {\n    type: \"error\",\n    message,\n  };\n}\n", "import { BufferReader } from \"../../BufferReader\";\nimport { BufferWriter } from \"../../BufferWriter\";\nimport { PingMessageType } from \"../../messageTypes\";\n\nexport type NetworkedDOMV02PingMessage = {\n  type: \"ping\";\n  ping: number;\n  documentTime: number;\n};\n\nexport function encodePing(\n  pingMessage: NetworkedDOMV02PingMessage,\n  writer: BufferWriter = new BufferWriter(8),\n): BufferWriter {\n  writer.writeUint8(PingMessageType);\n  writer.writeUVarint(pingMessage.ping);\n  writer.writeUVarint(pingMessage.documentTime);\n  return writer;\n}\n\n// Assumes that the first byte has already been read (the message type)\nexport function decodePing(buffer: BufferReader): NetworkedDOMV02PingMessage {\n  const ping = buffer.readUVarint();\n  const documentTime = buffer.readUVarint();\n  return {\n    type: \"ping\",\n    ping,\n    documentTime,\n  };\n}\n", "import { BufferReader } from \"../../BufferReader\";\nimport { BufferWriter } from \"../../BufferWriter\";\nimport {\n  decodeNodeDescription,\n  encodeNodeDescription,\n  NetworkedDOMV02ElementNodeDescription,\n  NetworkedDOMV02NodeDescription,\n} from \"../../common-structs/nodeDescription\";\nimport { SnapshotMessageType } from \"../../messageTypes\";\n\nexport type NetworkedDOMV02SnapshotMessage = {\n  type: \"snapshot\";\n  snapshot: NetworkedDOMV02NodeDescription;\n  documentTime: number;\n};\n\nexport function encodeSnapshot(\n  msg: NetworkedDOMV02SnapshotMessage,\n  writer: BufferWriter = new BufferWriter(64),\n): BufferWriter {\n  writer.writeUint8(SnapshotMessageType);\n  encodeNodeDescription(writer, msg.snapshot as NetworkedDOMV02ElementNodeDescription);\n  writer.writeUVarint(msg.documentTime);\n  return writer;\n}\n\n// Assumes that the first byte has already been read (the message type)\nexport function decodeSnapshot(buffer: BufferReader): NetworkedDOMV02SnapshotMessage {\n  return {\n    type: \"snapshot\",\n    snapshot: decodeNodeDescription(buffer),\n    documentTime: buffer.readUVarint(),\n  };\n}\n", "import { BufferReader } from \"../../BufferReader\";\nimport { BufferWriter } from \"../../BufferWriter\";\nimport { TextChangedMessageType } from \"../../messageTypes\";\n\nexport type NetworkedDOMV02TextChangedDiff = {\n  type: \"textChanged\";\n  nodeId: number;\n  text: string;\n};\n\nexport function encodeTextChanged(\n  msg: NetworkedDOMV02TextChangedDiff,\n  writer: BufferWriter = new BufferWriter(64),\n): BufferWriter {\n  writer.writeUint8(TextChangedMessageType);\n  writer.writeUVarint(msg.nodeId);\n  writer.writeLengthPrefixedString(msg.text);\n  return writer;\n}\n\n// Assumes that the first byte has already been read (the message type)\nexport function decodeTextChanged(buffer: BufferReader): NetworkedDOMV02TextChangedDiff {\n  const nodeId = buffer.readUVarint();\n  const text = buffer.readUVarintPrefixedString();\n  return {\n    type: \"textChanged\",\n    nodeId,\n    text,\n  };\n}\n", "import { BufferReader } from \"../../BufferReader\";\nimport { BufferWriter } from \"../../BufferWriter\";\nimport { WarningMessageType } from \"../../messageTypes\";\n\nexport type NetworkedDOMV02WarningMessage = {\n  type: \"warning\";\n  message: string;\n};\n\nexport function encodeWarning(\n  msg: NetworkedDOMV02WarningMessage,\n  writer: BufferWriter = new BufferWriter(64),\n): BufferWriter {\n  writer.writeUint8(WarningMessageType);\n  writer.writeLengthPrefixedString(msg.message);\n  return writer;\n}\n\n// Assumes that the first byte has already been read (the message type)\nexport function decodeWarning(buffer: BufferReader): NetworkedDOMV02WarningMessage {\n  const message = buffer.readUVarintPrefixedString();\n  return {\n    type: \"warning\",\n    message,\n  };\n}\n", "import { BufferReader } from \"./BufferReader\";\nimport {\n  batchEndMessage,\n  batchStartMessage,\n  decodeAttributesChanged,\n  decodeChangeHiddenFrom,\n  decodeChangeVisibleTo,\n  decodeChildrenAdded,\n  decodeChildrenRemoved,\n  decodeError,\n  decodePing,\n  decodeSnapshot,\n  decodeTextChanged,\n  decodeWarning,\n  NetworkedDOMV02ServerMessage,\n} from \"./messages\";\nimport { decodeDocumentTime } from \"./messages/from-server/documentTime\";\nimport {\n  AttributesChangedMessageType,\n  BatchEndMessageType,\n  BatchStartMessageType,\n  ChangeHiddenFromMessageType,\n  ChangeVisibleToMessageType,\n  ChildrenAddedMessageType,\n  ChildrenRemovedMessageType,\n  DocumentTimeMessageType,\n  ErrorMessageType,\n  PingMessageType,\n  SnapshotMessageType,\n  TextChangedMessageType,\n  WarningMessageType,\n} from \"./messageTypes\";\n\nexport function decodeServerMessages(buffer: BufferReader): Array<NetworkedDOMV02ServerMessage> {\n  const messages: NetworkedDOMV02ServerMessage[] = [];\n  while (!buffer.isEnd()) {\n    const messageType = buffer.readUInt8();\n    switch (messageType) {\n      case SnapshotMessageType:\n        messages.push(decodeSnapshot(buffer));\n        break;\n      case DocumentTimeMessageType:\n        messages.push(decodeDocumentTime(buffer));\n        break;\n      case ChildrenAddedMessageType:\n        messages.push(decodeChildrenAdded(buffer));\n        break;\n      case ChildrenRemovedMessageType:\n        messages.push(decodeChildrenRemoved(buffer));\n        break;\n      case AttributesChangedMessageType:\n        messages.push(decodeAttributesChanged(buffer));\n        break;\n      case TextChangedMessageType:\n        messages.push(decodeTextChanged(buffer));\n        break;\n      case ChangeVisibleToMessageType:\n        messages.push(decodeChangeVisibleTo(buffer));\n        break;\n      case ChangeHiddenFromMessageType:\n        messages.push(decodeChangeHiddenFrom(buffer));\n        break;\n      case BatchStartMessageType:\n        messages.push(batchStartMessage);\n        break;\n      case BatchEndMessageType:\n        messages.push(batchEndMessage);\n        break;\n      case PingMessageType:\n        messages.push(decodePing(buffer));\n        break;\n      case WarningMessageType:\n        messages.push(decodeWarning(buffer));\n        break;\n      case ErrorMessageType:\n        messages.push(decodeError(buffer));\n        break;\n      default:\n        throw new Error(`Unknown message type: ${messageType}`);\n    }\n  }\n  return messages;\n}\n", "import { BufferWriter } from \"./BufferWriter\";\nimport { networkedDOMProtocolSubProtocol_v0_2_SubversionNumber } from \"./constants\";\nimport {\n  encodeConnectUsers,\n  encodeDisconnectUsers,\n  encodeEvent,\n  encodePong,\n  NetworkedDOMV02ClientMessage,\n} from \"./messages\";\n\nexport function encodeClientMessage(\n  message: NetworkedDOMV02ClientMessage,\n  writer: BufferWriter,\n  protocolSubversion: networkedDOMProtocolSubProtocol_v0_2_SubversionNumber,\n) {\n  const type = message.type;\n  switch (type) {\n    case \"connectUsers\":\n      return encodeConnectUsers(message, writer, protocolSubversion);\n    case \"disconnectUsers\":\n      return encodeDisconnectUsers(message, writer);\n    case \"event\":\n      return encodeEvent(message, writer);\n    case \"pong\":\n      return encodePong(message, writer);\n    default:\n      throw new Error(`Unknown message type: ${type}`);\n  }\n}\n", "import { BufferWriter } from \"./BufferWriter\";\nimport {\n  encodeBatchEnd,\n  encodeBatchStart,\n  encodeTextChanged,\n  NetworkedDOMV02ServerMessage,\n} from \"./messages\";\nimport { encodeAttributesChanged } from \"./messages/from-server/attributesChanged\";\nimport { encodeChangeHiddenFrom } from \"./messages/from-server/changeHiddenFrom\";\nimport { encodeChangeVisibleTo } from \"./messages/from-server/changeVisibleTo\";\nimport { encodeChildrenAdded } from \"./messages/from-server/childrenAdded\";\nimport { encodeChildrenRemoved } from \"./messages/from-server/childrenRemoved\";\nimport { encodeDocumentTime } from \"./messages/from-server/documentTime\";\nimport { encodeError } from \"./messages/from-server/error\";\nimport { encodePing } from \"./messages/from-server/ping\";\nimport { encodeSnapshot } from \"./messages/from-server/snapshot\";\nimport { encodeWarning } from \"./messages/from-server/warning\";\n\nexport function encodeServerMessage(\n  message: NetworkedDOMV02ServerMessage,\n  writer?: BufferWriter,\n): BufferWriter {\n  switch (message.type) {\n    case \"snapshot\":\n      return encodeSnapshot(message, writer);\n    case \"documentTime\":\n      return encodeDocumentTime(message, writer);\n    case \"childrenAdded\":\n      return encodeChildrenAdded(message, writer);\n    case \"childrenRemoved\":\n      return encodeChildrenRemoved(message, writer);\n    case \"attributesChanged\":\n      return encodeAttributesChanged(message, writer);\n    case \"textChanged\":\n      return encodeTextChanged(message, writer);\n    case \"changeVisibleTo\":\n      return encodeChangeVisibleTo(message, writer);\n    case \"changeHiddenFrom\":\n      return encodeChangeHiddenFrom(message, writer);\n    case \"batchStart\":\n      return encodeBatchStart(writer);\n    case \"batchEnd\":\n      return encodeBatchEnd(writer);\n    case \"ping\":\n      return encodePing(message, writer);\n    case \"warning\":\n      return encodeWarning(message, writer);\n    case \"error\":\n      return encodeError(message, writer);\n    default:\n      throw new Error(`Unknown message type: ${(message as any).type}`);\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
