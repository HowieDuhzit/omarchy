{
  "version": 3,
  "sources": ["../src/BufferReader.ts", "../src/BufferWriter.ts", "../src/DeflateCompressor.ts", "../src/delta-net-v0.1/constants.ts", "../src/delta-net-v0.1/messageTypes.ts", "../src/delta-net-v0.1/messages/from-client/clientCustom.ts", "../src/delta-net-v0.1/messages/from-client/connectUser.ts", "../src/delta-net-v0.1/messages/from-client/pong.ts", "../src/delta-net-v0.1/messages/from-client/setUserComponents.ts", "../src/delta-net-v0.1/decodeClientMessages.ts", "../src/delta-net-v0.1/messages/from-server/error.ts", "../src/delta-net-v0.1/messages/from-server/initialCheckout.ts", "../src/delta-net-v0.1/messages/from-server/ping.ts", "../src/delta-net-v0.1/messages/from-server/serverCustom.ts", "../src/delta-net-v0.1/messages/from-server/tick.ts", "../src/delta-net-v0.1/messages/from-server/userIndex.ts", "../src/delta-net-v0.1/messages/from-server/warning.ts", "../src/delta-net-v0.1/decodeServerMessages.ts", "../src/delta-net-v0.1/encodeClientMessage.ts", "../src/delta-net-v0.1/encodeServerMessage.ts"],
  "sourcesContent": ["const textDecoder = new TextDecoder();\n\n/**\n * A class for reading binary data from a Uint8Array buffer.\n * Supports various data types including varints, strings, and boolean arrays.\n * All numeric values are read using varint encoding for efficiency.\n */\nexport class BufferReader {\n  private buffer: Uint8Array;\n  private offset: number;\n\n  /**\n   * Creates a new BufferReader instance.\n   * @param buffer - The Uint8Array to read from\n   */\n  constructor(buffer: Uint8Array) {\n    this.buffer = buffer;\n    this.offset = 0;\n  }\n\n  /**\n   * Reads a single unsigned 8-bit integer from the buffer.\n   * @returns The read value\n   */\n  public readUInt8(): number {\n    return this.buffer[this.offset++];\n  }\n\n  /**\n   * Reads a boolean value from the buffer.\n   * @returns true if the read byte is 1, false otherwise\n   */\n  public readBoolean(): boolean {\n    return this.readUInt8() === 1;\n  }\n\n  /**\n   * Reads a specified number of bytes from the buffer.\n   * @param length - The number of bytes to read\n   * @returns A new Uint8Array containing the read bytes\n   */\n  public readBytes(length: number): Uint8Array {\n    const bytes = this.buffer.subarray(this.offset, this.offset + length);\n    this.offset += length;\n    return bytes;\n  }\n\n  /**\n   * Reads a length-prefixed byte array from the buffer.\n   * The length is encoded as a varint.\n   * @returns A new Uint8Array containing the read bytes\n   */\n  public readUVarintPrefixedBytes(): Uint8Array {\n    const length = this.readUVarint();\n    return this.readBytes(length);\n  }\n\n  /**\n   * Reads a varint-encoded integer from the buffer.\n   * Varints are variable-length integers that use the high bit of each byte to indicate if more bytes follow.\n   * @param signed - Whether to interpret the value as a signed integer\n   * @returns The decoded integer value\n   * @throws Error if the varint encoding is invalid\n   */\n  public readUVarint(signed = false): number {\n    let lo = 0;\n    let hi = 0;\n    let i = 0;\n    for (; i < 4; ++i) {\n      lo = (lo | ((this.buffer[this.offset] & 127) << (i * 7))) >>> 0;\n      if (this.buffer[this.offset++] < 128) {\n        return signed ? loAndHiAsSigned(lo, hi) : loAndHiAsUnsigned(lo, hi);\n      }\n    }\n    lo = (lo | ((this.buffer[this.offset] & 127) << 28)) >>> 0;\n    hi = (hi | ((this.buffer[this.offset] & 127) >> 4)) >>> 0;\n    if (this.buffer[this.offset++] < 128) {\n      return signed ? loAndHiAsSigned(lo, hi) : loAndHiAsUnsigned(lo, hi);\n    }\n    i = 0;\n    for (; i < 5; ++i) {\n      hi = (hi | ((this.buffer[this.offset] & 127) << (i * 7 + 3))) >>> 0;\n      if (this.buffer[this.offset++] < 128) {\n        return signed ? loAndHiAsSigned(lo, hi) : loAndHiAsUnsigned(lo, hi);\n      }\n    }\n\n    throw Error(\"invalid varint encoding\");\n  }\n\n  /**\n   * Reads a string from the buffer with a specified byte length.\n   * Optimized for ASCII strings, falls back to TextDecoder for non-ASCII.\n   * @param byteLength - The number of bytes to read\n   * @returns The decoded string\n   */\n  private readStringBytes(byteLength: number): string {\n    let string = \"\";\n    let hasNonAscii = false;\n    for (let i = 0; i < byteLength; i++) {\n      const charValue = this.buffer[this.offset + i];\n      if (charValue < 0x80) {\n        string += String.fromCharCode(charValue);\n      } else {\n        hasNonAscii = true;\n        break;\n      }\n    }\n    if (!hasNonAscii) {\n      this.offset += byteLength;\n      return string;\n    }\n\n    // Slow path - decode the string using TextDecoder\n    const result = textDecoder.decode(this.buffer.subarray(this.offset, this.offset + byteLength));\n    this.offset += byteLength;\n    return result;\n  }\n\n  /**\n   * Reads a length-prefixed string from the buffer.\n   * The length is encoded as an unsigned varint.\n   * @returns The decoded string\n   */\n  public readUVarintPrefixedString(): string {\n    const readLength = this.readUVarint();\n    return this.readStringBytes(readLength);\n  }\n\n  /**\n   * Reads a length-prefixed string from the buffer.\n   * The length is encoded as a signed varint.\n   * @returns A tuple containing the decoded string and a boolean indicating if the length was negative\n   */\n  public readVarintPrefixedString(): [string, boolean] {\n    const length = this.readVarint();\n    const negativeLength = length < 0;\n    const readLength = negativeLength ? -length : length;\n    const result = this.readStringBytes(readLength);\n    return [result, negativeLength];\n  }\n\n  /**\n   * Reads a signed varint-encoded integer from the buffer.\n   * @returns The decoded signed integer value\n   */\n  public readVarint(): number {\n    return this.readUVarint(true);\n  }\n\n  /**\n   * Reads a varint-encoded bigint from the buffer.\n   * Varints are variable-length integers that use the high bit of each byte to indicate if more bytes follow.\n   * @param signed - Whether to interpret the value as a signed integer\n   * @returns The decoded bigint value\n   * @throws Error if the varint encoding is invalid\n   */\n  public readUVarintBigInt(signed = false): bigint {\n    let result = 0n;\n    let shift = 0n;\n    let byte: number;\n    let bytesRead = 0;\n\n    do {\n      if (bytesRead >= 10) {\n        throw Error(\"invalid varint encoding\");\n      }\n      byte = this.buffer[this.offset++];\n      result |= BigInt(byte & 0x7f) << shift;\n      shift += 7n;\n      bytesRead++;\n    } while (byte >= 0x80);\n\n    if (signed) {\n      // Convert from zigzag encoding\n      return result & 1n ? -(result + 1n) / 2n : result / 2n;\n    }\n\n    return result;\n  }\n\n  /**\n   * Reads a signed varint-encoded integer from the buffer.\n   * @returns The decoded signed integer value\n   */\n  public readBigIntVarint(): bigint {\n    return this.readUVarintBigInt(true);\n  }\n\n  /**\n   * Reads an array of boolean values from the buffer.\n   * The booleans are packed into bytes (8 booleans per byte).\n   * @returns An array of boolean values\n   */\n  public readLengthPrefixedBoolArray(): boolean[] {\n    // The length is the number of bools/bits to allow the reader to determine a non-multiple of 8 length and to allocate\n    const length = this.readUVarint();\n    // The booleans are packed into a single byte\n    const numBytes = Math.ceil(length / 8);\n    const result = new Array<boolean>(length);\n    for (let i = 0; i < length; i++) {\n      const byteIndex = Math.floor(i / 8);\n      const bitPosition = i % 8;\n      result[i] = !!(this.buffer[this.offset + byteIndex] & (1 << bitPosition));\n    }\n    this.offset += numBytes;\n    return result;\n  }\n\n  /**\n   * Checks if the reader has reached the end of the buffer.\n   * @returns true if all bytes have been read, false otherwise\n   */\n  public isEnd() {\n    return this.offset >= this.buffer.length;\n  }\n}\n\n/**\n * Converts a low and high 32-bit integer pair to a signed 64-bit integer.\n * @param lo - The low 32 bits\n * @param hi - The high 32 bits\n * @returns The signed 64-bit integer value\n */\nfunction loAndHiAsSigned(lo: number, hi: number) {\n  const value = lo + hi * 4294967296;\n  if (value & 1) {\n    return -(value + 1) / 2;\n  }\n  return value / 2;\n}\n\n/**\n * Converts a low and high 32-bit integer pair to an unsigned 64-bit integer.\n * @param lo - The low 32 bits\n * @param hi - The high 32 bits\n * @returns The unsigned 64-bit integer value\n */\nfunction loAndHiAsUnsigned(lo: number, hi: number) {\n  return lo + hi * 4294967296;\n}\n", "const textEncoder = new TextEncoder();\n\n/**\n * A class for writing binary data to a Uint8Array buffer.\n * Supports various data types including varints, strings, and boolean arrays.\n * All numeric values are written using varint encoding for efficiency.\n * The buffer automatically expands as needed.\n */\nexport class BufferWriter {\n  private buffer: Uint8Array;\n  private offset: number;\n\n  /**\n   * Creates a new BufferWriter instance.\n   * @param initialLength - The initial size of the buffer in bytes\n   */\n  constructor(initialLength: number) {\n    this.buffer = new Uint8Array(initialLength);\n    this.offset = 0;\n  }\n\n  /**\n   * Writes an unsigned 8-bit integer to the buffer.\n   * @param value - The value to write (will be truncated to 8 bits)\n   */\n  public writeUint8(value: number): void {\n    this.ensureCapacity(1);\n    this.buffer[this.offset] = value & 0xff;\n    this.offset += 1;\n  }\n\n  /**\n   * Writes a boolean value to the buffer.\n   * @param bool - The boolean value to write (true = 1, false = 0)\n   */\n  public writeBoolean(bool: boolean) {\n    this.writeUint8(bool ? 1 : 0);\n  }\n\n  /**\n   * Writes an array of bytes to the buffer without a length prefix.\n   * @param bytes - The bytes to write\n   */\n  public writeUnprefixedBytes(bytes: Uint8Array): void {\n    this.ensureCapacity(bytes.byteLength);\n    this.buffer.set(bytes, this.offset);\n    this.offset += bytes.byteLength;\n  }\n\n  /**\n   * Writes a length-prefixed array of bytes to the buffer.\n   * The length is encoded as an unsigned varint.\n   * @param bytes - The bytes to write\n   */\n  public writeUVarintLengthPrefixedBytes(bytes: Uint8Array): void {\n    if (!(bytes instanceof Uint8Array)) {\n      throw new Error(\"bytes must be a Uint8Array\");\n    }\n    this.writeUVarint(bytes.byteLength);\n    this.writeUnprefixedBytes(bytes);\n  }\n\n  /**\n   * Gets the written bytes as a Uint8Array.\n   * @returns A new Uint8Array containing only the written bytes\n   */\n  public getBuffer(): Uint8Array {\n    return this.buffer.subarray(0, this.offset);\n  }\n\n  /**\n   * Gets the number of bytes written so far.\n   * @returns The current write offset\n   */\n  public getWrittenLength(): number {\n    return this.offset;\n  }\n\n  /**\n   * Ensures the buffer has enough capacity for the required space.\n   * @param neededSpace - The number of additional bytes needed\n   */\n  private ensureCapacity(neededSpace: number): void {\n    while (this.offset + neededSpace > this.buffer.length) {\n      this.expandBuffer();\n    }\n  }\n\n  /**\n   * Expands the buffer by doubling its current length.\n   */\n  private expandBuffer(): void {\n    const newBuffer = new Uint8Array(this.buffer.length * 2);\n    newBuffer.set(this.buffer);\n    this.buffer = newBuffer;\n  }\n\n  /**\n   * Writes an unsigned varint to the buffer.\n   * Varints are variable-length integers that use the high bit of each byte to indicate if more bytes follow.\n   * @param x - The value to write\n   */\n  public writeUVarint(x: number) {\n    if (x <= 268435455) {\n      // Simple case that can be handled without hi and lo\n      this.ensureCapacity(4);\n      while (x >= 0x80) {\n        this.buffer[this.offset] = (x & 0x7f) | 0x80; // Extract least significant 7 bits and set continuation bit\n        this.offset++;\n        x >>>= 7; // Use unsigned shift here\n      }\n      this.buffer[this.offset] = x & 0x7f; // No need for 0xff here since we're limiting it to 7 bits\n      this.offset++;\n      return;\n    }\n    this.ensureCapacity(10);\n\n    let lo = 0;\n    let hi = 0;\n    if (x !== 0) {\n      lo = x >>> 0;\n      hi = ((x - lo) / 4294967296) >>> 0;\n    }\n\n    while (hi) {\n      this.buffer[this.offset++] = (lo & 127) | 128;\n      lo = ((lo >>> 7) | (hi << 25)) >>> 0;\n      hi >>>= 7;\n    }\n    while (lo > 127) {\n      this.buffer[this.offset++] = (lo & 127) | 128;\n      lo = lo >>> 7;\n    }\n    this.buffer[this.offset++] = lo;\n  }\n\n  /**\n   * Writes an unsigned varint to the buffer.\n   * Varints are variable-length integers that use the high bit of each byte to indicate if more bytes follow.\n   * @param x - The value to write\n   */\n  public writeUVarintBigInt(x: bigint) {\n    this.ensureCapacity(10);\n\n    while (x >= 0x80n) {\n      this.buffer[this.offset] = Number(x & 0x7fn) | 0x80;\n      this.offset++;\n      x >>= 7n;\n    }\n    this.buffer[this.offset] = Number(x & 0x7fn);\n    this.offset++;\n  }\n\n  /**\n   * Writes a signed varint to the buffer using zigzag encoding.\n   * @param x - The signed value to write\n   */\n  public writeVarint(x: number) {\n    if (x >= 0) {\n      this.writeUVarint(x * 2);\n    } else {\n      this.writeUVarint(-x * 2 - 1);\n    }\n  }\n\n  /**\n   * Writes a signed varint to the buffer using zigzag encoding.\n   * @param x - The signed value to write\n   */\n  public writeBigIntVarint(x: bigint) {\n    if (x >= 0n) {\n      this.writeUVarintBigInt(x * 2n);\n    } else {\n      this.writeUVarintBigInt(-x * 2n - 1n);\n    }\n  }\n\n  /**\n   * Writes an array of boolean values to the buffer.\n   * The booleans are packed into bytes (8 booleans per byte).\n   * @param data - The array of boolean values to write\n   */\n  public writeLengthPrefixedBoolArray(data: boolean[]) {\n    // The length is the number of bools/bits to allow the reader to determine a non-multiple of 8 length and to allocate\n    this.writeUVarint(data.length);\n    // Pack the booleans into a single byte\n    const numBytes = Math.ceil(data.length / 8);\n    this.ensureCapacity(numBytes + 4);\n\n    // Pack booleans into bits\n    for (let i = 0; i < data.length; i++) {\n      if (data[i]) {\n        // Set the bit at position i\n        const byteIndex = Math.floor(i / 8);\n        const bitPosition = i % 8;\n        this.buffer[this.offset + byteIndex] |= 1 << bitPosition;\n      }\n    }\n    this.offset += numBytes;\n  }\n\n  /**\n   * Writes a length-prefixed string to the buffer.\n   * Optimized for ASCII strings, falls back to TextEncoder for non-ASCII.\n   * @param value - The string to write\n   * @param varint - Whether to use signed varint for length (default: false)\n   * @param negativeLength - Whether the length should be negative (only used if varint is true)\n   */\n  public writeLengthPrefixedString(value: string, varint = false, negativeLength = false) {\n    /*\n     Try fast case first - no non-ascii characters and byte length is string length.\n\n     Even if this case fails (non-ascii character found) the data will always be\n     shorter so it can be overwritten\n    */\n    const originalOffset = this.offset; // store this in case we need to overwrite from here\n    // Just write the length of the string (not the known encoded length)\n    if (varint) {\n      this.writeVarint(negativeLength ? -value.length : value.length);\n    } else {\n      this.writeUVarint(value.length);\n    }\n    this.ensureCapacity(value.length); // Ensure we have enough space for the string\n    let nonAscii = false;\n    for (let i = 0; i < value.length; i++) {\n      const charCode = value.charCodeAt(i);\n      if (charCode > 0x7f) {\n        nonAscii = true;\n        break;\n      }\n      this.buffer[this.offset++] = charCode;\n    }\n\n    if (!nonAscii) {\n      return;\n    }\n\n    /*\n     If we have non-ascii characters, we need to encode the string respecting\n     utf-8 and overwrite the buffer from the original offset\n    */\n    this.offset = originalOffset; // overwrite the length\n    let encodedLength = value.length; // This will be overwritten once we know the actual length\n    this.ensureCapacity(encodedLength); // This will be at least the required length, but it gives the chance of initially creating a large enough buffer\n    while (true) {\n      this.offset = originalOffset;\n      if (varint) {\n        this.writeVarint(negativeLength ? -encodedLength : encodedLength);\n      } else {\n        this.writeUVarint(encodedLength);\n      }\n      const offsetAfterVarint = this.offset;\n      const varintLength = offsetAfterVarint - originalOffset;\n\n      const writeBuffer = new Uint8Array(this.buffer.buffer, this.offset);\n      const { read, written } = textEncoder.encodeInto(value, writeBuffer);\n      if (read !== value.length) {\n        // Need more space and try again\n        this.expandBuffer();\n        continue;\n      }\n      if (written !== encodedLength) {\n        encodedLength = written;\n        // We need to overwrite the varint with the correct length\n        this.offset = originalOffset;\n        if (varint) {\n          this.writeVarint(negativeLength ? -encodedLength : encodedLength);\n        } else {\n          this.writeUVarint(encodedLength);\n        }\n        const newOffsetAfterVarint = this.offset;\n        const actualVarintLength = newOffsetAfterVarint - originalOffset;\n        if (actualVarintLength !== varintLength) {\n          // The varint length changed and it has overwritten the string\n          // We need to write the string again\n          continue;\n        } else {\n          // The varint length is the same so the string is intact\n        }\n      }\n      // String written successfully - update the offset\n      this.offset += written;\n      return;\n    }\n  }\n}\n\n/**\n * Encodes a signed integer using zigzag encoding.\n * Zigzag encoding maps signed integers to unsigned integers in a way that preserves ordering.\n * @param value - The signed value to encode\n * @returns The zigzag-encoded value\n */\nexport function zigzagEncode(value: number): number {\n  // Positive numbers: 2*n\n  // Negative numbers: 2*|n|-1\n  return value >= 0 ? value * 2 : -value * 2 - 1;\n}\n", "import { deflate, inflate } from \"pako\";\n\nlet nodeZlibFunctions: {\n  deflateSync: (data: Uint8Array) => Uint8Array;\n  inflateSync: (data: Uint8Array) => Uint8Array;\n} | null = null;\ntry {\n  const isNode =\n    typeof process !== \"undefined\" && process.versions && typeof process.versions.node === \"string\";\n\n  if (isNode) {\n    (async () => {\n      try {\n        const nodeZlib = await import(\"node:zlib\");\n        nodeZlibFunctions = {\n          deflateSync: (data: Uint8Array) => {\n            const result = nodeZlib.deflateSync(data);\n            return new Uint8Array(result);\n          },\n          inflateSync: (data: Uint8Array) => {\n            const result = nodeZlib.inflateSync(data);\n            return new Uint8Array(result);\n          },\n        };\n      } catch (e) {\n        console.log(\"nodeZlib not available - sync\", e);\n      }\n    })();\n  }\n} catch (e) {\n  console.log(\"nodeZlib not available - sync\", e);\n}\n\nexport enum CompressionLibraryChoice {\n  PAKO = \"PAKO\",\n  NODE_ZLIB = \"NODE_ZLIB\",\n  NO_PREFERENCE = \"NO_PREFERENCE\",\n  NONE = \"NONE\",\n}\n\nimport { BufferReader } from \"./BufferReader\";\nimport { BufferWriter } from \"./BufferWriter\";\n\nfunction getCompressFunction(compressionLibrary: CompressionLibraryChoice) {\n  switch (compressionLibrary) {\n    case CompressionLibraryChoice.PAKO:\n      return deflate;\n    case CompressionLibraryChoice.NODE_ZLIB:\n      if (nodeZlibFunctions) {\n        return nodeZlibFunctions.deflateSync;\n      } else {\n        throw new Error(\"node:zlib not available\");\n      }\n    case CompressionLibraryChoice.NO_PREFERENCE:\n      if (nodeZlibFunctions) {\n        return nodeZlibFunctions.deflateSync;\n      } else {\n        return deflate;\n      }\n    case CompressionLibraryChoice.NONE:\n      return (data: Uint8Array) => {\n        return new Uint8Array(data);\n      };\n  }\n}\n\nfunction getDecompressFunction(compressionLibrary: CompressionLibraryChoice) {\n  switch (compressionLibrary) {\n    case CompressionLibraryChoice.PAKO:\n      return inflate;\n    case CompressionLibraryChoice.NODE_ZLIB:\n      if (nodeZlibFunctions) {\n        return nodeZlibFunctions.inflateSync;\n      } else {\n        throw new Error(\"node:zlib not available\");\n      }\n    case CompressionLibraryChoice.NO_PREFERENCE:\n      if (nodeZlibFunctions) {\n        return nodeZlibFunctions.inflateSync;\n      } else {\n        return inflate;\n      }\n    case CompressionLibraryChoice.NONE:\n      return (data: Uint8Array) => {\n        return new Uint8Array(data);\n      };\n  }\n}\n\nexport class DeflateCompressor {\n  public static compress(\n    data: Uint8Array,\n    compressionLibrary: CompressionLibraryChoice = CompressionLibraryChoice.NO_PREFERENCE,\n  ): Uint8Array {\n    return getCompressFunction(compressionLibrary)(data);\n  }\n\n  public static decompress(\n    compressed: Uint8Array,\n    compressionLibrary: CompressionLibraryChoice = CompressionLibraryChoice.NO_PREFERENCE,\n  ): Uint8Array {\n    return getDecompressFunction(compressionLibrary)(compressed);\n  }\n\n  public static varIntCompress(\n    data: BigInt64Array,\n    length: number,\n    compressionLibrary: CompressionLibraryChoice = CompressionLibraryChoice.NO_PREFERENCE,\n  ): [Uint8Array, Uint8Array] {\n    if (length > data.length) {\n      throw new Error(\"length is greater than the data length\");\n    }\n    const writer = new BufferWriter(length);\n    for (let i = 0; i < length; i++) {\n      writer.writeBigIntVarint(data[i]);\n    }\n    const uint8Array = writer.getBuffer();\n    return [uint8Array, DeflateCompressor.compress(uint8Array, compressionLibrary)];\n  }\n\n  public static varIntDecompress(\n    compressed: Uint8Array,\n    length: number,\n    compressionLibrary: CompressionLibraryChoice = CompressionLibraryChoice.NO_PREFERENCE,\n  ): BigInt64Array {\n    const data = DeflateCompressor.decompress(compressed, compressionLibrary);\n    const buffer = new BigInt64Array(length);\n    const reader = new BufferReader(data);\n    for (let i = 0; i < length; i++) {\n      buffer[i] = reader.readBigIntVarint();\n    }\n    return buffer;\n  }\n\n  public static varIntBytesCompress(\n    data: Array<Uint8Array | null>,\n    length: number,\n    compressionLibrary: CompressionLibraryChoice = CompressionLibraryChoice.NO_PREFERENCE,\n  ): [Uint8Array, Uint8Array] {\n    if (length > data.length) {\n      throw new Error(\"length is greater than the data length\");\n    }\n    const writer = new BufferWriter(length);\n    for (let i = 0; i < length; i++) {\n      const value = data[i];\n      if (value === null || value === undefined) {\n        writer.writeUVarintLengthPrefixedBytes(new Uint8Array(0));\n      } else {\n        writer.writeUVarintLengthPrefixedBytes(value);\n      }\n    }\n    const uint8Array = writer.getBuffer();\n    return [uint8Array, DeflateCompressor.compress(uint8Array, compressionLibrary)];\n  }\n\n  public static varIntBytesDecompress(\n    compressed: Uint8Array,\n    length: number,\n    compressionLibrary: CompressionLibraryChoice = CompressionLibraryChoice.NO_PREFERENCE,\n  ): Array<Uint8Array> {\n    const data = DeflateCompressor.decompress(compressed, compressionLibrary);\n    const buffer = new Array<Uint8Array>(length);\n    const reader = new BufferReader(data);\n    for (let i = 0; i < length; i++) {\n      buffer[i] = reader.readUVarintPrefixedBytes();\n    }\n    return buffer;\n  }\n}\n", "export const deltaNetProtocolSubProtocol_v0_1 = \"delta-net-v0.1\";\n", "// Server -> Client\nexport const InitialCheckoutMessageType = 1;\nexport const ServerCustomMessageType = 2;\nexport const UserIndexMessageType = 3;\nexport const TickMessageType = 4;\nexport const PingMessageType = 5;\nexport const WarningMessageType = 6;\nexport const ErrorMessageType = 7;\n\n// Client -> Server\nexport const ConnectUserMessageType = 64;\nexport const ClientCustomMessageType = 65;\nexport const SetUserComponentsMessageType = 66;\nexport const SetUserStateMessageType = 67;\nexport const PongMessageType = 68;\n", "import { BufferReader } from \"../../../BufferReader\";\nimport { BufferWriter } from \"../../../BufferWriter\";\nimport { ClientCustomMessageType } from \"../../messageTypes\";\n\nexport type DeltaNetV01ClientCustomMessage = {\n  type: \"clientCustom\";\n  customType: number;\n  contents: string;\n};\n\nexport function encodeClientCustom(\n  msg: DeltaNetV01ClientCustomMessage,\n  writer: BufferWriter = new BufferWriter(64),\n): BufferWriter {\n  writer.writeUint8(ClientCustomMessageType);\n  writer.writeUVarint(msg.customType);\n  writer.writeLengthPrefixedString(msg.contents);\n  return writer;\n}\n\n// Assumes that the first byte has already been read (the message type)\nexport function decodeClientCustom(buffer: BufferReader): DeltaNetV01ClientCustomMessage {\n  const customType = buffer.readUVarint();\n  const contents = buffer.readUVarintPrefixedString();\n  return {\n    type: \"clientCustom\",\n    customType,\n    contents,\n  };\n}\n", "import { BufferReader } from \"../../../BufferReader\";\nimport { BufferWriter } from \"../../../BufferWriter\";\nimport { ConnectUserMessageType } from \"../../messageTypes\";\n\n/**\n * Initial connection request message from client to server.\n * Contains authentication token and initial state of the connecting user.\n */\nexport type DeltaNetV01ConnectUserMessage = {\n  /** Message type identifier */\n  type: \"connectUser\";\n  /** Authentication token for the user */\n  token: string;\n  /** Whether the client is an observer-only client */\n  observer: boolean;\n  /** Array of [componentId, value] pairs for the user's initial component values */\n  components: Array<[number, bigint]>;\n  /** Array of [stateId, value] pairs for the user's initial state values */\n  states: Array<[number, Uint8Array]>;\n};\n\n/**\n * Encodes a connect user message into a binary buffer.\n * @param connectUserMessage - The message to encode\n * @param writer - The BufferWriter to write to\n */\nexport function encodeConnectUser(\n  connectUserMessage: DeltaNetV01ConnectUserMessage,\n  writer: BufferWriter,\n) {\n  writer.writeUint8(ConnectUserMessageType);\n  writer.writeLengthPrefixedString(connectUserMessage.token);\n  writer.writeBoolean(connectUserMessage.observer ?? false);\n  writer.writeUVarint(connectUserMessage.components.length);\n  for (const [componentId, componentValue] of connectUserMessage.components) {\n    writer.writeUVarint(componentId);\n    writer.writeBigIntVarint(componentValue);\n  }\n  writer.writeUVarint(connectUserMessage.states.length);\n  for (const [stateId, stateValue] of connectUserMessage.states) {\n    writer.writeUVarint(stateId);\n    writer.writeUVarintLengthPrefixedBytes(stateValue);\n  }\n}\n\n/**\n * Decodes a connect user message from a binary buffer.\n * Assumes that the first byte (message type) has already been read.\n * @param buffer - The BufferReader containing the message data\n * @returns The decoded connect user message\n */\nexport function decodeConnectUser(buffer: BufferReader): DeltaNetV01ConnectUserMessage {\n  const token = buffer.readUVarintPrefixedString();\n  const observer = buffer.readBoolean();\n  const componentsLength = buffer.readUVarint();\n  const components: Array<[number, bigint]> = [];\n  for (let i = 0; i < componentsLength; i++) {\n    const componentId = buffer.readUVarint();\n    const componentValue = buffer.readBigIntVarint();\n    components.push([componentId, componentValue]);\n  }\n  const statesLength = buffer.readUVarint();\n  const states: Array<[number, Uint8Array]> = [];\n  for (let i = 0; i < statesLength; i++) {\n    const stateId = buffer.readUVarint();\n    const stateValue = buffer.readUVarintPrefixedBytes();\n    states.push([stateId, stateValue]);\n  }\n  return {\n    type: \"connectUser\",\n    token,\n    observer,\n    components,\n    states,\n  };\n}\n", "import { BufferReader } from \"../../../BufferReader\";\nimport { BufferWriter } from \"../../../BufferWriter\";\nimport { PongMessageType } from \"../../messageTypes\";\n\nexport type DeltaNetV01PongMessage = {\n  type: \"pong\";\n  pong: number;\n};\n\nexport function encodePong(pongMessage: DeltaNetV01PongMessage, writer: BufferWriter) {\n  writer.writeUint8(PongMessageType);\n  writer.writeUVarint(pongMessage.pong);\n}\n\n// Assumes that the first byte has already been read (the message type)\nexport function decodePong(buffer: BufferReader): DeltaNetV01PongMessage {\n  const pong = buffer.readUVarint();\n  return {\n    type: \"pong\",\n    pong,\n  };\n}\n", "import { BufferReader } from \"../../../BufferReader\";\nimport { BufferWriter } from \"../../../BufferWriter\";\nimport { SetUserComponentsMessageType } from \"../../messageTypes\";\n\n/**\n * Message sent by client to update component and state values.\n * Used to send user input and state changes to the server.\n */\nexport type DeltaNetV01SetUserComponentsMessage = {\n  /** Message type identifier */\n  type: \"setUserComponents\";\n  /** Array of [componentId, value] pairs for updated component values */\n  components: Array<[number, bigint]>;\n  /** Array of [stateId, value] pairs for updated state values */\n  states: Array<[number, Uint8Array]>;\n};\n\n/**\n * Encodes a set user components message into a binary buffer.\n * @param message - The message to encode\n * @param writer - The BufferWriter to write to\n */\nexport function encodeSetUserComponents(\n  message: DeltaNetV01SetUserComponentsMessage,\n  writer: BufferWriter,\n) {\n  writer.writeUint8(SetUserComponentsMessageType);\n  writer.writeUVarint(message.components.length);\n  for (const [componentId, componentValue] of message.components) {\n    writer.writeUVarint(componentId);\n    writer.writeBigIntVarint(componentValue);\n  }\n  writer.writeUVarint(message.states.length);\n  for (const [stateId, stateValue] of message.states) {\n    writer.writeUVarint(stateId);\n    writer.writeUVarintLengthPrefixedBytes(stateValue);\n  }\n}\n\n/**\n * Decodes a set user components message from a binary buffer.\n * Assumes that the first byte (message type) has already been read.\n * @param buffer - The BufferReader containing the message data\n * @returns The decoded set user components message\n */\nexport function decodeSetUserComponents(buffer: BufferReader): DeltaNetV01SetUserComponentsMessage {\n  const componentsLength = buffer.readUVarint();\n  const components: Array<[number, bigint]> = [];\n  for (let i = 0; i < componentsLength; i++) {\n    const componentId = buffer.readUVarint();\n    const componentValue = buffer.readBigIntVarint();\n    components.push([componentId, componentValue]);\n  }\n  const statesLength = buffer.readUVarint();\n  const states: Array<[number, Uint8Array]> = [];\n  for (let i = 0; i < statesLength; i++) {\n    const stateId = buffer.readUVarint();\n    const stateValue = buffer.readUVarintPrefixedBytes();\n    states.push([stateId, stateValue]);\n  }\n  return {\n    type: \"setUserComponents\",\n    components,\n    states,\n  };\n}\n", "import { BufferReader } from \"../BufferReader\";\n\nimport { DeltaNetV01ClientMessage } from \"./messages\";\nimport { decodeClientCustom } from \"./messages/from-client/clientCustom\";\nimport { decodeConnectUser } from \"./messages/from-client/connectUser\";\nimport { decodePong } from \"./messages/from-client/pong\";\nimport { decodeSetUserComponents } from \"./messages/from-client/setUserComponents\";\nimport {\n  ConnectUserMessageType,\n  PongMessageType,\n  SetUserComponentsMessageType,\n  ClientCustomMessageType,\n} from \"./messageTypes\";\n\nexport function decodeClientMessages(buffer: BufferReader): Array<DeltaNetV01ClientMessage> {\n  const messages: DeltaNetV01ClientMessage[] = [];\n  while (!buffer.isEnd()) {\n    const messageType = buffer.readUInt8();\n    switch (messageType) {\n      case ConnectUserMessageType:\n        messages.push(decodeConnectUser(buffer));\n        break;\n      case SetUserComponentsMessageType:\n        messages.push(decodeSetUserComponents(buffer));\n        break;\n      case PongMessageType:\n        messages.push(decodePong(buffer));\n        break;\n      case ClientCustomMessageType:\n        messages.push(decodeClientCustom(buffer));\n        break;\n      default:\n        throw new Error(`Unknown message type: ${messageType}`);\n    }\n  }\n  return messages;\n}\n", "import { BufferReader } from \"../../../BufferReader\";\nimport { BufferWriter } from \"../../../BufferWriter\";\nimport { ErrorMessageType } from \"../../messageTypes\";\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport namespace DeltaNetV01ServerErrors {\n  export const USER_ALREADY_AUTHENTICATED_ERROR_TYPE = \"USER_ALREADY_AUTHENTICATED\";\n  export const USER_NOT_AUTHENTICATED_ERROR_TYPE = \"USER_NOT_AUTHENTICATED\";\n  export const AUTHENTICATION_IN_PROGRESS_ERROR_TYPE = \"AUTHENTICATION_IN_PROGRESS\";\n  export const OBSERVER_CANNOT_SEND_STATE_UPDATES_ERROR_TYPE = \"OBSERVER_CANNOT_SEND_STATE_UPDATES\";\n  export const UNSUPPORTED_WEBSOCKET_SUBPROTOCOL_ERROR_TYPE = \"UNSUPPORTED_WEBSOCKET_SUBPROTOCOL\";\n  export const USER_NETWORKING_UNKNOWN_ERROR_TYPE = \"USER_NETWORKING_UNKNOWN_ERROR\";\n  export const USER_AUTHENTICATION_FAILED_ERROR_TYPE = \"USER_AUTHENTICATION_FAILED\";\n  export const USER_NETWORKING_CONNECTION_LIMIT_REACHED_ERROR_TYPE = \"CONNECTION_LIMIT_REACHED\";\n  export const USER_NETWORKING_SERVER_SHUTDOWN_ERROR_TYPE = \"SERVER_SHUTDOWN\";\n}\n\nexport type DeltaNetV01ServerErrorType =\n  | typeof DeltaNetV01ServerErrors.USER_ALREADY_AUTHENTICATED_ERROR_TYPE\n  | typeof DeltaNetV01ServerErrors.USER_NOT_AUTHENTICATED_ERROR_TYPE\n  | typeof DeltaNetV01ServerErrors.AUTHENTICATION_IN_PROGRESS_ERROR_TYPE\n  | typeof DeltaNetV01ServerErrors.OBSERVER_CANNOT_SEND_STATE_UPDATES_ERROR_TYPE\n  | typeof DeltaNetV01ServerErrors.UNSUPPORTED_WEBSOCKET_SUBPROTOCOL_ERROR_TYPE\n  | typeof DeltaNetV01ServerErrors.USER_NETWORKING_UNKNOWN_ERROR_TYPE\n  | typeof DeltaNetV01ServerErrors.USER_AUTHENTICATION_FAILED_ERROR_TYPE\n  | typeof DeltaNetV01ServerErrors.USER_NETWORKING_CONNECTION_LIMIT_REACHED_ERROR_TYPE\n  | typeof DeltaNetV01ServerErrors.USER_NETWORKING_SERVER_SHUTDOWN_ERROR_TYPE;\n\nexport type DeltaNetV01ErrorMessage = {\n  type: \"error\";\n  errorType: DeltaNetV01ServerErrorType | string;\n  message: string;\n  retryable: boolean; // Whether the client should retry the operation - if false the client should not attempt to reconnect/retry\n};\n\nexport function encodeError(\n  msg: DeltaNetV01ErrorMessage,\n  writer: BufferWriter = new BufferWriter(64),\n): BufferWriter {\n  writer.writeUint8(ErrorMessageType);\n  writer.writeLengthPrefixedString(msg.errorType);\n  writer.writeLengthPrefixedString(msg.message);\n  writer.writeBoolean(msg.retryable);\n  return writer;\n}\n\n// Assumes that the first byte has already been read (the message type)\nexport function decodeError(buffer: BufferReader): DeltaNetV01ErrorMessage {\n  const errorType = buffer.readUVarintPrefixedString() as DeltaNetV01ServerErrorType;\n  const message = buffer.readUVarintPrefixedString();\n  const retryable = buffer.readBoolean();\n  return {\n    type: \"error\",\n    errorType,\n    message,\n    retryable,\n  };\n}\n", "import { BufferReader } from \"../../../BufferReader\";\nimport { BufferWriter } from \"../../../BufferWriter\";\nimport { DeflateCompressor } from \"../../../DeflateCompressor\";\nimport { DecodeServerMessageOptions } from \"../../decodeServerMessages\";\nimport { InitialCheckoutMessageType } from \"../../messageTypes\";\n\n/**\n * Represents a component in the initial checkout message.\n * Contains both the initial values and the delta values that will be used for subsequent ticks.\n */\nexport type DeltaNetV01InitialCheckoutComponent = {\n  /** Unique identifier for the component */\n  componentId: number;\n  /** The delta values from the tick this initial checkout is from which will be referred to in subsequent ticks */\n  deltas: BigInt64Array;\n  /** The initial values for all users */\n  values: BigInt64Array;\n};\n\nexport type DeltaNetV01InitialCheckoutState = {\n  /** Unique identifier for the state */\n  stateId: number;\n  /** The initial values for all users */\n  values: Array<Uint8Array>;\n};\n\n/**\n * Initial checkout message sent when a client first connects.\n * Contains the complete initial state of the game, including all components and states.\n */\nexport type DeltaNetV01InitialCheckoutMessage = {\n  /** Message type identifier */\n  type: \"initialCheckout\";\n  /** Current server time */\n  serverTime: number;\n  /** Number of user indices in the system */\n  indicesCount: number;\n  /** Array of components with their initial values and deltas */\n  components: Array<DeltaNetV01InitialCheckoutComponent>;\n  /** Array of state values, each containing [stateId, stateValue] */\n  states: Array<DeltaNetV01InitialCheckoutState>;\n};\n\n/**\n * Encodes an initial checkout message into a binary buffer.\n * @param msg - The message to encode\n * @param writer - Optional BufferWriter instance to use (creates a new one if not provided)\n * @returns The BufferWriter containing the encoded message\n */\nexport function encodeInitialCheckout(\n  msg: DeltaNetV01InitialCheckoutMessage,\n  writer: BufferWriter = new BufferWriter(64),\n): BufferWriter {\n  writer.writeUint8(InitialCheckoutMessageType);\n  writer.writeUVarint(msg.serverTime);\n  writer.writeUVarint(msg.indicesCount);\n  writer.writeUVarint(msg.components.length);\n  for (const { componentId, deltas, values } of msg.components) {\n    writer.writeUVarint(componentId);\n    const [, valuesBytes] = DeflateCompressor.varIntCompress(values, msg.indicesCount);\n    writer.writeUVarintLengthPrefixedBytes(valuesBytes);\n    const [, deltaBytes] = DeflateCompressor.varIntCompress(deltas, msg.indicesCount);\n    writer.writeUVarintLengthPrefixedBytes(deltaBytes);\n  }\n  writer.writeUVarint(msg.states.length);\n  for (const { stateId, values } of msg.states) {\n    writer.writeUVarint(stateId);\n    const [, stateBytes] = DeflateCompressor.varIntBytesCompress(values, msg.indicesCount);\n    writer.writeUVarintLengthPrefixedBytes(stateBytes);\n  }\n  return writer;\n}\n\nexport const lastInitialCheckoutDebugData: {\n  componentsByteLength: number;\n  statesByteLength: number;\n} = {\n  componentsByteLength: 0,\n  statesByteLength: 0,\n};\n\n/**\n * Decodes an initial checkout message from a binary buffer.\n * Assumes that the first byte (message type) has already been read.\n * @param buffer - The BufferReader containing the message data\n * @param opts - Optional options for decoding, such as ignoring data\n * @returns The decoded initial checkout message\n */\nexport function decodeInitialCheckout(\n  buffer: BufferReader,\n  opts?: DecodeServerMessageOptions,\n): DeltaNetV01InitialCheckoutMessage {\n  let componentsByteLength = 0;\n  let statesByteLength = 0;\n\n  const serverTime = buffer.readUVarint();\n  const indicesLength = buffer.readUVarint();\n  const componentsLength = buffer.readUVarint();\n  const components: Array<DeltaNetV01InitialCheckoutComponent> = [];\n  for (let i = 0; i < componentsLength; i++) {\n    const componentId = buffer.readUVarint();\n    const valuesBytes = buffer.readUVarintPrefixedBytes();\n    const values = DeflateCompressor.varIntDecompress(valuesBytes, indicesLength);\n    const deltaBytes = buffer.readUVarintPrefixedBytes();\n    componentsByteLength += valuesBytes.length + deltaBytes.length;\n    if (opts?.ignoreData) {\n      components.push({ componentId, deltas: new BigInt64Array(indicesLength), values });\n    } else {\n      const deltas = DeflateCompressor.varIntDecompress(deltaBytes, indicesLength);\n      components.push({ componentId, deltas, values });\n    }\n  }\n  const statesLength = buffer.readUVarint();\n  const states: Array<DeltaNetV01InitialCheckoutState> = [];\n  for (let i = 0; i < statesLength; i++) {\n    const stateId = buffer.readUVarint();\n    const valuesBytes = buffer.readUVarintPrefixedBytes();\n    statesByteLength += valuesBytes.length;\n    if (opts?.ignoreData) {\n      const emptyValues = new Array<Uint8Array>(indicesLength).fill(new Uint8Array(0));\n      states.push({ stateId, values: emptyValues });\n    } else {\n      const values = DeflateCompressor.varIntBytesDecompress(valuesBytes, indicesLength);\n      states.push({ stateId, values });\n    }\n  }\n  lastInitialCheckoutDebugData.componentsByteLength = componentsByteLength;\n  lastInitialCheckoutDebugData.statesByteLength = statesByteLength;\n  return {\n    type: \"initialCheckout\",\n    serverTime,\n    indicesCount: indicesLength,\n    components,\n    states,\n  };\n}\n", "import { BufferReader } from \"../../../BufferReader\";\nimport { BufferWriter } from \"../../../BufferWriter\";\nimport { PingMessageType } from \"../../messageTypes\";\n\nexport type DeltaNetV01PingMessage = {\n  type: \"ping\";\n  ping: number;\n};\n\nexport function encodePing(\n  pingMessage: DeltaNetV01PingMessage,\n  writer: BufferWriter = new BufferWriter(8),\n): BufferWriter {\n  writer.writeUint8(PingMessageType);\n  writer.writeUVarint(pingMessage.ping);\n  return writer;\n}\n\n// Assumes that the first byte has already been read (the message type)\nexport function decodePing(buffer: BufferReader): DeltaNetV01PingMessage {\n  const ping = buffer.readUVarint();\n  return {\n    type: \"ping\",\n    ping,\n  };\n}\n", "import { BufferReader } from \"../../../BufferReader\";\nimport { BufferWriter } from \"../../../BufferWriter\";\nimport { ServerCustomMessageType } from \"../../messageTypes\";\n\nexport type DeltaNetV01ServerCustomMessage = {\n  type: \"serverCustom\";\n  customType: number;\n  contents: string;\n};\n\nexport function encodeServerCustom(\n  msg: DeltaNetV01ServerCustomMessage,\n  writer: BufferWriter = new BufferWriter(64),\n): BufferWriter {\n  writer.writeUint8(ServerCustomMessageType);\n  writer.writeUVarint(msg.customType);\n  writer.writeLengthPrefixedString(msg.contents);\n  return writer;\n}\n\n// Assumes that the first byte has already been read (the message type)\nexport function decodeServerCustom(buffer: BufferReader): DeltaNetV01ServerCustomMessage {\n  const customType = buffer.readUVarint();\n  const contents = buffer.readUVarintPrefixedString();\n  return {\n    type: \"serverCustom\",\n    customType,\n    contents,\n  };\n}\n", "import { BufferReader } from \"../../../BufferReader\";\nimport { BufferWriter } from \"../../../BufferWriter\";\nimport { DeflateCompressor } from \"../../../DeflateCompressor\";\nimport { DecodeServerMessageOptions } from \"../../decodeServerMessages\";\nimport { TickMessageType } from \"../../messageTypes\";\n\n/**\n * Represents state updates in a tick message.\n * States are not updated every tick, so they are specified as indices that have changed and their new values.\n */\nexport type DeltaNetV01StateUpdates = {\n  /** Unique identifier for the state */\n  stateId: number;\n  /** Array of [index, value] pairs for updated states */\n  updatedStates: Array<[number, Uint8Array]>; //index to state\n};\n\n/**\n * Represents component updates in a tick message.\n * Uses second-order delta compression (deltas of deltas) for efficient updates.\n */\nexport type DeltaNetV01ComponentTick = {\n  /** Unique identifier for the component */\n  componentId: number;\n  /** The second-order delta values (deltas of deltas) from the previous tick */\n  deltaDeltas: BigInt64Array;\n};\n\n/**\n * Regular state update message sent at configurable intervals (typically 5-20Hz).\n * Contains updates to components and states, as well as information about user indices.\n */\nexport type DeltaNetV01Tick = {\n  /** Message type identifier */\n  type: \"tick\";\n  /** Current server time */\n  serverTime: number;\n  /** Indices of users that have been removed since the last tick */\n  removedIndices: Array<number>;\n  /** Current number of user indices in the system */\n  indicesCount: number;\n  /** Array of component updates using second-order delta compression */\n  componentDeltaDeltas: Array<DeltaNetV01ComponentTick>;\n  /** Array of state updates */\n  states: Array<DeltaNetV01StateUpdates>;\n};\n\n/**\n * Encodes a tick message into a binary buffer.\n * @param msg - The message to encode\n * @param writer - Optional BufferWriter instance to use (creates a new one if not provided)\n * @returns The BufferWriter containing the encoded message\n */\nexport function encodeTick(\n  msg: DeltaNetV01Tick,\n  writer: BufferWriter = new BufferWriter(64),\n): BufferWriter {\n  writer.writeUint8(TickMessageType);\n\n  writer.writeUVarint(msg.serverTime);\n\n  writer.writeUVarint(msg.removedIndices.length);\n  for (const index of msg.removedIndices) {\n    writer.writeUVarint(index);\n  }\n  writer.writeUVarint(msg.indicesCount);\n  writer.writeUVarint(msg.componentDeltaDeltas.length);\n  for (const componentTick of msg.componentDeltaDeltas) {\n    writer.writeUVarint(componentTick.componentId);\n    const [, deltaDeltasBytes] = DeflateCompressor.varIntCompress(\n      componentTick.deltaDeltas,\n      msg.indicesCount,\n    );\n    writer.writeUVarintLengthPrefixedBytes(deltaDeltasBytes);\n  }\n  writer.writeUVarint(msg.states.length);\n  for (const state of msg.states) {\n    writer.writeUVarint(state.stateId);\n    writer.writeUVarint(state.updatedStates.length);\n\n    // Separate indices and values for compression\n    const indices = new BigInt64Array(state.updatedStates.length);\n    const values = new Array<Uint8Array>(state.updatedStates.length);\n\n    for (let i = 0; i < state.updatedStates.length; i++) {\n      const [index, value] = state.updatedStates[i];\n      indices[i] = BigInt(index);\n      values[i] = value;\n    }\n\n    // Compress and write indices\n    const [, compressedIndices] = DeflateCompressor.varIntCompress(indices, indices.length);\n    writer.writeUVarintLengthPrefixedBytes(compressedIndices);\n\n    // Compress and write values\n    const [, compressedValues] = DeflateCompressor.varIntBytesCompress(values, values.length);\n    writer.writeUVarintLengthPrefixedBytes(compressedValues);\n  }\n  return writer;\n}\n\nexport const lastTickDebugData: {\n  componentsByteLength: number;\n  statesByteLength: number;\n} = {\n  componentsByteLength: 0,\n  statesByteLength: 0,\n};\n\n/**\n * Decodes a tick message from a binary buffer.\n * Assumes that the first byte (message type) has already been read.\n * @param buffer - The BufferReader containing the message data\n * @param opts - Optional options for decoding, such as ignoring data\n * @returns The decoded tick message\n */\nexport function decodeTick(\n  buffer: BufferReader,\n  opts?: DecodeServerMessageOptions,\n): DeltaNetV01Tick {\n  let componentsByteLength = 0;\n  let statesByteLength = 0;\n\n  const serverTime = buffer.readUVarint();\n  const removedIndicesLength = buffer.readUVarint();\n  const removedIndices: Array<number> = [];\n  for (let i = 0; i < removedIndicesLength; i++) {\n    removedIndices.push(buffer.readUVarint());\n  }\n  const indicesCount = buffer.readUVarint();\n  const componentsLength = buffer.readUVarint();\n  const components: Array<DeltaNetV01ComponentTick> = [];\n  for (let i = 0; i < componentsLength; i++) {\n    const componentId = buffer.readUVarint();\n    const deltaDeltaBytes = buffer.readUVarintPrefixedBytes();\n    componentsByteLength += deltaDeltaBytes.byteLength;\n    if (opts?.ignoreData) {\n      components.push({ componentId, deltaDeltas: new BigInt64Array(indicesCount) });\n    } else {\n      const deltaDeltas = DeflateCompressor.varIntDecompress(deltaDeltaBytes, indicesCount);\n      components.push({ componentId, deltaDeltas });\n    }\n  }\n  const statesLength = buffer.readUVarint();\n  const states: Array<DeltaNetV01StateUpdates> = [];\n  for (let i = 0; i < statesLength; i++) {\n    const stateId = buffer.readUVarint();\n    const stateCount = buffer.readUVarint();\n    const state: DeltaNetV01StateUpdates = {\n      stateId,\n      updatedStates: [],\n    };\n\n    const compressedIndices = buffer.readUVarintPrefixedBytes();\n    const compressedValues = buffer.readUVarintPrefixedBytes();\n    statesByteLength += compressedIndices.byteLength;\n    statesByteLength += compressedValues.byteLength;\n\n    if (stateCount > 0) {\n      // Read and decompress indices\n      const indices = DeflateCompressor.varIntDecompress(compressedIndices, stateCount);\n      const values = DeflateCompressor.varIntBytesDecompress(compressedValues, stateCount);\n\n      // Recombine indices and values\n      for (let j = 0; j < stateCount; j++) {\n        const index = Number(indices[j]);\n        const value = values[j];\n        state.updatedStates.push([index, value]);\n      }\n    }\n\n    states.push(state);\n  }\n  lastTickDebugData.componentsByteLength = componentsByteLength;\n  lastTickDebugData.statesByteLength = statesByteLength;\n  return {\n    type: \"tick\",\n    serverTime,\n    removedIndices,\n    indicesCount,\n    componentDeltaDeltas: components,\n    states,\n  };\n}\n", "import { BufferReader } from \"../../../BufferReader\";\nimport { BufferWriter } from \"../../../BufferWriter\";\nimport { UserIndexMessageType } from \"../../messageTypes\";\n\nexport type DeltaNetV01UserIndexMessage = {\n  type: \"userIndex\";\n  index: number;\n};\n\nexport function encodeUserIndex(\n  msg: DeltaNetV01UserIndexMessage,\n  writer: BufferWriter = new BufferWriter(64),\n): BufferWriter {\n  writer.writeUint8(UserIndexMessageType);\n  writer.writeUVarint(msg.index);\n  return writer;\n}\n\n// Assumes that the first byte has already been read (the message type)\nexport function decodeUserIndex(buffer: BufferReader): DeltaNetV01UserIndexMessage {\n  const index = buffer.readUVarint();\n  return {\n    type: \"userIndex\",\n    index,\n  };\n}\n", "import { BufferReader } from \"../../../BufferReader\";\nimport { BufferWriter } from \"../../../BufferWriter\";\nimport { WarningMessageType } from \"../../messageTypes\";\n\nexport type DeltaNetV01WarningMessage = {\n  type: \"warning\";\n  message: string;\n};\n\nexport function encodeWarning(\n  msg: DeltaNetV01WarningMessage,\n  writer: BufferWriter = new BufferWriter(64),\n): BufferWriter {\n  writer.writeUint8(WarningMessageType);\n  writer.writeLengthPrefixedString(msg.message);\n  return writer;\n}\n\n// Assumes that the first byte has already been read (the message type)\nexport function decodeWarning(buffer: BufferReader): DeltaNetV01WarningMessage {\n  const message = buffer.readUVarintPrefixedString();\n  return {\n    type: \"warning\",\n    message,\n  };\n}\n", "import { BufferReader } from \"../BufferReader\";\n\nimport {\n  decodeError,\n  decodeInitialCheckout,\n  decodePing,\n  decodeServerCustom,\n  decodeTick,\n  decodeUserIndex,\n  decodeWarning,\n  DeltaNetV01ServerMessage,\n} from \"./messages\";\nimport {\n  ErrorMessageType,\n  InitialCheckoutMessageType,\n  PingMessageType,\n  ServerCustomMessageType,\n  TickMessageType,\n  UserIndexMessageType,\n  WarningMessageType,\n} from \"./messageTypes\";\n\nexport type DecodeServerMessageOptions = {\n  ignoreData?: boolean; // Used when the client doesn't want to process data, e.g., in bot mode\n};\n\nexport function decodeServerMessages(\n  buffer: BufferReader,\n  opts?: DecodeServerMessageOptions,\n): Array<DeltaNetV01ServerMessage> {\n  const messages: DeltaNetV01ServerMessage[] = [];\n  while (!buffer.isEnd()) {\n    const messageType = buffer.readUInt8();\n    switch (messageType) {\n      case InitialCheckoutMessageType:\n        messages.push(decodeInitialCheckout(buffer, opts));\n        break;\n      case UserIndexMessageType:\n        messages.push(decodeUserIndex(buffer));\n        break;\n      case TickMessageType:\n        messages.push(decodeTick(buffer, opts));\n        break;\n      case ServerCustomMessageType:\n        messages.push(decodeServerCustom(buffer));\n        break;\n      case PingMessageType:\n        messages.push(decodePing(buffer));\n        break;\n      case WarningMessageType:\n        messages.push(decodeWarning(buffer));\n        break;\n      case ErrorMessageType:\n        messages.push(decodeError(buffer));\n        break;\n      default:\n        throw new Error(`Unknown message type: ${messageType}`);\n    }\n  }\n  return messages;\n}\n", "import { BufferWriter } from \"../BufferWriter\";\n\nimport {\n  DeltaNetV01ClientMessage,\n  encodeConnectUser,\n  encodePong,\n  encodeSetUserComponents,\n  encodeClientCustom,\n} from \"./messages\";\n\nexport function encodeClientMessage(message: DeltaNetV01ClientMessage, writer: BufferWriter) {\n  const type = message.type;\n  switch (type) {\n    case \"connectUser\":\n      return encodeConnectUser(message, writer);\n    case \"setUserComponents\":\n      return encodeSetUserComponents(message, writer);\n    case \"pong\":\n      return encodePong(message, writer);\n    case \"clientCustom\":\n      return encodeClientCustom(message, writer);\n    default:\n      throw new Error(`Unknown message type: ${type}`);\n  }\n}\n", "import { BufferWriter } from \"../BufferWriter\";\n\nimport {\n  DeltaNetV01ServerMessage,\n  encodeInitialCheckout,\n  encodeServerCustom,\n  encodeUserIndex,\n} from \"./messages\";\nimport { encodeError } from \"./messages/from-server/error\";\nimport { encodePing } from \"./messages/from-server/ping\";\nimport { encodeTick } from \"./messages/from-server/tick\";\nimport { encodeWarning } from \"./messages/from-server/warning\";\n\nexport function encodeServerMessage(\n  message: DeltaNetV01ServerMessage,\n  writer?: BufferWriter,\n): BufferWriter {\n  switch (message.type) {\n    case \"initialCheckout\":\n      return encodeInitialCheckout(message, writer);\n    case \"tick\":\n      return encodeTick(message, writer);\n    case \"userIndex\":\n      return encodeUserIndex(message, writer);\n    case \"ping\":\n      return encodePing(message, writer);\n    case \"serverCustom\":\n      return encodeServerCustom(message, writer);\n    case \"warning\":\n      return encodeWarning(message, writer);\n    case \"error\":\n      return encodeError(message, writer);\n    default:\n      throw new Error(`Unknown message type: ${(message as any).type}`);\n  }\n}\n"],
  "mappings": "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",
  "names": ["CompressionLibraryChoice", "DeltaNetV01ServerErrors"]
}
