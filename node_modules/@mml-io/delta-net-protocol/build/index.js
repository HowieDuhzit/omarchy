// src/BufferReader.ts
var textDecoder = new TextDecoder();
var BufferReader = class {
  buffer;
  offset;
  /**
   * Creates a new BufferReader instance.
   * @param buffer - The Uint8Array to read from
   */
  constructor(buffer) {
    this.buffer = buffer;
    this.offset = 0;
  }
  /**
   * Reads a single unsigned 8-bit integer from the buffer.
   * @returns The read value
   */
  readUInt8() {
    return this.buffer[this.offset++];
  }
  /**
   * Reads a boolean value from the buffer.
   * @returns true if the read byte is 1, false otherwise
   */
  readBoolean() {
    return this.readUInt8() === 1;
  }
  /**
   * Reads a specified number of bytes from the buffer.
   * @param length - The number of bytes to read
   * @returns A new Uint8Array containing the read bytes
   */
  readBytes(length) {
    const bytes = this.buffer.subarray(this.offset, this.offset + length);
    this.offset += length;
    return bytes;
  }
  /**
   * Reads a length-prefixed byte array from the buffer.
   * The length is encoded as a varint.
   * @returns A new Uint8Array containing the read bytes
   */
  readUVarintPrefixedBytes() {
    const length = this.readUVarint();
    return this.readBytes(length);
  }
  /**
   * Reads a varint-encoded integer from the buffer.
   * Varints are variable-length integers that use the high bit of each byte to indicate if more bytes follow.
   * @param signed - Whether to interpret the value as a signed integer
   * @returns The decoded integer value
   * @throws Error if the varint encoding is invalid
   */
  readUVarint(signed = false) {
    let lo = 0;
    let hi = 0;
    let i = 0;
    for (; i < 4; ++i) {
      lo = (lo | (this.buffer[this.offset] & 127) << i * 7) >>> 0;
      if (this.buffer[this.offset++] < 128) {
        return signed ? loAndHiAsSigned(lo, hi) : loAndHiAsUnsigned(lo, hi);
      }
    }
    lo = (lo | (this.buffer[this.offset] & 127) << 28) >>> 0;
    hi = (hi | (this.buffer[this.offset] & 127) >> 4) >>> 0;
    if (this.buffer[this.offset++] < 128) {
      return signed ? loAndHiAsSigned(lo, hi) : loAndHiAsUnsigned(lo, hi);
    }
    i = 0;
    for (; i < 5; ++i) {
      hi = (hi | (this.buffer[this.offset] & 127) << i * 7 + 3) >>> 0;
      if (this.buffer[this.offset++] < 128) {
        return signed ? loAndHiAsSigned(lo, hi) : loAndHiAsUnsigned(lo, hi);
      }
    }
    throw Error("invalid varint encoding");
  }
  /**
   * Reads a string from the buffer with a specified byte length.
   * Optimized for ASCII strings, falls back to TextDecoder for non-ASCII.
   * @param byteLength - The number of bytes to read
   * @returns The decoded string
   */
  readStringBytes(byteLength) {
    let string = "";
    let hasNonAscii = false;
    for (let i = 0; i < byteLength; i++) {
      const charValue = this.buffer[this.offset + i];
      if (charValue < 128) {
        string += String.fromCharCode(charValue);
      } else {
        hasNonAscii = true;
        break;
      }
    }
    if (!hasNonAscii) {
      this.offset += byteLength;
      return string;
    }
    const result = textDecoder.decode(this.buffer.subarray(this.offset, this.offset + byteLength));
    this.offset += byteLength;
    return result;
  }
  /**
   * Reads a length-prefixed string from the buffer.
   * The length is encoded as an unsigned varint.
   * @returns The decoded string
   */
  readUVarintPrefixedString() {
    const readLength = this.readUVarint();
    return this.readStringBytes(readLength);
  }
  /**
   * Reads a length-prefixed string from the buffer.
   * The length is encoded as a signed varint.
   * @returns A tuple containing the decoded string and a boolean indicating if the length was negative
   */
  readVarintPrefixedString() {
    const length = this.readVarint();
    const negativeLength = length < 0;
    const readLength = negativeLength ? -length : length;
    const result = this.readStringBytes(readLength);
    return [result, negativeLength];
  }
  /**
   * Reads a signed varint-encoded integer from the buffer.
   * @returns The decoded signed integer value
   */
  readVarint() {
    return this.readUVarint(true);
  }
  /**
   * Reads a varint-encoded bigint from the buffer.
   * Varints are variable-length integers that use the high bit of each byte to indicate if more bytes follow.
   * @param signed - Whether to interpret the value as a signed integer
   * @returns The decoded bigint value
   * @throws Error if the varint encoding is invalid
   */
  readUVarintBigInt(signed = false) {
    let result = 0n;
    let shift = 0n;
    let byte;
    let bytesRead = 0;
    do {
      if (bytesRead >= 10) {
        throw Error("invalid varint encoding");
      }
      byte = this.buffer[this.offset++];
      result |= BigInt(byte & 127) << shift;
      shift += 7n;
      bytesRead++;
    } while (byte >= 128);
    if (signed) {
      return result & 1n ? -(result + 1n) / 2n : result / 2n;
    }
    return result;
  }
  /**
   * Reads a signed varint-encoded integer from the buffer.
   * @returns The decoded signed integer value
   */
  readBigIntVarint() {
    return this.readUVarintBigInt(true);
  }
  /**
   * Reads an array of boolean values from the buffer.
   * The booleans are packed into bytes (8 booleans per byte).
   * @returns An array of boolean values
   */
  readLengthPrefixedBoolArray() {
    const length = this.readUVarint();
    const numBytes = Math.ceil(length / 8);
    const result = new Array(length);
    for (let i = 0; i < length; i++) {
      const byteIndex = Math.floor(i / 8);
      const bitPosition = i % 8;
      result[i] = !!(this.buffer[this.offset + byteIndex] & 1 << bitPosition);
    }
    this.offset += numBytes;
    return result;
  }
  /**
   * Checks if the reader has reached the end of the buffer.
   * @returns true if all bytes have been read, false otherwise
   */
  isEnd() {
    return this.offset >= this.buffer.length;
  }
};
function loAndHiAsSigned(lo, hi) {
  const value = lo + hi * 4294967296;
  if (value & 1) {
    return -(value + 1) / 2;
  }
  return value / 2;
}
function loAndHiAsUnsigned(lo, hi) {
  return lo + hi * 4294967296;
}

// src/BufferWriter.ts
var textEncoder = new TextEncoder();
var BufferWriter = class {
  buffer;
  offset;
  /**
   * Creates a new BufferWriter instance.
   * @param initialLength - The initial size of the buffer in bytes
   */
  constructor(initialLength) {
    this.buffer = new Uint8Array(initialLength);
    this.offset = 0;
  }
  /**
   * Writes an unsigned 8-bit integer to the buffer.
   * @param value - The value to write (will be truncated to 8 bits)
   */
  writeUint8(value) {
    this.ensureCapacity(1);
    this.buffer[this.offset] = value & 255;
    this.offset += 1;
  }
  /**
   * Writes a boolean value to the buffer.
   * @param bool - The boolean value to write (true = 1, false = 0)
   */
  writeBoolean(bool) {
    this.writeUint8(bool ? 1 : 0);
  }
  /**
   * Writes an array of bytes to the buffer without a length prefix.
   * @param bytes - The bytes to write
   */
  writeUnprefixedBytes(bytes) {
    this.ensureCapacity(bytes.byteLength);
    this.buffer.set(bytes, this.offset);
    this.offset += bytes.byteLength;
  }
  /**
   * Writes a length-prefixed array of bytes to the buffer.
   * The length is encoded as an unsigned varint.
   * @param bytes - The bytes to write
   */
  writeUVarintLengthPrefixedBytes(bytes) {
    if (!(bytes instanceof Uint8Array)) {
      throw new Error("bytes must be a Uint8Array");
    }
    this.writeUVarint(bytes.byteLength);
    this.writeUnprefixedBytes(bytes);
  }
  /**
   * Gets the written bytes as a Uint8Array.
   * @returns A new Uint8Array containing only the written bytes
   */
  getBuffer() {
    return this.buffer.subarray(0, this.offset);
  }
  /**
   * Gets the number of bytes written so far.
   * @returns The current write offset
   */
  getWrittenLength() {
    return this.offset;
  }
  /**
   * Ensures the buffer has enough capacity for the required space.
   * @param neededSpace - The number of additional bytes needed
   */
  ensureCapacity(neededSpace) {
    while (this.offset + neededSpace > this.buffer.length) {
      this.expandBuffer();
    }
  }
  /**
   * Expands the buffer by doubling its current length.
   */
  expandBuffer() {
    const newBuffer = new Uint8Array(this.buffer.length * 2);
    newBuffer.set(this.buffer);
    this.buffer = newBuffer;
  }
  /**
   * Writes an unsigned varint to the buffer.
   * Varints are variable-length integers that use the high bit of each byte to indicate if more bytes follow.
   * @param x - The value to write
   */
  writeUVarint(x) {
    if (x <= 268435455) {
      this.ensureCapacity(4);
      while (x >= 128) {
        this.buffer[this.offset] = x & 127 | 128;
        this.offset++;
        x >>>= 7;
      }
      this.buffer[this.offset] = x & 127;
      this.offset++;
      return;
    }
    this.ensureCapacity(10);
    let lo = 0;
    let hi = 0;
    if (x !== 0) {
      lo = x >>> 0;
      hi = (x - lo) / 4294967296 >>> 0;
    }
    while (hi) {
      this.buffer[this.offset++] = lo & 127 | 128;
      lo = (lo >>> 7 | hi << 25) >>> 0;
      hi >>>= 7;
    }
    while (lo > 127) {
      this.buffer[this.offset++] = lo & 127 | 128;
      lo = lo >>> 7;
    }
    this.buffer[this.offset++] = lo;
  }
  /**
   * Writes an unsigned varint to the buffer.
   * Varints are variable-length integers that use the high bit of each byte to indicate if more bytes follow.
   * @param x - The value to write
   */
  writeUVarintBigInt(x) {
    this.ensureCapacity(10);
    while (x >= 0x80n) {
      this.buffer[this.offset] = Number(x & 0x7fn) | 128;
      this.offset++;
      x >>= 7n;
    }
    this.buffer[this.offset] = Number(x & 0x7fn);
    this.offset++;
  }
  /**
   * Writes a signed varint to the buffer using zigzag encoding.
   * @param x - The signed value to write
   */
  writeVarint(x) {
    if (x >= 0) {
      this.writeUVarint(x * 2);
    } else {
      this.writeUVarint(-x * 2 - 1);
    }
  }
  /**
   * Writes a signed varint to the buffer using zigzag encoding.
   * @param x - The signed value to write
   */
  writeBigIntVarint(x) {
    if (x >= 0n) {
      this.writeUVarintBigInt(x * 2n);
    } else {
      this.writeUVarintBigInt(-x * 2n - 1n);
    }
  }
  /**
   * Writes an array of boolean values to the buffer.
   * The booleans are packed into bytes (8 booleans per byte).
   * @param data - The array of boolean values to write
   */
  writeLengthPrefixedBoolArray(data) {
    this.writeUVarint(data.length);
    const numBytes = Math.ceil(data.length / 8);
    this.ensureCapacity(numBytes + 4);
    for (let i = 0; i < data.length; i++) {
      if (data[i]) {
        const byteIndex = Math.floor(i / 8);
        const bitPosition = i % 8;
        this.buffer[this.offset + byteIndex] |= 1 << bitPosition;
      }
    }
    this.offset += numBytes;
  }
  /**
   * Writes a length-prefixed string to the buffer.
   * Optimized for ASCII strings, falls back to TextEncoder for non-ASCII.
   * @param value - The string to write
   * @param varint - Whether to use signed varint for length (default: false)
   * @param negativeLength - Whether the length should be negative (only used if varint is true)
   */
  writeLengthPrefixedString(value, varint = false, negativeLength = false) {
    const originalOffset = this.offset;
    if (varint) {
      this.writeVarint(negativeLength ? -value.length : value.length);
    } else {
      this.writeUVarint(value.length);
    }
    this.ensureCapacity(value.length);
    let nonAscii = false;
    for (let i = 0; i < value.length; i++) {
      const charCode = value.charCodeAt(i);
      if (charCode > 127) {
        nonAscii = true;
        break;
      }
      this.buffer[this.offset++] = charCode;
    }
    if (!nonAscii) {
      return;
    }
    this.offset = originalOffset;
    let encodedLength = value.length;
    this.ensureCapacity(encodedLength);
    while (true) {
      this.offset = originalOffset;
      if (varint) {
        this.writeVarint(negativeLength ? -encodedLength : encodedLength);
      } else {
        this.writeUVarint(encodedLength);
      }
      const offsetAfterVarint = this.offset;
      const varintLength = offsetAfterVarint - originalOffset;
      const writeBuffer = new Uint8Array(this.buffer.buffer, this.offset);
      const { read, written } = textEncoder.encodeInto(value, writeBuffer);
      if (read !== value.length) {
        this.expandBuffer();
        continue;
      }
      if (written !== encodedLength) {
        encodedLength = written;
        this.offset = originalOffset;
        if (varint) {
          this.writeVarint(negativeLength ? -encodedLength : encodedLength);
        } else {
          this.writeUVarint(encodedLength);
        }
        const newOffsetAfterVarint = this.offset;
        const actualVarintLength = newOffsetAfterVarint - originalOffset;
        if (actualVarintLength !== varintLength) {
          continue;
        } else {
        }
      }
      this.offset += written;
      return;
    }
  }
};
function zigzagEncode(value) {
  return value >= 0 ? value * 2 : -value * 2 - 1;
}

// src/DeflateCompressor.ts
import { deflate, inflate } from "pako";
var nodeZlibFunctions = null;
try {
  const isNode = typeof process !== "undefined" && process.versions && typeof process.versions.node === "string";
  if (isNode) {
    (async () => {
      try {
        const nodeZlib = await import("zlib");
        nodeZlibFunctions = {
          deflateSync: (data) => {
            const result = nodeZlib.deflateSync(data);
            return new Uint8Array(result);
          },
          inflateSync: (data) => {
            const result = nodeZlib.inflateSync(data);
            return new Uint8Array(result);
          }
        };
      } catch (e) {
        console.log("nodeZlib not available - sync", e);
      }
    })();
  }
} catch (e) {
  console.log("nodeZlib not available - sync", e);
}
var CompressionLibraryChoice = /* @__PURE__ */ ((CompressionLibraryChoice2) => {
  CompressionLibraryChoice2["PAKO"] = "PAKO";
  CompressionLibraryChoice2["NODE_ZLIB"] = "NODE_ZLIB";
  CompressionLibraryChoice2["NO_PREFERENCE"] = "NO_PREFERENCE";
  CompressionLibraryChoice2["NONE"] = "NONE";
  return CompressionLibraryChoice2;
})(CompressionLibraryChoice || {});
function getCompressFunction(compressionLibrary) {
  switch (compressionLibrary) {
    case "PAKO" /* PAKO */:
      return deflate;
    case "NODE_ZLIB" /* NODE_ZLIB */:
      if (nodeZlibFunctions) {
        return nodeZlibFunctions.deflateSync;
      } else {
        throw new Error("node:zlib not available");
      }
    case "NO_PREFERENCE" /* NO_PREFERENCE */:
      if (nodeZlibFunctions) {
        return nodeZlibFunctions.deflateSync;
      } else {
        return deflate;
      }
    case "NONE" /* NONE */:
      return (data) => {
        return new Uint8Array(data);
      };
  }
}
function getDecompressFunction(compressionLibrary) {
  switch (compressionLibrary) {
    case "PAKO" /* PAKO */:
      return inflate;
    case "NODE_ZLIB" /* NODE_ZLIB */:
      if (nodeZlibFunctions) {
        return nodeZlibFunctions.inflateSync;
      } else {
        throw new Error("node:zlib not available");
      }
    case "NO_PREFERENCE" /* NO_PREFERENCE */:
      if (nodeZlibFunctions) {
        return nodeZlibFunctions.inflateSync;
      } else {
        return inflate;
      }
    case "NONE" /* NONE */:
      return (data) => {
        return new Uint8Array(data);
      };
  }
}
var DeflateCompressor = class _DeflateCompressor {
  static compress(data, compressionLibrary = "NO_PREFERENCE" /* NO_PREFERENCE */) {
    return getCompressFunction(compressionLibrary)(data);
  }
  static decompress(compressed, compressionLibrary = "NO_PREFERENCE" /* NO_PREFERENCE */) {
    return getDecompressFunction(compressionLibrary)(compressed);
  }
  static varIntCompress(data, length, compressionLibrary = "NO_PREFERENCE" /* NO_PREFERENCE */) {
    if (length > data.length) {
      throw new Error("length is greater than the data length");
    }
    const writer = new BufferWriter(length);
    for (let i = 0; i < length; i++) {
      writer.writeBigIntVarint(data[i]);
    }
    const uint8Array = writer.getBuffer();
    return [uint8Array, _DeflateCompressor.compress(uint8Array, compressionLibrary)];
  }
  static varIntDecompress(compressed, length, compressionLibrary = "NO_PREFERENCE" /* NO_PREFERENCE */) {
    const data = _DeflateCompressor.decompress(compressed, compressionLibrary);
    const buffer = new BigInt64Array(length);
    const reader = new BufferReader(data);
    for (let i = 0; i < length; i++) {
      buffer[i] = reader.readBigIntVarint();
    }
    return buffer;
  }
  static varIntBytesCompress(data, length, compressionLibrary = "NO_PREFERENCE" /* NO_PREFERENCE */) {
    if (length > data.length) {
      throw new Error("length is greater than the data length");
    }
    const writer = new BufferWriter(length);
    for (let i = 0; i < length; i++) {
      const value = data[i];
      if (value === null || value === void 0) {
        writer.writeUVarintLengthPrefixedBytes(new Uint8Array(0));
      } else {
        writer.writeUVarintLengthPrefixedBytes(value);
      }
    }
    const uint8Array = writer.getBuffer();
    return [uint8Array, _DeflateCompressor.compress(uint8Array, compressionLibrary)];
  }
  static varIntBytesDecompress(compressed, length, compressionLibrary = "NO_PREFERENCE" /* NO_PREFERENCE */) {
    const data = _DeflateCompressor.decompress(compressed, compressionLibrary);
    const buffer = new Array(length);
    const reader = new BufferReader(data);
    for (let i = 0; i < length; i++) {
      buffer[i] = reader.readUVarintPrefixedBytes();
    }
    return buffer;
  }
};

// src/delta-net-v0.1/constants.ts
var deltaNetProtocolSubProtocol_v0_1 = "delta-net-v0.1";

// src/delta-net-v0.1/messageTypes.ts
var InitialCheckoutMessageType = 1;
var ServerCustomMessageType = 2;
var UserIndexMessageType = 3;
var TickMessageType = 4;
var PingMessageType = 5;
var WarningMessageType = 6;
var ErrorMessageType = 7;
var ConnectUserMessageType = 64;
var ClientCustomMessageType = 65;
var SetUserComponentsMessageType = 66;
var SetUserStateMessageType = 67;
var PongMessageType = 68;

// src/delta-net-v0.1/messages/from-client/clientCustom.ts
function encodeClientCustom(msg, writer = new BufferWriter(64)) {
  writer.writeUint8(ClientCustomMessageType);
  writer.writeUVarint(msg.customType);
  writer.writeLengthPrefixedString(msg.contents);
  return writer;
}
function decodeClientCustom(buffer) {
  const customType = buffer.readUVarint();
  const contents = buffer.readUVarintPrefixedString();
  return {
    type: "clientCustom",
    customType,
    contents
  };
}

// src/delta-net-v0.1/messages/from-client/connectUser.ts
function encodeConnectUser(connectUserMessage, writer) {
  writer.writeUint8(ConnectUserMessageType);
  writer.writeLengthPrefixedString(connectUserMessage.token);
  writer.writeBoolean(connectUserMessage.observer ?? false);
  writer.writeUVarint(connectUserMessage.components.length);
  for (const [componentId, componentValue] of connectUserMessage.components) {
    writer.writeUVarint(componentId);
    writer.writeBigIntVarint(componentValue);
  }
  writer.writeUVarint(connectUserMessage.states.length);
  for (const [stateId, stateValue] of connectUserMessage.states) {
    writer.writeUVarint(stateId);
    writer.writeUVarintLengthPrefixedBytes(stateValue);
  }
}
function decodeConnectUser(buffer) {
  const token = buffer.readUVarintPrefixedString();
  const observer = buffer.readBoolean();
  const componentsLength = buffer.readUVarint();
  const components = [];
  for (let i = 0; i < componentsLength; i++) {
    const componentId = buffer.readUVarint();
    const componentValue = buffer.readBigIntVarint();
    components.push([componentId, componentValue]);
  }
  const statesLength = buffer.readUVarint();
  const states = [];
  for (let i = 0; i < statesLength; i++) {
    const stateId = buffer.readUVarint();
    const stateValue = buffer.readUVarintPrefixedBytes();
    states.push([stateId, stateValue]);
  }
  return {
    type: "connectUser",
    token,
    observer,
    components,
    states
  };
}

// src/delta-net-v0.1/messages/from-client/pong.ts
function encodePong(pongMessage, writer) {
  writer.writeUint8(PongMessageType);
  writer.writeUVarint(pongMessage.pong);
}
function decodePong(buffer) {
  const pong = buffer.readUVarint();
  return {
    type: "pong",
    pong
  };
}

// src/delta-net-v0.1/messages/from-client/setUserComponents.ts
function encodeSetUserComponents(message, writer) {
  writer.writeUint8(SetUserComponentsMessageType);
  writer.writeUVarint(message.components.length);
  for (const [componentId, componentValue] of message.components) {
    writer.writeUVarint(componentId);
    writer.writeBigIntVarint(componentValue);
  }
  writer.writeUVarint(message.states.length);
  for (const [stateId, stateValue] of message.states) {
    writer.writeUVarint(stateId);
    writer.writeUVarintLengthPrefixedBytes(stateValue);
  }
}
function decodeSetUserComponents(buffer) {
  const componentsLength = buffer.readUVarint();
  const components = [];
  for (let i = 0; i < componentsLength; i++) {
    const componentId = buffer.readUVarint();
    const componentValue = buffer.readBigIntVarint();
    components.push([componentId, componentValue]);
  }
  const statesLength = buffer.readUVarint();
  const states = [];
  for (let i = 0; i < statesLength; i++) {
    const stateId = buffer.readUVarint();
    const stateValue = buffer.readUVarintPrefixedBytes();
    states.push([stateId, stateValue]);
  }
  return {
    type: "setUserComponents",
    components,
    states
  };
}

// src/delta-net-v0.1/decodeClientMessages.ts
function decodeClientMessages(buffer) {
  const messages = [];
  while (!buffer.isEnd()) {
    const messageType = buffer.readUInt8();
    switch (messageType) {
      case ConnectUserMessageType:
        messages.push(decodeConnectUser(buffer));
        break;
      case SetUserComponentsMessageType:
        messages.push(decodeSetUserComponents(buffer));
        break;
      case PongMessageType:
        messages.push(decodePong(buffer));
        break;
      case ClientCustomMessageType:
        messages.push(decodeClientCustom(buffer));
        break;
      default:
        throw new Error(`Unknown message type: ${messageType}`);
    }
  }
  return messages;
}

// src/delta-net-v0.1/messages/from-server/error.ts
var DeltaNetV01ServerErrors;
((DeltaNetV01ServerErrors2) => {
  DeltaNetV01ServerErrors2.USER_ALREADY_AUTHENTICATED_ERROR_TYPE = "USER_ALREADY_AUTHENTICATED";
  DeltaNetV01ServerErrors2.USER_NOT_AUTHENTICATED_ERROR_TYPE = "USER_NOT_AUTHENTICATED";
  DeltaNetV01ServerErrors2.AUTHENTICATION_IN_PROGRESS_ERROR_TYPE = "AUTHENTICATION_IN_PROGRESS";
  DeltaNetV01ServerErrors2.OBSERVER_CANNOT_SEND_STATE_UPDATES_ERROR_TYPE = "OBSERVER_CANNOT_SEND_STATE_UPDATES";
  DeltaNetV01ServerErrors2.UNSUPPORTED_WEBSOCKET_SUBPROTOCOL_ERROR_TYPE = "UNSUPPORTED_WEBSOCKET_SUBPROTOCOL";
  DeltaNetV01ServerErrors2.USER_NETWORKING_UNKNOWN_ERROR_TYPE = "USER_NETWORKING_UNKNOWN_ERROR";
  DeltaNetV01ServerErrors2.USER_AUTHENTICATION_FAILED_ERROR_TYPE = "USER_AUTHENTICATION_FAILED";
  DeltaNetV01ServerErrors2.USER_NETWORKING_CONNECTION_LIMIT_REACHED_ERROR_TYPE = "CONNECTION_LIMIT_REACHED";
  DeltaNetV01ServerErrors2.USER_NETWORKING_SERVER_SHUTDOWN_ERROR_TYPE = "SERVER_SHUTDOWN";
})(DeltaNetV01ServerErrors || (DeltaNetV01ServerErrors = {}));
function encodeError(msg, writer = new BufferWriter(64)) {
  writer.writeUint8(ErrorMessageType);
  writer.writeLengthPrefixedString(msg.errorType);
  writer.writeLengthPrefixedString(msg.message);
  writer.writeBoolean(msg.retryable);
  return writer;
}
function decodeError(buffer) {
  const errorType = buffer.readUVarintPrefixedString();
  const message = buffer.readUVarintPrefixedString();
  const retryable = buffer.readBoolean();
  return {
    type: "error",
    errorType,
    message,
    retryable
  };
}

// src/delta-net-v0.1/messages/from-server/initialCheckout.ts
function encodeInitialCheckout(msg, writer = new BufferWriter(64)) {
  writer.writeUint8(InitialCheckoutMessageType);
  writer.writeUVarint(msg.serverTime);
  writer.writeUVarint(msg.indicesCount);
  writer.writeUVarint(msg.components.length);
  for (const { componentId, deltas, values } of msg.components) {
    writer.writeUVarint(componentId);
    const [, valuesBytes] = DeflateCompressor.varIntCompress(values, msg.indicesCount);
    writer.writeUVarintLengthPrefixedBytes(valuesBytes);
    const [, deltaBytes] = DeflateCompressor.varIntCompress(deltas, msg.indicesCount);
    writer.writeUVarintLengthPrefixedBytes(deltaBytes);
  }
  writer.writeUVarint(msg.states.length);
  for (const { stateId, values } of msg.states) {
    writer.writeUVarint(stateId);
    const [, stateBytes] = DeflateCompressor.varIntBytesCompress(values, msg.indicesCount);
    writer.writeUVarintLengthPrefixedBytes(stateBytes);
  }
  return writer;
}
var lastInitialCheckoutDebugData = {
  componentsByteLength: 0,
  statesByteLength: 0
};
function decodeInitialCheckout(buffer, opts) {
  let componentsByteLength = 0;
  let statesByteLength = 0;
  const serverTime = buffer.readUVarint();
  const indicesLength = buffer.readUVarint();
  const componentsLength = buffer.readUVarint();
  const components = [];
  for (let i = 0; i < componentsLength; i++) {
    const componentId = buffer.readUVarint();
    const valuesBytes = buffer.readUVarintPrefixedBytes();
    const values = DeflateCompressor.varIntDecompress(valuesBytes, indicesLength);
    const deltaBytes = buffer.readUVarintPrefixedBytes();
    componentsByteLength += valuesBytes.length + deltaBytes.length;
    if (opts == null ? void 0 : opts.ignoreData) {
      components.push({ componentId, deltas: new BigInt64Array(indicesLength), values });
    } else {
      const deltas = DeflateCompressor.varIntDecompress(deltaBytes, indicesLength);
      components.push({ componentId, deltas, values });
    }
  }
  const statesLength = buffer.readUVarint();
  const states = [];
  for (let i = 0; i < statesLength; i++) {
    const stateId = buffer.readUVarint();
    const valuesBytes = buffer.readUVarintPrefixedBytes();
    statesByteLength += valuesBytes.length;
    if (opts == null ? void 0 : opts.ignoreData) {
      const emptyValues = new Array(indicesLength).fill(new Uint8Array(0));
      states.push({ stateId, values: emptyValues });
    } else {
      const values = DeflateCompressor.varIntBytesDecompress(valuesBytes, indicesLength);
      states.push({ stateId, values });
    }
  }
  lastInitialCheckoutDebugData.componentsByteLength = componentsByteLength;
  lastInitialCheckoutDebugData.statesByteLength = statesByteLength;
  return {
    type: "initialCheckout",
    serverTime,
    indicesCount: indicesLength,
    components,
    states
  };
}

// src/delta-net-v0.1/messages/from-server/ping.ts
function encodePing(pingMessage, writer = new BufferWriter(8)) {
  writer.writeUint8(PingMessageType);
  writer.writeUVarint(pingMessage.ping);
  return writer;
}
function decodePing(buffer) {
  const ping = buffer.readUVarint();
  return {
    type: "ping",
    ping
  };
}

// src/delta-net-v0.1/messages/from-server/serverCustom.ts
function encodeServerCustom(msg, writer = new BufferWriter(64)) {
  writer.writeUint8(ServerCustomMessageType);
  writer.writeUVarint(msg.customType);
  writer.writeLengthPrefixedString(msg.contents);
  return writer;
}
function decodeServerCustom(buffer) {
  const customType = buffer.readUVarint();
  const contents = buffer.readUVarintPrefixedString();
  return {
    type: "serverCustom",
    customType,
    contents
  };
}

// src/delta-net-v0.1/messages/from-server/tick.ts
function encodeTick(msg, writer = new BufferWriter(64)) {
  writer.writeUint8(TickMessageType);
  writer.writeUVarint(msg.serverTime);
  writer.writeUVarint(msg.removedIndices.length);
  for (const index of msg.removedIndices) {
    writer.writeUVarint(index);
  }
  writer.writeUVarint(msg.indicesCount);
  writer.writeUVarint(msg.componentDeltaDeltas.length);
  for (const componentTick of msg.componentDeltaDeltas) {
    writer.writeUVarint(componentTick.componentId);
    const [, deltaDeltasBytes] = DeflateCompressor.varIntCompress(
      componentTick.deltaDeltas,
      msg.indicesCount
    );
    writer.writeUVarintLengthPrefixedBytes(deltaDeltasBytes);
  }
  writer.writeUVarint(msg.states.length);
  for (const state of msg.states) {
    writer.writeUVarint(state.stateId);
    writer.writeUVarint(state.updatedStates.length);
    const indices = new BigInt64Array(state.updatedStates.length);
    const values = new Array(state.updatedStates.length);
    for (let i = 0; i < state.updatedStates.length; i++) {
      const [index, value] = state.updatedStates[i];
      indices[i] = BigInt(index);
      values[i] = value;
    }
    const [, compressedIndices] = DeflateCompressor.varIntCompress(indices, indices.length);
    writer.writeUVarintLengthPrefixedBytes(compressedIndices);
    const [, compressedValues] = DeflateCompressor.varIntBytesCompress(values, values.length);
    writer.writeUVarintLengthPrefixedBytes(compressedValues);
  }
  return writer;
}
var lastTickDebugData = {
  componentsByteLength: 0,
  statesByteLength: 0
};
function decodeTick(buffer, opts) {
  let componentsByteLength = 0;
  let statesByteLength = 0;
  const serverTime = buffer.readUVarint();
  const removedIndicesLength = buffer.readUVarint();
  const removedIndices = [];
  for (let i = 0; i < removedIndicesLength; i++) {
    removedIndices.push(buffer.readUVarint());
  }
  const indicesCount = buffer.readUVarint();
  const componentsLength = buffer.readUVarint();
  const components = [];
  for (let i = 0; i < componentsLength; i++) {
    const componentId = buffer.readUVarint();
    const deltaDeltaBytes = buffer.readUVarintPrefixedBytes();
    componentsByteLength += deltaDeltaBytes.byteLength;
    if (opts == null ? void 0 : opts.ignoreData) {
      components.push({ componentId, deltaDeltas: new BigInt64Array(indicesCount) });
    } else {
      const deltaDeltas = DeflateCompressor.varIntDecompress(deltaDeltaBytes, indicesCount);
      components.push({ componentId, deltaDeltas });
    }
  }
  const statesLength = buffer.readUVarint();
  const states = [];
  for (let i = 0; i < statesLength; i++) {
    const stateId = buffer.readUVarint();
    const stateCount = buffer.readUVarint();
    const state = {
      stateId,
      updatedStates: []
    };
    const compressedIndices = buffer.readUVarintPrefixedBytes();
    const compressedValues = buffer.readUVarintPrefixedBytes();
    statesByteLength += compressedIndices.byteLength;
    statesByteLength += compressedValues.byteLength;
    if (stateCount > 0) {
      const indices = DeflateCompressor.varIntDecompress(compressedIndices, stateCount);
      const values = DeflateCompressor.varIntBytesDecompress(compressedValues, stateCount);
      for (let j = 0; j < stateCount; j++) {
        const index = Number(indices[j]);
        const value = values[j];
        state.updatedStates.push([index, value]);
      }
    }
    states.push(state);
  }
  lastTickDebugData.componentsByteLength = componentsByteLength;
  lastTickDebugData.statesByteLength = statesByteLength;
  return {
    type: "tick",
    serverTime,
    removedIndices,
    indicesCount,
    componentDeltaDeltas: components,
    states
  };
}

// src/delta-net-v0.1/messages/from-server/userIndex.ts
function encodeUserIndex(msg, writer = new BufferWriter(64)) {
  writer.writeUint8(UserIndexMessageType);
  writer.writeUVarint(msg.index);
  return writer;
}
function decodeUserIndex(buffer) {
  const index = buffer.readUVarint();
  return {
    type: "userIndex",
    index
  };
}

// src/delta-net-v0.1/messages/from-server/warning.ts
function encodeWarning(msg, writer = new BufferWriter(64)) {
  writer.writeUint8(WarningMessageType);
  writer.writeLengthPrefixedString(msg.message);
  return writer;
}
function decodeWarning(buffer) {
  const message = buffer.readUVarintPrefixedString();
  return {
    type: "warning",
    message
  };
}

// src/delta-net-v0.1/decodeServerMessages.ts
function decodeServerMessages(buffer, opts) {
  const messages = [];
  while (!buffer.isEnd()) {
    const messageType = buffer.readUInt8();
    switch (messageType) {
      case InitialCheckoutMessageType:
        messages.push(decodeInitialCheckout(buffer, opts));
        break;
      case UserIndexMessageType:
        messages.push(decodeUserIndex(buffer));
        break;
      case TickMessageType:
        messages.push(decodeTick(buffer, opts));
        break;
      case ServerCustomMessageType:
        messages.push(decodeServerCustom(buffer));
        break;
      case PingMessageType:
        messages.push(decodePing(buffer));
        break;
      case WarningMessageType:
        messages.push(decodeWarning(buffer));
        break;
      case ErrorMessageType:
        messages.push(decodeError(buffer));
        break;
      default:
        throw new Error(`Unknown message type: ${messageType}`);
    }
  }
  return messages;
}

// src/delta-net-v0.1/encodeClientMessage.ts
function encodeClientMessage(message, writer) {
  const type = message.type;
  switch (type) {
    case "connectUser":
      return encodeConnectUser(message, writer);
    case "setUserComponents":
      return encodeSetUserComponents(message, writer);
    case "pong":
      return encodePong(message, writer);
    case "clientCustom":
      return encodeClientCustom(message, writer);
    default:
      throw new Error(`Unknown message type: ${type}`);
  }
}

// src/delta-net-v0.1/encodeServerMessage.ts
function encodeServerMessage(message, writer) {
  switch (message.type) {
    case "initialCheckout":
      return encodeInitialCheckout(message, writer);
    case "tick":
      return encodeTick(message, writer);
    case "userIndex":
      return encodeUserIndex(message, writer);
    case "ping":
      return encodePing(message, writer);
    case "serverCustom":
      return encodeServerCustom(message, writer);
    case "warning":
      return encodeWarning(message, writer);
    case "error":
      return encodeError(message, writer);
    default:
      throw new Error(`Unknown message type: ${message.type}`);
  }
}
export {
  BufferReader,
  BufferWriter,
  ClientCustomMessageType,
  CompressionLibraryChoice,
  ConnectUserMessageType,
  DeflateCompressor,
  DeltaNetV01ServerErrors,
  ErrorMessageType,
  InitialCheckoutMessageType,
  PingMessageType,
  PongMessageType,
  ServerCustomMessageType,
  SetUserComponentsMessageType,
  SetUserStateMessageType,
  TickMessageType,
  UserIndexMessageType,
  WarningMessageType,
  decodeClientCustom,
  decodeClientMessages,
  decodeConnectUser,
  decodeError,
  decodeInitialCheckout,
  decodePing,
  decodePong,
  decodeServerCustom,
  decodeServerMessages,
  decodeSetUserComponents,
  decodeTick,
  decodeUserIndex,
  decodeWarning,
  deltaNetProtocolSubProtocol_v0_1,
  encodeClientCustom,
  encodeClientMessage,
  encodeConnectUser,
  encodeError,
  encodeInitialCheckout,
  encodePing,
  encodePong,
  encodeServerCustom,
  encodeServerMessage,
  encodeSetUserComponents,
  encodeTick,
  encodeUserIndex,
  encodeWarning,
  lastInitialCheckoutDebugData,
  lastTickDebugData,
  zigzagEncode
};
//# sourceMappingURL=index.js.map
