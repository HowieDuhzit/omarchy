// src/character/MMLCharacter.ts
import { Group, MathUtils, Sphere, Vector3 } from "three";
var MMLCharacter = class _MMLCharacter {
  constructor(modelLoader) {
    this.modelLoader = modelLoader;
  }
  static load(fullBodyURL, bodyParts, modelLoader, abortController) {
    const mmlCharacter = new _MMLCharacter(modelLoader);
    return mmlCharacter.load(fullBodyURL, bodyParts, abortController);
  }
  createBoneIndexMap(originSkeleton, targetSkeleton) {
    const boneIndexMap = /* @__PURE__ */ new Map();
    for (let i = 0; i < originSkeleton.bones.length; i++) {
      const originBone = originSkeleton.bones[i];
      const targetBone = targetSkeleton.bones.find((bone) => bone.name === originBone.name);
      if (targetBone) {
        boneIndexMap.set(i, targetSkeleton.bones.indexOf(targetBone));
      }
    }
    return boneIndexMap;
  }
  remapBoneIndices(skinnedMesh, targetSkeleton) {
    const originSkeleton = skinnedMesh.skeleton;
    const originGeometry = skinnedMesh.geometry;
    const boneIndexMap = this.createBoneIndexMap(originSkeleton, targetSkeleton);
    const missingBoneIndices = /* @__PURE__ */ new Set();
    const skinIndexAttribute = originGeometry.attributes.skinIndex;
    for (let i = 0; i < skinIndexAttribute.count; i++) {
      const originIndex = skinIndexAttribute.getComponent(i, 0);
      const targetIndex = boneIndexMap.get(originIndex);
      if (targetIndex !== void 0) {
        skinIndexAttribute.setComponent(i, 0, targetIndex);
      } else {
        missingBoneIndices.add(originIndex);
      }
    }
    if (missingBoneIndices.size > 0) {
      console.warn(
        `Missing bone indices in skinIndex attribute: ${Array.from(missingBoneIndices).join(", ")}`
      );
    }
  }
  async load(fullBodyURL, bodyParts, abortController) {
    const group = new Group();
    const fullBodyAssetPromise = this.modelLoader.load(fullBodyURL, abortController);
    const assetPromises = bodyParts.map((part) => {
      return new Promise((resolve) => {
        this.modelLoader.load(part.url, abortController).then((asset) => {
          if (!asset) {
            resolve(null);
            return;
          }
          resolve({ asset, part });
        });
      });
    });
    const fullBodyAsset = await fullBodyAssetPromise;
    if (abortController == null ? void 0 : abortController.signal.aborted) {
      return null;
    }
    if (!fullBodyAsset) {
      return null;
    }
    const assets = await Promise.all(assetPromises);
    if (abortController == null ? void 0 : abortController.signal.aborted) {
      return null;
    }
    const rawBodyGltf = fullBodyAsset.group;
    const availableBones = /* @__PURE__ */ new Map();
    rawBodyGltf.traverse((child) => {
      const asBone = child;
      if (asBone.isBone) {
        availableBones.set(child.name, asBone);
      }
      const asSkinnedMesh = child;
      if (asSkinnedMesh.isSkinnedMesh) {
        asSkinnedMesh.castShadow = true;
        asSkinnedMesh.receiveShadow = true;
      }
    });
    const foundSkinnedMeshes = [];
    rawBodyGltf.traverse((child) => {
      const asSkinnedMesh = child;
      if (asSkinnedMesh.isSkinnedMesh) {
        foundSkinnedMeshes.push(asSkinnedMesh);
        asSkinnedMesh.boundingSphere = new Sphere(new Vector3(), 3);
      }
    });
    if (foundSkinnedMeshes.length === 0) {
      throw new Error("No skinned mesh in base model file");
    }
    if (foundSkinnedMeshes.length > 1) {
      console.warn(
        "Multiple skinned meshes in base model file. Expected 1. Using first for skeleton."
      );
    }
    const skinnedMesh = foundSkinnedMeshes[0];
    group.add(...foundSkinnedMeshes);
    const sharedSkeleton = skinnedMesh.skeleton;
    group.add(skinnedMesh.skeleton.bones[0]);
    const sharedMatrixWorld = skinnedMesh.matrixWorld;
    for (const loadingAsset of assets) {
      if (loadingAsset) {
        const part = loadingAsset.part;
        const rawGltf = loadingAsset.asset;
        const modelGroup = rawGltf.group;
        if (part.socket) {
          const socketName = part.socket.socket;
          let bone = availableBones.get("root");
          if (availableBones.has(socketName)) {
            bone = availableBones.get(socketName);
          } else {
            console.warn(
              `WARNING: no bone found for [${socketName}] socket. Attatching to Root bone`
            );
          }
          if (bone) {
            bone.add(modelGroup);
            modelGroup.position.set(
              part.socket.position.x,
              part.socket.position.y,
              part.socket.position.z
            );
            modelGroup.rotation.set(
              MathUtils.degToRad(part.socket.rotation.x),
              MathUtils.degToRad(part.socket.rotation.y),
              MathUtils.degToRad(part.socket.rotation.z)
            );
            modelGroup.scale.set(part.socket.scale.x, part.socket.scale.y, part.socket.scale.z);
          }
        } else {
          const skinnedMeshes = [];
          modelGroup.traverse((child) => {
            const asSkinnedMesh = child;
            if (asSkinnedMesh.isSkinnedMesh) {
              skinnedMeshes.push(asSkinnedMesh);
              asSkinnedMesh.boundingSphere = new Sphere(new Vector3(), 3);
            }
          });
          for (const skinnedMeshPart of skinnedMeshes) {
            this.remapBoneIndices(skinnedMeshPart, sharedSkeleton);
            skinnedMeshPart.castShadow = true;
            skinnedMeshPart.receiveShadow = true;
            skinnedMeshPart.bind(sharedSkeleton, sharedMatrixWorld);
            skinnedMeshPart.children = [];
            group.add(skinnedMeshPart);
          }
        }
      }
    }
    return group;
  }
};

// src/helpers/cloneSkinnedMesh.ts
import * as SkeletonUtils from "three/examples/jsm/utils/SkeletonUtils.js";
function cloneSkinnedMesh(model) {
  return SkeletonUtils.clone(model);
}

// src/helpers/parseMMLDescription.ts
var parseMMLDescription = (mmlDescription, mmlCharacterUrl) => {
  const parser = new DOMParser();
  const doc = parser.parseFromString(mmlDescription, "text/html");
  const tag = (count) => {
    return count > 1 ? "tags" : "tag";
  };
  const errors = [];
  const warn = (errorMessage) => {
    errors.push(errorMessage);
    console.warn(errorMessage);
  };
  const characters = Array.from(doc.body.children).filter(
    (child) => child.tagName.toLowerCase() === "m-character"
  );
  const validCharacter = characters.shift();
  if (characters.length > 0) {
    const tagStr = tag(characters.length);
    warn(
      `ignoring ${characters.length} extra <m-character> ${tagStr} found in the root of the document (only the first one is valid).`
    );
  }
  const nestedCharacters = doc.querySelectorAll("body * m-character");
  if (nestedCharacters.length > 0) {
    const tagStr = tag(nestedCharacters.length);
    warn(
      `ignoring ${nestedCharacters.length} nested <m-character> ${tagStr} found within other tags. A valid <m-character> tag must be at the root of the document.`
    );
  }
  const rootModels = Array.from(doc.body.children).filter(
    (child) => child.tagName.toLowerCase() === "m-model"
  );
  if (rootModels.length > 0) {
    const tagStr = tag(rootModels.length);
    warn(
      `ignoring ${rootModels.length} <m-model> ${tagStr} were found at the root of the document (<m-model> tags must be children of a valid <m-character> tag).`
    );
  }
  let base = { url: "" };
  let parts = [];
  if (validCharacter) {
    let baseSrc = validCharacter.getAttribute("src") ?? "";
    if (mmlCharacterUrl) {
      baseSrc = new URL(baseSrc, mmlCharacterUrl).toString();
    }
    base = { url: baseSrc };
    const directModelChildren = Array.from(validCharacter.children).filter(
      (child) => child.tagName.toLowerCase() === "m-model"
    );
    parts = directModelChildren.map((model) => {
      let partSrc = model.getAttribute("src") ?? "";
      if (mmlCharacterUrl) {
        partSrc = new URL(partSrc, mmlCharacterUrl).toString();
      }
      const socketAttr = model.getAttribute("socket");
      const position = {
        x: parseFloat(model.getAttribute("x") ?? "0") || 0,
        y: parseFloat(model.getAttribute("y") ?? "0") || 0,
        z: parseFloat(model.getAttribute("z") ?? "0") || 0
      };
      const scale = {
        x: parseFloat(model.getAttribute("sx") ?? "1") || 1,
        y: parseFloat(model.getAttribute("sy") ?? "1") || 1,
        z: parseFloat(model.getAttribute("sz") ?? "1") || 1
      };
      const rotation = {
        x: parseFloat(model.getAttribute("rx") ?? "0") || 0,
        y: parseFloat(model.getAttribute("ry") ?? "0") || 0,
        z: parseFloat(model.getAttribute("rz") ?? "0") || 0
      };
      const socketObj = socketAttr ? { socket: socketAttr, position, scale, rotation } : void 0;
      return { url: partSrc, socket: socketObj };
    });
    const wrappedModelTags = Array.from(doc.querySelectorAll("m-character m-model")).filter(
      (model) => !directModelChildren.includes(model)
    );
    if (wrappedModelTags.length > 0) {
      const tagStr = tag(wrappedModelTags.length);
      warn(
        `ignoring ${wrappedModelTags.length} <m-model> ${tagStr} that were found wrapped inside tags other than a valid <m-character> tag.`
      );
    }
  } else {
    warn(`No valid <m-character> tag was found in the provided document.`);
  }
  const characterDescription = {
    base,
    parts
  };
  return [characterDescription, errors];
};

// src/helpers/createMMLCharacterString.ts
var createMMLCharacterString = (characterDescription) => {
  const base = characterDescription.base.url;
  const partsTags = characterDescription.parts.map(
    (part) => `<m-model src="${part.url}"${part.type ? ` type="${part.type}"` : ""}></m-model>`
  );
  return `<m-character src="${base}">
  ${partsTags.join("\n  ")}
</m-character>`;
};
export {
  MMLCharacter,
  cloneSkinnedMesh,
  createMMLCharacterString,
  parseMMLDescription
};
//# sourceMappingURL=index.js.map
