// src/DeltaNetClientState.ts
var DeltaNetClientState = class {
  componentValues = /* @__PURE__ */ new Map();
  allStates = /* @__PURE__ */ new Map();
  byStableId = /* @__PURE__ */ new Map();
  localClientIndex = -1;
  indicesCount = 0;
  stableIdToIndex = /* @__PURE__ */ new Map();
  stableIds = [];
  stableIdCounter = 1e3;
  // Start at 1000 to avoid confusion with indices
  constructor() {
    this.reset();
  }
  /**
   * Reset all state to initial values. This should be called when reconnecting
   * to ensure that stale data from previous connections doesn't interfere.
   */
  reset() {
    this.componentValues.clear();
    this.allStates.clear();
    this.byStableId.clear();
    this.localClientIndex = -1;
    this.indicesCount = 0;
    this.stableIdToIndex.clear();
    this.stableIds.length = 0;
    this.stableIdCounter = 1e3;
  }
  getComponentValues() {
    return this.componentValues;
  }
  getStateById(stateId) {
    return this.allStates.get(stateId) ?? null;
  }
  getAllStates() {
    return this.allStates;
  }
  getLocalClientIndex() {
    return this.localClientIndex;
  }
  getIndicesCount() {
    return this.indicesCount;
  }
  getStableIds() {
    return this.stableIds;
  }
  getComponentValueForStableId(stableId, componentId) {
    const index = this.stableIdToIndex.get(stableId);
    if (index === void 0) {
      return null;
    }
    const componentValue = this.componentValues.get(componentId);
    if (!componentValue) {
      return null;
    }
    return componentValue.values[index] ?? null;
  }
  getComponentsForStableId(stableId) {
    const index = this.stableIdToIndex.get(stableId);
    if (index === void 0) {
      return null;
    }
    const componentMap = /* @__PURE__ */ new Map();
    for (const [key, componentValue] of this.componentValues) {
      if (componentValue === void 0) {
        throw new Error(`Component value for key ${key} is undefined`);
      }
      componentMap.set(key, componentValue.values[index]);
    }
    return componentMap;
  }
  handleInitialCheckout(initialCheckout) {
    const { indicesCount, initialComponents, initialStates } = initialCheckout;
    const addedStableIds = [];
    for (let i = 0; i < indicesCount; i++) {
      const stableId = this.stableIdCounter++;
      this.stableIds.push(stableId);
      this.stableIdToIndex.set(stableId, i);
      const entityInfo = {
        stableId,
        components: /* @__PURE__ */ new Map(),
        states: /* @__PURE__ */ new Map()
      };
      this.byStableId.set(stableId, entityInfo);
      addedStableIds.push(stableId);
    }
    this.indicesCount = indicesCount;
    const deltaDeltas = new BigInt64Array(indicesCount);
    for (let i = 0; i < deltaDeltas.length; i++) {
      deltaDeltas[i] = BigInt(0);
    }
    for (const [key, value] of initialComponents) {
      this.componentValues.set(key, {
        values: value.values,
        deltas: value.deltas,
        deltaDeltas
      });
      for (let i = 0; i < this.stableIds.length; i++) {
        const stableId = this.stableIds[i];
        const entityInfo = this.byStableId.get(stableId);
        if (entityInfo) {
          entityInfo.components.set(key, value.values[i]);
        }
      }
    }
    for (const [stateId, values] of initialStates) {
      this.allStates.set(stateId, values);
      for (let i = 0; i < this.stableIds.length; i++) {
        const stableId = this.stableIds[i];
        const entityInfo = this.byStableId.get(stableId);
        const stateValue = values[i];
        if (entityInfo) {
          entityInfo.states.set(stateId, stateValue);
        }
      }
    }
    return { addedStableIds };
  }
  handleTick(tick) {
    const { unoccupying, indicesCount, componentDeltaDeltas, stateChanges } = tick;
    let removedStableIds = [];
    if (unoccupying.length > 0) {
      const stableIdsToRemove = unoccupying.map((index) => this.stableIds[index]);
      removedStableIds = stableIdsToRemove.filter((stableId) => stableId !== void 0);
      for (const [componentId, component] of this.componentValues) {
        this.removeIndicesFromBigInt64Array(unoccupying, component.values);
        this.removeIndicesFromBigInt64Array(unoccupying, component.deltas);
      }
      for (const [stateId, state] of this.allStates) {
        this.removeIndicesFromState(unoccupying, state);
      }
      let decrementIndex = 0;
      for (const index of unoccupying) {
        if (index <= this.localClientIndex) {
          decrementIndex++;
        }
      }
      this.localClientIndex -= decrementIndex;
      this.indicesCount -= unoccupying.length;
      this.removeIndices(unoccupying);
      for (const stableId of stableIdsToRemove) {
        if (stableId === void 0) {
          throw new Error(`stableId is undefined`);
        }
        this.byStableId.delete(stableId);
      }
    }
    const addedStableIds = [];
    if (indicesCount > this.indicesCount) {
      const addedIndices = indicesCount - this.indicesCount;
      for (let i = 0; i < addedIndices; i++) {
        const stableId = this.stableIdCounter++;
        this.stableIds.push(stableId);
        this.stableIdToIndex.set(stableId, this.stableIds.length - 1);
        const entityInfo = {
          stableId,
          components: /* @__PURE__ */ new Map(),
          states: /* @__PURE__ */ new Map()
        };
        this.byStableId.set(stableId, entityInfo);
        addedStableIds.push(stableId);
      }
    }
    this.indicesCount = indicesCount;
    for (const [key, deltaDeltas] of componentDeltaDeltas) {
      if (deltaDeltas.length !== indicesCount) {
        throw new Error(
          `DeltaDeltas length (${deltaDeltas.length}) does not match indices count (${indicesCount})`
        );
      }
      const existingComponent = this.componentValues.get(key);
      if (!existingComponent) {
        const values = new BigInt64Array(deltaDeltas);
        const deltas = new BigInt64Array(deltaDeltas);
        this.componentValues.set(key, { values, deltas, deltaDeltas });
      } else {
        if (existingComponent.values.length < deltaDeltas.length) {
          const newValues = new BigInt64Array(deltaDeltas.length);
          newValues.set(existingComponent.values);
          const newDeltas = new BigInt64Array(deltaDeltas.length);
          newDeltas.set(existingComponent.deltas);
          const newDeltaDelta = new BigInt64Array(deltaDeltas.length);
          newDeltaDelta.set(existingComponent.deltaDeltas);
          for (let i = existingComponent.values.length; i < deltaDeltas.length; i++) {
            newValues[i] = BigInt(0);
            newDeltas[i] = BigInt(0);
            newDeltaDelta[i] = BigInt(0);
          }
          existingComponent.values = newValues;
          existingComponent.deltas = newDeltas;
          existingComponent.deltaDeltas = newDeltaDelta;
        }
        for (let i = 0; i < deltaDeltas.length; i++) {
          const deltaDelta = deltaDeltas[i];
          const stableId = this.stableIds[i];
          existingComponent.deltaDeltas[i] = deltaDelta;
          existingComponent.deltas[i] += deltaDelta;
          existingComponent.values[i] += existingComponent.deltas[i];
          const entityInfo = this.byStableId.get(stableId);
          if (entityInfo) {
            entityInfo.components.set(key, existingComponent.values[i]);
          }
        }
      }
    }
    const stateUpdates = [];
    for (const [stateId, states] of stateChanges) {
      let state = this.allStates.get(stateId);
      if (!state) {
        state = [];
        this.allStates.set(stateId, state);
      }
      for (const [index, value] of states) {
        const stableId = this.stableIds[index];
        if (stableId === void 0) {
          throw new Error(`Stable ID is undefined for index ${index} in state ${stateId}`);
        }
        stateUpdates.push({
          stableId,
          stateId,
          state: value
        });
        state[index] = value;
        const entityInfo = this.byStableId.get(stableId);
        if (entityInfo) {
          entityInfo.states.set(stateId, value);
        }
      }
    }
    return { stateUpdates, removedStableIds, addedStableIds };
  }
  setLocalIndex(index) {
    this.localClientIndex = index;
  }
  removeIndices(removing) {
    if (removing.length === 0) {
      return;
    }
    let writeIndex = 0;
    let skipIndex = 0;
    for (let readIndex = 0; readIndex < this.stableIds.length; readIndex++) {
      if (skipIndex < removing.length && readIndex === removing[skipIndex]) {
        skipIndex++;
        continue;
      }
      const stableId = this.stableIds[readIndex];
      if (writeIndex !== readIndex) {
        this.stableIds[writeIndex] = this.stableIds[readIndex];
      }
      this.stableIdToIndex.set(stableId, writeIndex);
      writeIndex++;
    }
    this.stableIds.length = writeIndex;
  }
  removeIndicesFromBigInt64Array(removing, array) {
    if (removing.length === 0) {
      return;
    }
    let writeIndex = 0;
    let skipIndex = 0;
    for (let readIndex = 0; readIndex < array.length; readIndex++) {
      if (skipIndex < removing.length && readIndex === removing[skipIndex]) {
        skipIndex++;
        continue;
      }
      if (writeIndex !== readIndex) {
        array[writeIndex] = array[readIndex];
      }
      writeIndex++;
    }
    for (let i = writeIndex; i < array.length; i++) {
      array[i] = BigInt(0);
    }
  }
  removeIndicesFromState(removing, state) {
    if (removing.length === 0) {
      return;
    }
    let writeIndex = 0;
    let skipIndex = 0;
    for (let readIndex = 0; readIndex < state.length; readIndex++) {
      if (skipIndex < removing.length && readIndex === removing[skipIndex]) {
        skipIndex++;
        continue;
      }
      if (writeIndex !== readIndex) {
        state[writeIndex] = state[readIndex];
      }
      writeIndex++;
    }
  }
};

// src/DeltaNetClientWebsocket.ts
import { deltaNetProtocolSubProtocol_v0_1 } from "@mml-io/delta-net-protocol";

// src/DeltaNetClientWebsocketV01Adapter.ts
import {
  BufferReader,
  BufferWriter,
  decodeServerMessages,
  encodeClientMessage,
  lastInitialCheckoutDebugData,
  lastTickDebugData
} from "@mml-io/delta-net-protocol";
function areUint8ArraysEqual(a, b) {
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) return false;
  }
  return true;
}
var DeltaNetClientWebsocketV01Adapter = class {
  constructor(websocket, connectedCallback, options, token, internalOptions, timeCallback) {
    this.websocket = websocket;
    this.connectedCallback = connectedCallback;
    this.options = options;
    this.token = token;
    this.internalOptions = internalOptions;
    this.timeCallback = timeCallback;
    this.websocket.binaryType = "arraybuffer";
    this.isObserver = options.observer ?? false;
    if (this.isObserver) {
      this.sendConnectUser([], []);
    }
  }
  gotInitialCheckout = false;
  sentUserConnect = false;
  receivedUserIndex = false;
  queuedStateUpdates = /* @__PURE__ */ new Map();
  components = /* @__PURE__ */ new Map();
  states = /* @__PURE__ */ new Map();
  disposed = false;
  isObserver;
  sendConnectUser(components, states) {
    if (this.sentUserConnect) {
      return;
    }
    this.sentUserConnect = true;
    this.send({
      type: "connectUser",
      token: this.token,
      observer: this.isObserver,
      components: this.isObserver ? [] : components,
      states: this.isObserver ? [] : states
    });
  }
  setUserComponents(components, changedStates) {
    if (this.disposed) {
      throw new Error("DeltaNetClientWebsocketV01Adapter is disposed");
    }
    const messageComponents = [];
    for (const [componentId, value] of components) {
      messageComponents.push([componentId, value]);
      this.components.set(componentId, value);
    }
    const messageStates = [];
    for (const [stateId, value] of changedStates) {
      const currentState = this.states.get(stateId);
      if (currentState && areUint8ArraysEqual(currentState, value)) {
        continue;
      }
      this.states.set(stateId, value);
      messageStates.push([stateId, value]);
    }
    if (!this.sentUserConnect) {
      this.sendConnectUser(messageComponents, messageStates);
      return;
    }
    if (this.isObserver) {
      return;
    }
    if (this.receivedUserIndex) {
      if (messageComponents.length > 0 || messageStates.length > 0) {
        const setUserComponents = {
          type: "setUserComponents",
          components: messageComponents,
          states: messageStates
        };
        this.send(setUserComponents);
      }
    } else {
      for (const [stateId, value] of messageStates) {
        this.queuedStateUpdates.set(stateId, value);
      }
    }
  }
  send(message) {
    const writer = new BufferWriter(256);
    encodeClientMessage(message, writer);
    this.websocket.send(writer.getBuffer());
  }
  sendCustomMessage(customType, contents) {
    if (this.disposed) {
      return;
    }
    const customMessage = {
      type: "clientCustom",
      customType,
      contents
    };
    this.send(customMessage);
  }
  receiveMessage(event) {
    if (this.disposed) {
      return;
    }
    const buffer = new Uint8Array(event.data);
    const now = Date.now();
    this.internalOptions.receivedBytes(buffer.byteLength, now);
    const reader = new BufferReader(buffer);
    const messages = decodeServerMessages(reader, {
      ignoreData: this.options.ignoreData
    });
    for (const message of messages) {
      this.applyMessage(message, now);
    }
  }
  applyMessage(message, now) {
    switch (message.type) {
      case "error":
        console.error("Error from server", message);
        this.internalOptions.onError(message.errorType, message.message, message.retryable);
        break;
      case "warning":
        console.warn("Warning from server", message);
        this.internalOptions.onWarning(message.message);
        break;
      case "initialCheckout":
        this.handleInitialCheckout(message, now);
        this.connectedCallback();
        break;
      case "tick":
        this.handleTick(message, now);
        break;
      case "userIndex":
        this.handleUserIndex(message);
        break;
      case "ping":
        this.handlePing(message);
        break;
      case "serverCustom":
        this.handleServerCustom(message);
        break;
      default:
        console.warn("unknown message type", message);
        break;
    }
  }
  handleUserIndex(message) {
    this.receivedUserIndex = true;
    this.options.onUserIndex({
      userIndex: message.index
    });
    this.sendQueuedUpdates();
  }
  sendQueuedUpdates() {
    if (this.queuedStateUpdates.size > 0) {
      const queuedStatesArray = [];
      for (const [stateId, value] of this.queuedStateUpdates) {
        queuedStatesArray.push([stateId, value]);
      }
      const setUserComponents = {
        type: "setUserComponents",
        components: Array.from(this.components.entries()),
        states: queuedStatesArray
      };
      this.send(setUserComponents);
      this.queuedStateUpdates.clear();
    }
  }
  handlePing(message) {
    this.send({
      type: "pong",
      pong: message.ping
    });
  }
  handleServerCustom(message) {
    var _a, _b;
    (_b = (_a = this.options).onServerCustom) == null ? void 0 : _b.call(_a, message.customType, message.contents);
  }
  didConnect() {
    return this.gotInitialCheckout;
  }
  handleInitialCheckout(message, now) {
    this.gotInitialCheckout = true;
    if (this.options.ignoreData) {
      return;
    }
    const components = /* @__PURE__ */ new Map();
    for (const { componentId, deltas, values } of message.components) {
      components.set(componentId, { values, deltas });
    }
    const allStates = /* @__PURE__ */ new Map();
    for (const { stateId, values } of message.states) {
      allStates.set(stateId, values);
    }
    this.internalOptions.receivedComponentBytes(
      lastInitialCheckoutDebugData.componentsByteLength,
      now
    );
    this.internalOptions.receivedStateBytes(lastInitialCheckoutDebugData.statesByteLength, now);
    this.options.onInitialCheckout({
      indicesCount: message.indicesCount,
      initialComponents: components,
      initialStates: allStates
    });
  }
  handleTick(message, now) {
    var _a;
    if (this.options.ignoreData) {
      return;
    }
    (_a = this.timeCallback) == null ? void 0 : _a.call(this, message.serverTime);
    const components = /* @__PURE__ */ new Map();
    for (const { componentId, deltaDeltas } of message.componentDeltaDeltas) {
      components.set(componentId, deltaDeltas);
    }
    const stateChanges = /* @__PURE__ */ new Map();
    for (const stateChange of message.states) {
      const updatedStates = /* @__PURE__ */ new Map();
      for (const [index, value] of stateChange.updatedStates) {
        updatedStates.set(index, value);
      }
      stateChanges.set(stateChange.stateId, updatedStates);
    }
    this.internalOptions.receivedComponentBytes(lastTickDebugData.componentsByteLength, now);
    this.internalOptions.receivedStateBytes(lastTickDebugData.statesByteLength, now);
    this.options.onTick({
      unoccupying: message.removedIndices,
      indicesCount: message.indicesCount,
      componentDeltaDeltas: components,
      stateChanges
    });
  }
  dispose() {
    this.disposed = true;
  }
};

// src/DeltaNetClientWebsocket.ts
var startingBackoffTimeMilliseconds = 100;
var maximumBackoffTimeMilliseconds = 1e4;
var maximumWebsocketConnectionTimeout = 5e3;
var DeltaNetClientWebsocketStatus = /* @__PURE__ */ ((DeltaNetClientWebsocketStatus2) => {
  DeltaNetClientWebsocketStatus2[DeltaNetClientWebsocketStatus2["Connecting"] = 0] = "Connecting";
  DeltaNetClientWebsocketStatus2[DeltaNetClientWebsocketStatus2["ConnectionOpen"] = 1] = "ConnectionOpen";
  DeltaNetClientWebsocketStatus2[DeltaNetClientWebsocketStatus2["Connected"] = 2] = "Connected";
  DeltaNetClientWebsocketStatus2[DeltaNetClientWebsocketStatus2["Reconnecting"] = 3] = "Reconnecting";
  DeltaNetClientWebsocketStatus2[DeltaNetClientWebsocketStatus2["Disconnected"] = 4] = "Disconnected";
  return DeltaNetClientWebsocketStatus2;
})(DeltaNetClientWebsocketStatus || {});
function DeltaNetClientWebsocketStatusToString(status) {
  switch (status) {
    case 0 /* Connecting */:
      return "Connecting...";
    case 1 /* ConnectionOpen */:
      return "Connection Open";
    case 2 /* Connected */:
      return "Connected";
    case 3 /* Reconnecting */:
      return "Reconnecting...";
    case 4 /* Disconnected */:
      return "Disconnected";
    default:
      return "Unknown";
  }
}
function updateLastSecondArray(records, size, time) {
  let sizeChange = size;
  const oneSecondAgo = time - 1e3;
  records.push([time, size]);
  let i;
  for (i = 0; i < records.length; i++) {
    if (records[i][0] < oneSecondAgo) {
      sizeChange -= records[i][1];
    } else {
      break;
    }
  }
  records.splice(0, i);
  return sizeChange;
}
var DeltaNetClientWebsocket = class {
  constructor(url, websocketFactory, token, options, timeCallback, statusUpdateCallback) {
    this.url = url;
    this.websocketFactory = websocketFactory;
    this.token = token;
    this.options = options;
    this.timeCallback = timeCallback;
    this.statusUpdateCallback = statusUpdateCallback;
    this.setStatus(0 /* Connecting */);
    this.startWebSocketConnectionAttempt();
  }
  websocket = null;
  websocketAdapter = null;
  stopped = false;
  backoffTime = startingBackoffTimeMilliseconds;
  status = 0 /* Connecting */;
  bandwidthPerSecond = 0;
  lastSecondMessageSizes = [];
  // Timestamp in ms, size in bytes
  componentBytesPerSecond = 0;
  lastSecondComponentBufferSizes = [];
  // Timestamp in ms, size in bytes
  stateBytesPerSecond = 0;
  lastSecondStateBufferSizes = [];
  // Timestamp in ms, size in bytes
  static createWebSocket(url) {
    return new WebSocket(url, [deltaNetProtocolSubProtocol_v0_1]);
  }
  setStatus(status) {
    if (this.status !== status) {
      this.status = status;
      if (this.statusUpdateCallback) {
        this.statusUpdateCallback(status);
      }
    }
  }
  getStatus() {
    return this.status;
  }
  async createWebsocketWithTimeout(timeout) {
    return new Promise((resolve, reject) => {
      const websocket = this.websocketFactory(this.url);
      const timeoutId = setTimeout(() => {
        reject(new Error("websocket connection timed out"));
        websocket.close();
      }, timeout);
      websocket.binaryType = "arraybuffer";
      websocket.addEventListener("open", () => {
        clearTimeout(timeoutId);
        this.websocket = websocket;
        const websocketAdapter = new DeltaNetClientWebsocketV01Adapter(
          websocket,
          () => {
            this.backoffTime = startingBackoffTimeMilliseconds;
            this.setStatus(2 /* Connected */);
          },
          this.options,
          this.token,
          {
            receivedBytes: (bytes, now) => {
              this.bandwidthPerSecond += updateLastSecondArray(
                this.lastSecondMessageSizes,
                bytes,
                now
              );
            },
            receivedComponentBytes: (bytes, now) => {
              this.componentBytesPerSecond += updateLastSecondArray(
                this.lastSecondComponentBufferSizes,
                bytes,
                now
              );
            },
            receivedStateBytes: (bytes, now) => {
              this.stateBytesPerSecond += updateLastSecondArray(
                this.lastSecondStateBufferSizes,
                bytes,
                now
              );
            },
            onError: (errorType, errorMessage, retryable) => {
              var _a, _b;
              this.options.onError(errorType, errorMessage, retryable);
              if (this.websocket === websocket) {
                (_a = this.websocket) == null ? void 0 : _a.close();
                this.websocket = null;
                (_b = this.websocketAdapter) == null ? void 0 : _b.dispose();
                this.websocketAdapter = null;
                onWebsocketClose(retryable);
              }
            },
            onWarning: (warning) => {
              this.options.onWarning(warning);
            }
          },
          this.timeCallback
        );
        this.websocketAdapter = websocketAdapter;
        websocket.addEventListener("message", (event) => {
          if (websocket !== this.websocket) {
            console.log("Ignoring websocket message event because it is no longer current");
            websocket.close();
            return;
          }
          if (this.stopped) {
            console.warn("Ignoring websocket message event because the client is stopped");
            return;
          }
          websocketAdapter.receiveMessage(event);
        });
        const onWebsocketClose = async (retryable = true) => {
          let didConnect = false;
          if (this.websocketAdapter) {
            didConnect = this.websocketAdapter.didConnect();
          }
          if (this.stopped) {
            this.setStatus(4 /* Disconnected */);
            return;
          }
          if (retryable) {
            if (!didConnect) {
              await this.waitBackoffTime();
            }
            this.setStatus(3 /* Reconnecting */);
            this.startWebSocketConnectionAttempt();
          } else {
            this.setStatus(4 /* Disconnected */);
          }
        };
        websocket.addEventListener("close", () => {
          var _a;
          if (websocket !== this.websocket) {
            console.warn("Ignoring websocket close event because it is no longer current");
            return;
          }
          this.websocket = null;
          (_a = this.websocketAdapter) == null ? void 0 : _a.dispose();
          this.websocketAdapter = null;
          onWebsocketClose();
        });
        websocket.addEventListener("error", (e) => {
          var _a;
          if (websocket !== this.websocket) {
            console.log("Ignoring websocket error event because it is no longer current");
            return;
          }
          console.error("DeltaNetClientWebsocket error", e);
          this.websocket = null;
          (_a = this.websocketAdapter) == null ? void 0 : _a.dispose();
          this.websocketAdapter = null;
          onWebsocketClose();
        });
        this.setStatus(1 /* ConnectionOpen */);
        resolve(websocket);
      });
      websocket.addEventListener("error", (e) => {
        clearTimeout(timeoutId);
        reject(e);
      });
    });
  }
  async waitBackoffTime() {
    console.warn(`Websocket connection to '${this.url}' failed: retrying in ${this.backoffTime}ms`);
    await new Promise((resolve) => setTimeout(resolve, this.backoffTime));
    this.backoffTime = Math.min(
      // Introduce a small amount of randomness to prevent clients from retrying in lockstep
      this.backoffTime * (1.5 + Math.random() * 0.5),
      maximumBackoffTimeMilliseconds
    );
  }
  async startWebSocketConnectionAttempt() {
    if (this.stopped) {
      return;
    }
    while (true) {
      if (this.stopped) {
        return;
      }
      try {
        await this.createWebsocketWithTimeout(maximumWebsocketConnectionTimeout);
        break;
      } catch (e) {
        console.error("Websocket connection failed", e);
        this.setStatus(3 /* Reconnecting */);
        await this.waitBackoffTime();
      }
    }
  }
  stop() {
    var _a;
    this.stopped = true;
    if (this.websocket !== null) {
      this.websocket.close();
      this.websocket = null;
    }
    (_a = this.websocketAdapter) == null ? void 0 : _a.dispose();
    this.websocketAdapter = null;
  }
  setUserComponents(components, changedStates) {
    if (this.websocketAdapter) {
      this.websocketAdapter.setUserComponents(components, changedStates);
    }
  }
  sendCustomMessage(customType, contents) {
    if (this.websocketAdapter) {
      this.websocketAdapter.sendCustomMessage(customType, contents);
    }
  }
};
export {
  DeltaNetClientState,
  DeltaNetClientWebsocket,
  DeltaNetClientWebsocketStatus,
  DeltaNetClientWebsocketStatusToString
};
//# sourceMappingURL=index.js.map
