{
  "version": 3,
  "sources": ["../src/DeltaNetServer.ts", "../src/ComponentCollection.ts", "../src/createDeltaNetServerConnectionForWebsocket.ts", "../src/DeltaNetV01Connection.ts", "../src/StateCollection.ts"],
  "sourcesContent": ["import {\n  BufferWriter,\n  DeltaNetV01ComponentTick,\n  DeltaNetV01InitialCheckoutComponent,\n  DeltaNetV01InitialCheckoutMessage,\n  DeltaNetV01InitialCheckoutState,\n  DeltaNetV01PingMessage,\n  DeltaNetV01ServerErrorType,\n  DeltaNetV01StateUpdates,\n  DeltaNetV01Tick,\n  encodeInitialCheckout,\n  encodePing,\n  encodeTick,\n  encodeServerMessage,\n} from \"@mml-io/delta-net-protocol\";\n\nimport { ComponentCollection } from \"./ComponentCollection\";\nimport {\n  createDeltaNetServerConnectionForWebsocket,\n  SupportedWebsocketSubProtocolsPreferenceOrder,\n} from \"./createDeltaNetServerConnectionForWebsocket\";\nimport { DeltaNetV01Connection } from \"./DeltaNetV01Connection\";\nimport { StateCollection } from \"./StateCollection\";\n\nexport type onJoinerOptions = {\n  deltaNetV01Connection: DeltaNetV01Connection;\n  components: Array<[number, bigint]>;\n  states: Array<[number, Uint8Array]>;\n  token: string;\n  internalConnectionId: number;\n};\n\nexport type onComponentsUpdateOptions = {\n  deltaNetV01Connection: DeltaNetV01Connection;\n  internalConnectionId: number;\n  components: Array<[number, bigint]>;\n};\n\nexport type onStatesUpdateOptions = {\n  deltaNetV01Connection: DeltaNetV01Connection;\n  internalConnectionId: number;\n  states: Array<[number, Uint8Array]>;\n};\n\nexport type onLeaveOptions = {\n  deltaNetV01Connection: DeltaNetV01Connection;\n  internalConnectionId: number;\n  components: Array<[number, number]>;\n  states: Array<[number, Uint8Array]>;\n};\n\nexport type onCustomMessageOptions = {\n  deltaNetV01Connection: DeltaNetV01Connection;\n  internalConnectionId: number;\n  customType: number;\n  contents: string;\n};\n\nexport class DeltaNetServerError extends Error {\n  constructor(\n    public errorType: DeltaNetV01ServerErrorType,\n    message: string,\n    public retryable: boolean,\n  ) {\n    super(message);\n  }\n}\n\nexport type DeltaNetServerOptions = {\n  onJoiner?: (\n    opts: onJoinerOptions,\n  ) =>\n    | true\n    | void\n    | Error\n    | DeltaNetServerError\n    | { success: true; stateOverrides?: Array<[number, Uint8Array]> }\n    | Promise<\n        | true\n        | void\n        | Error\n        | DeltaNetServerError\n        | { success: true; stateOverrides?: Array<[number, Uint8Array]> }\n      >;\n  onComponentsUpdate?: (\n    opts: onComponentsUpdateOptions,\n  ) => true | void | Error | DeltaNetServerError;\n  onStatesUpdate?: (\n    opts: onStatesUpdateOptions,\n  ) =>\n    | true\n    | void\n    | Error\n    | DeltaNetServerError\n    | { success: true; stateOverrides?: Array<[number, Uint8Array]> }\n    | Promise<\n        | true\n        | void\n        | Error\n        | DeltaNetServerError\n        | { success: true; stateOverrides?: Array<[number, Uint8Array]> }\n      >;\n  onLeave?: (opts: onLeaveOptions) => void;\n  onCustomMessage?: (opts: onCustomMessageOptions) => void;\n  // If provided, the server will create a state for each user that contains their connection id\n  serverConnectionIdStateId?: number;\n  // Maximum size in bytes for individual state values (default: 1MB)\n  maxStateValueSize?: number;\n  // Maximum total size in bytes for a single message (default: 10MB)\n  maxMessageSize?: number;\n};\n\nexport class DeltaNetServer {\n  private currentConnectionId = 1;\n\n  private nextIndex = 0;\n\n  private preTickData = {\n    // This is state that will be flushed to clients in the next tick, but messages handled before the tick could change it\n    unoccupyingIndices: new Set<number>(),\n    newJoinerConnections: new Set<DeltaNetV01Connection>(),\n    // Allows for arbitrary processes to be run that can imitate a new joiner connection (currently used for legacy adapter)\n    newJoinerCallbacks: new Set<\n      (index: number) => { id: number; afterAddCallback?: () => void } | null\n    >(),\n    componentsUpdated: 0,\n  };\n\n  private connectionIdToComponentIndex = new Map<number, number>();\n  private componentIndexToConnectionId = new Map<number, number>();\n  private connectionIdToDeltaNetServerConnection = new Map<number, DeltaNetV01Connection>();\n\n  private allDeltaNetV01Connections = new Set<DeltaNetV01Connection>();\n  private authenticatedDeltaNetV01Connections = new Set<DeltaNetV01Connection>();\n  private observerConnections = new Set<DeltaNetV01Connection>(); // Track observer connections separately\n  private webSocketToDeltaNetServerConnection = new Map<WebSocket, DeltaNetV01Connection>();\n\n  private components = new Map<number, ComponentCollection>();\n  private states = new Map<number, StateCollection>();\n\n  private documentEffectiveStartTime = Date.now();\n  private pingCounter = 1;\n\n  private disposed = false;\n\n  private maxStateValueSize: number;\n  private maxMessageSize: number;\n\n  constructor(private opts: DeltaNetServerOptions = {}) {\n    if (opts.serverConnectionIdStateId !== undefined) {\n      this.states.set(opts.serverConnectionIdStateId, new StateCollection());\n    }\n\n    // Set default limits\n    this.maxStateValueSize = opts.maxStateValueSize ?? 1024 * 1024; // 1MB default\n    this.maxMessageSize = opts.maxMessageSize ?? 10 * 1024 * 1024; // 10MB default\n  }\n\n  public static handleWebsocketSubprotocol(protocols: Set<string> | Array<string>): string | false {\n    const protocolsSet = new Set(protocols);\n    // Find highest priority (first in the array) protocol that is supported\n    for (const protocol of SupportedWebsocketSubProtocolsPreferenceOrder) {\n      if (protocolsSet.has(protocol)) {\n        return protocol;\n      }\n    }\n    return false;\n  }\n\n  public addWebSocket(webSocket: WebSocket) {\n    if (this.disposed) {\n      throw new Error(\"This DeltaNetServer has been disposed\");\n    }\n\n    const deltaNetV01Connection = createDeltaNetServerConnectionForWebsocket(webSocket, this);\n    if (deltaNetV01Connection === null) {\n      // Error is handled in createDeltaNetServerConnectionForWebsocket\n      return;\n    }\n\n    this.allDeltaNetV01Connections.add(deltaNetV01Connection);\n    this.webSocketToDeltaNetServerConnection.set(\n      deltaNetV01Connection.webSocket,\n      deltaNetV01Connection,\n    );\n  }\n\n  public removeWebSocket(webSocket: WebSocket) {\n    // Allow removal even when disposed to ensure cleanup\n    const deltaNetV01Connection = this.webSocketToDeltaNetServerConnection.get(webSocket);\n    if (deltaNetV01Connection === undefined) {\n      // Connection might have already been removed, which is fine\n      return;\n    }\n    if (!this.allDeltaNetV01Connections.has(deltaNetV01Connection)) {\n      // Connection might have already been cleaned up, which is fine\n      return;\n    }\n\n    // Dispose the connection (this will cancel any pending validations)\n    deltaNetV01Connection.dispose();\n\n    // Call onLeave callback if provided and connection has an ID (but not if disposed)\n    if (!this.disposed && this.opts.onLeave) {\n      const internalConnectionId = deltaNetV01Connection.internalConnectionId;\n      const index = this.connectionIdToComponentIndex.get(internalConnectionId);\n\n      if (index !== undefined) {\n        // Gather current component and state data for the leaving user\n        const components: Array<[number, number]> = [];\n        for (const [componentId, collection] of this.components) {\n          const value = collection.getTargetValue(index);\n          if (value !== 0n) {\n            components.push([componentId, Number(value)]);\n          }\n        }\n\n        const states: Array<[number, Uint8Array]> = [];\n        for (const [stateId, collection] of this.states) {\n          const value = collection.values[index];\n          if (value !== undefined && value.length > 0) {\n            states.push([stateId, value]);\n          }\n        }\n\n        try {\n          this.opts.onLeave({\n            deltaNetV01Connection,\n            internalConnectionId,\n            components,\n            states,\n          });\n        } catch (error) {\n          console.warn(\"Error in onLeave callback:\", error);\n        }\n      }\n    }\n\n    const internalConnectionId = deltaNetV01Connection.internalConnectionId;\n    this.connectionIdToDeltaNetServerConnection.delete(internalConnectionId);\n    if (this.preTickData.newJoinerConnections.has(deltaNetV01Connection)) {\n      // This connection is still pending, so we need to remove it from the pending joiner list\n      this.preTickData.newJoinerConnections.delete(deltaNetV01Connection);\n    } else {\n      // This connection is already authenticated (has an index assigned), so we need to clear data for it\n      const index = this.connectionIdToComponentIndex.get(internalConnectionId);\n      if (index !== undefined) {\n        this.clearInternalConnectionId(internalConnectionId);\n      }\n      // If index is undefined, this connection was never fully authenticated and has no data to clear\n    }\n    this.authenticatedDeltaNetV01Connections.delete(deltaNetV01Connection);\n    this.observerConnections.delete(deltaNetV01Connection); // Remove from observers if present\n    this.allDeltaNetV01Connections.delete(deltaNetV01Connection);\n    this.webSocketToDeltaNetServerConnection.delete(deltaNetV01Connection.webSocket);\n  }\n\n  public hasWebSocket(webSocket: WebSocket): boolean {\n    return this.webSocketToDeltaNetServerConnection.has(webSocket);\n  }\n\n  public dangerouslyGetConnectionsToComponentIndex(): Map<number, number> {\n    return this.connectionIdToComponentIndex;\n  }\n\n  public dangerouslyAddNewJoinerCallback(\n    callback: (index: number) => { id: number; afterAddCallback?: () => void } | null,\n  ): void {\n    this.preTickData.newJoinerCallbacks.add(callback);\n  }\n\n  private disconnectWithError(\n    deltaNetV01Connection: DeltaNetV01Connection,\n    error: Error,\n    errorType: DeltaNetV01ServerErrorType,\n    retryable: boolean = true,\n  ): void {\n    try {\n      deltaNetV01Connection.sendMessage({\n        type: \"error\",\n        errorType,\n        message: error.message,\n        retryable,\n      });\n    } catch (sendError) {\n      // If sending the error message fails, just log it and proceed with disconnection\n      console.warn(\"Failed to send error message to client:\", sendError);\n    }\n\n    try {\n      deltaNetV01Connection.webSocket.close(1008, error.message);\n    } catch (closeError) {\n      // If closing the connection fails, just log it\n      console.warn(\"Failed to close websocket connection:\", closeError);\n    }\n\n    // Immediately clean up internal data structures to prevent memory leaks\n    // This ensures cleanup happens even if the WebSocket close event doesn't fire\n    try {\n      this.removeWebSocket(deltaNetV01Connection.webSocket);\n    } catch (cleanupError) {\n      // If the connection was already removed or doesn't exist, that's fine\n      console.warn(\"Failed to clean up connection state:\", cleanupError);\n    }\n  }\n\n  public getComponentValue(componentId: number, componentIndex: number): number | null {\n    const componentCollection = this.components.get(componentId);\n    if (componentCollection === undefined) {\n      return null;\n    }\n    return Number(componentCollection.getTargetValue(componentIndex));\n  }\n\n  public getNextConnectionId(): number {\n    return this.currentConnectionId++;\n  }\n\n  public getMaxMessageSize(): number {\n    return this.maxMessageSize;\n  }\n\n  public validateJoiner(\n    deltaNetV01Connection: DeltaNetV01Connection,\n    token: string,\n    components: Array<[number, bigint]>,\n    states: Array<[number, Uint8Array]>,\n  ):\n    | Promise<{ success: true } | { success: false; error: string }>\n    | { success: true }\n    | { success: false; error: string } {\n    if (this.disposed) {\n      return { success: false, error: \"This DeltaNetServer has been disposed\" };\n    }\n\n    // Check individual state value sizes\n    for (const [stateId, stateValue] of states) {\n      if (stateValue.length > this.maxStateValueSize) {\n        return {\n          success: false,\n          error: `State value for state ${stateId} has size ${stateValue.length} bytes which exceeds maximum allowed size of ${this.maxStateValueSize} bytes`,\n        };\n      }\n    }\n\n    function resultToReturn(\n      result:\n        | true\n        | void\n        | Error\n        | DeltaNetServerError\n        | { success: true; stateOverrides?: Array<[number, Uint8Array]> },\n    ):\n      | { success: true; stateOverrides?: Array<[number, Uint8Array]> }\n      | { success: false; error: string } {\n      if (result instanceof DeltaNetServerError) {\n        return { success: false, error: result.message };\n      }\n      if (result instanceof Error) {\n        return { success: false, error: result.message };\n      }\n      if (result === true || result === undefined) {\n        // If the callback returns true or undefined, treat it as success\n        return { success: true };\n      }\n      if (typeof result === \"object\" && result.success === true) {\n        // Return the object with potential state overrides\n        return result;\n      }\n      return { success: false, error: \"Joiner validation failed\" };\n    }\n\n    // Call onJoiner callback if provided (now potentially async)\n    if (this.opts.onJoiner) {\n      const rawResult = this.opts.onJoiner({\n        deltaNetV01Connection,\n        components,\n        states,\n        token,\n        internalConnectionId: deltaNetV01Connection.internalConnectionId,\n      });\n      if (rawResult instanceof Promise) {\n        return rawResult\n          .then((resolvedResult): { success: true } | { success: false; error: string } => {\n            return resultToReturn(resolvedResult);\n          })\n          .catch((error) => {\n            console.warn(\"Error in async onJoiner callback:\", error);\n            return resultToReturn(error);\n          });\n      } else {\n        return resultToReturn(rawResult);\n      }\n    }\n\n    return { success: true };\n  }\n\n  public addAuthenticatedConnection(deltaNetV01Connection: DeltaNetV01Connection): void {\n    if (deltaNetV01Connection.internalConnectionId === null) {\n      throw new Error(\"Connection ID must be set before adding to authenticated connections\");\n    }\n\n    this.connectionIdToDeltaNetServerConnection.set(\n      deltaNetV01Connection.internalConnectionId,\n      deltaNetV01Connection,\n    );\n\n    if (deltaNetV01Connection.isObserver) {\n      // Observers don't get indices but still need to go through the newJoiner flow to receive initialCheckout\n      this.observerConnections.add(deltaNetV01Connection);\n      this.preTickData.newJoinerConnections.add(deltaNetV01Connection);\n    } else {\n      // Regular users get added to new joiner queue for index assignment\n      this.preTickData.newJoinerConnections.add(deltaNetV01Connection);\n    }\n  }\n\n  public validateAndApplyStateUpdate(\n    deltaNetV01Connection: DeltaNetV01Connection,\n    internalConnectionId: number,\n    stateId: number,\n    stateValue: Uint8Array,\n  ):\n    | Promise<true | void | Error | DeltaNetServerError>\n    | true\n    | void\n    | Error\n    | DeltaNetServerError {\n    if (this.disposed) {\n      return new Error(\"This DeltaNetServer has been disposed\");\n    }\n\n    // Check state value size limit\n    if (stateValue.length > this.maxStateValueSize) {\n      return new DeltaNetServerError(\n        \"USER_NETWORKING_UNKNOWN_ERROR\",\n        `State value for state ${stateId} has size ${stateValue.length} bytes which exceeds maximum allowed size of ${this.maxStateValueSize} bytes`,\n        false,\n      );\n    }\n\n    // Observers cannot send state updates\n    if (deltaNetV01Connection.isObserver) {\n      return new DeltaNetServerError(\n        \"OBSERVER_CANNOT_SEND_STATE_UPDATES\",\n        \"Observers cannot send state updates\",\n        false,\n      );\n    }\n\n    // Call onStatesUpdate callback if provided\n    if (this.opts.onStatesUpdate) {\n      try {\n        const result = this.opts.onStatesUpdate({\n          deltaNetV01Connection,\n          internalConnectionId,\n          states: [[stateId, stateValue]],\n        });\n\n        // If it's a Promise, return it for the connection to handle\n        if (result instanceof Promise) {\n          return result\n            .then((asyncResult) => {\n              // Check if connection still exists before applying state update\n              if (!this.connectionIdToDeltaNetServerConnection.has(internalConnectionId)) {\n                // Connection was removed while validation was pending - ignore the result\n                return;\n              }\n              if (asyncResult instanceof DeltaNetServerError || asyncResult instanceof Error) {\n                return asyncResult;\n              }\n\n              if (asyncResult === true || asyncResult === undefined) {\n                this.applyStateUpdates(deltaNetV01Connection, internalConnectionId, [\n                  [stateId, stateValue],\n                ]);\n                return true;\n              }\n\n              // If asyncResult is an object with success: true, apply the state overrides\n              if (asyncResult.success) {\n                if (asyncResult.stateOverrides) {\n                  this.applyStateUpdates(\n                    deltaNetV01Connection,\n                    internalConnectionId,\n                    asyncResult.stateOverrides,\n                  );\n                }\n                return true;\n              } else {\n                return new DeltaNetServerError(\n                  \"USER_NETWORKING_UNKNOWN_ERROR\",\n                  \"State validation failed\",\n                  false,\n                );\n              }\n            })\n            .catch((error) => {\n              // Handle async callback errors\n              console.warn(\"Error in async onStatesUpdate callback:\", error);\n              if (error instanceof DeltaNetServerError) {\n                return error;\n              }\n              if (error instanceof Error) {\n                return error;\n              }\n              return new Error(\"State validation failed\");\n            });\n        } else {\n          // Synchronous validation\n          if (result instanceof DeltaNetServerError || result instanceof Error) {\n            return result;\n          }\n\n          if (result === true || result === undefined) {\n            this.applyStateUpdates(deltaNetV01Connection, internalConnectionId, [\n              [stateId, stateValue],\n            ]);\n            return true;\n          }\n\n          // If result is an object with success: true, apply the state overrides\n          if (result.success) {\n            if (result.stateOverrides) {\n              this.applyStateUpdates(\n                deltaNetV01Connection,\n                internalConnectionId,\n                result.stateOverrides,\n              );\n            }\n            return true;\n          } else {\n            return new DeltaNetServerError(\n              \"USER_NETWORKING_UNKNOWN_ERROR\",\n              \"State validation failed\",\n              false,\n            );\n          }\n        }\n      } catch (error) {\n        console.warn(\"Error in onStatesUpdate callback:\", error);\n        if (error instanceof DeltaNetServerError) {\n          return error;\n        }\n        if (error instanceof Error) {\n          return error;\n        }\n        return new Error(\"State validation failed\");\n      }\n    } else {\n      // No validation callback, apply immediately\n      this.applyStateUpdates(deltaNetV01Connection, internalConnectionId, [[stateId, stateValue]]);\n      return true;\n    }\n  }\n\n  public clearInternalConnectionId(internalConnectionId: number) {\n    const index = this.connectionIdToComponentIndex.get(internalConnectionId);\n    if (index === undefined) {\n      throw new Error(\"Index for removing user is undefined\");\n    }\n    // Clear all the component values for this index\n    for (const [, collection] of this.components) {\n      collection.setValue(index, 0n);\n    }\n    for (const [, collection] of this.states) {\n      collection.setValue(index, null);\n    }\n\n    this.preTickData.unoccupyingIndices.add(index);\n  }\n\n  private sendPings() {\n    const ping = this.pingCounter++;\n    if (this.pingCounter > 1000) {\n      this.pingCounter = 1;\n    }\n    const v01PingMessage: DeltaNetV01PingMessage = {\n      type: \"ping\",\n      ping,\n    };\n    const writer = new BufferWriter(8);\n    encodePing(v01PingMessage, writer);\n    const v01Encoded = writer.getBuffer();\n    this.allDeltaNetV01Connections.forEach((deltaNetV01Connection) => {\n      deltaNetV01Connection.sendEncodedBytes(v01Encoded);\n    });\n  }\n\n  public tick(): {\n    removedIds: Set<number>;\n    addedIds: Set<number>;\n  } {\n    if (this.disposed) {\n      return { removedIds: new Set(), addedIds: new Set() }; // Silently ignore ticks after disposal\n    }\n\n    this.preTickData.componentsUpdated = 0;\n\n    const removedIds: Set<number> = new Set();\n    const addedIds: Set<number> = new Set();\n\n    // Determine the indices of the removed connections. Send the original indices to the clients so they can be removed.\n    const sortedUnoccupyingIndices = Array.from(this.preTickData.unoccupyingIndices);\n    sortedUnoccupyingIndices.sort((a, b) => a - b);\n\n    // Apply the unoccupying indices to the component and state collections\n    for (const componentCollection of this.components.values()) {\n      componentCollection.removeIndices(sortedUnoccupyingIndices);\n    }\n    for (const stateCollection of this.states.values()) {\n      stateCollection.removeIndices(sortedUnoccupyingIndices);\n    }\n\n    for (const index of sortedUnoccupyingIndices) {\n      const connectionId = this.componentIndexToConnectionId.get(index);\n      if (connectionId === undefined) {\n        throw new Error(\"Connection id not found for index \" + index);\n      }\n      removedIds.add(connectionId);\n      this.connectionIdToComponentIndex.delete(connectionId);\n      this.componentIndexToConnectionId.delete(index);\n    }\n\n    let writeIndex = 0;\n    let skipIndex = 0;\n    for (let i = 0; i < this.nextIndex; i++) {\n      // Fix the indices of the maps to connectionId\n      const connectionId = this.componentIndexToConnectionId.get(i);\n\n      // Skip indices that should be removed\n      if (\n        skipIndex < sortedUnoccupyingIndices.length &&\n        i === sortedUnoccupyingIndices[skipIndex]\n      ) {\n        skipIndex++;\n        continue;\n      }\n\n      // Shift values to the left (in-place)\n      if (writeIndex !== i) {\n        if (connectionId === undefined) {\n          throw new Error(\"Connection id not found for index \" + i);\n        }\n        this.componentIndexToConnectionId.set(writeIndex, connectionId);\n        this.connectionIdToComponentIndex.set(connectionId, writeIndex);\n      }\n      writeIndex++;\n    }\n\n    // Now decrement the nextIndex to reflect the removed indices\n    this.nextIndex -= sortedUnoccupyingIndices.length;\n\n    // handle new joiners\n    for (const deltaNetV01Connection of this.preTickData.newJoinerConnections) {\n      const internalConnectionId = deltaNetV01Connection.internalConnectionId;\n\n      if (deltaNetV01Connection.isObserver) {\n        // Observers don't get indices assigned\n      } else {\n        // Regular participants get indices assigned\n        const index = this.nextIndex++;\n\n        this.connectionIdToComponentIndex.set(internalConnectionId, index);\n        this.componentIndexToConnectionId.set(index, internalConnectionId);\n        addedIds.add(internalConnectionId);\n\n        // Create new collections for any components or states that are not already present\n        for (const [componentId] of deltaNetV01Connection.components) {\n          if (!this.components.has(componentId)) {\n            this.components.set(componentId, new ComponentCollection());\n          }\n        }\n        for (const [stateId] of deltaNetV01Connection.states) {\n          if (!this.states.has(stateId)) {\n            this.states.set(stateId, new StateCollection());\n          }\n        }\n\n        for (const [componentId, collection] of this.components) {\n          const value = deltaNetV01Connection.components.get(componentId);\n          if (value === undefined) {\n            collection.setValue(index, 0n);\n          } else {\n            collection.setValue(index, BigInt(value));\n          }\n        }\n\n        for (const [stateId, collection] of this.states) {\n          const value = deltaNetV01Connection.states.get(stateId);\n          if (\n            this.opts.serverConnectionIdStateId !== undefined &&\n            stateId === this.opts.serverConnectionIdStateId\n          ) {\n            const writer = new BufferWriter(8);\n            writer.writeUVarint(internalConnectionId);\n            const buffer = writer.getBuffer();\n            collection.setValue(index, buffer);\n          } else {\n            if (value === undefined) {\n              collection.setValue(index, null);\n            } else {\n              collection.setValue(index, value);\n            }\n          }\n        }\n\n        deltaNetV01Connection.sendMessage({\n          type: \"userIndex\",\n          index,\n        });\n      }\n    }\n\n    for (const callback of this.preTickData.newJoinerCallbacks) {\n      const index = this.nextIndex++;\n      const result = callback(index);\n      if (result === null) {\n        // If the callback returns false, the index is not used and should be decremented\n        this.nextIndex--;\n      } else {\n        const { id, afterAddCallback } = result;\n        this.connectionIdToComponentIndex.set(id, index);\n        this.componentIndexToConnectionId.set(index, id);\n        addedIds.add(id);\n\n        if (this.opts.serverConnectionIdStateId !== undefined) {\n          const writer = new BufferWriter(8);\n          writer.writeUVarint(id);\n          const buffer = writer.getBuffer();\n          this.setUserState(index, this.opts.serverConnectionIdStateId, buffer);\n        }\n        if (afterAddCallback) {\n          afterAddCallback();\n        }\n      }\n    }\n\n    const componentDeltas: Array<DeltaNetV01ComponentTick> = [];\n    for (const [componentId, collection] of this.components) {\n      const { deltaDeltas } = collection.tick();\n      componentDeltas.push({ componentId, deltaDeltas });\n    }\n    const stateDeltas: Array<DeltaNetV01StateUpdates> = [];\n    for (const [stateId, collection] of this.states) {\n      const updatedStates: Array<[number, Uint8Array]> = collection.tick();\n      if (updatedStates.length === 0) {\n        continue;\n      }\n      stateDeltas.push({\n        stateId,\n        updatedStates,\n      });\n    }\n\n    const tickMessage: DeltaNetV01Tick = {\n      type: \"tick\",\n      serverTime: this.getServerTime(),\n      removedIndices: sortedUnoccupyingIndices,\n      indicesCount: this.nextIndex,\n      componentDeltaDeltas: componentDeltas,\n      states: stateDeltas,\n    };\n    const writer = new BufferWriter(this.nextIndex * this.components.size + 128); // Try to avoid needing to resize\n    encodeTick(tickMessage, writer);\n    const v01EncodedComponentsChanged = writer.getBuffer();\n    this.authenticatedDeltaNetV01Connections.forEach((deltaNetV01Connection) => {\n      deltaNetV01Connection.sendEncodedBytes(v01EncodedComponentsChanged);\n    });\n\n    // Handle the initial checkout for new joiners\n\n    if (this.preTickData.newJoinerConnections.size > 0) {\n      const components: Array<DeltaNetV01InitialCheckoutComponent> = [];\n      for (const [componentId, collection] of this.components) {\n        components.push({\n          componentId,\n          values: collection.getCurrentValuesArray(),\n          deltas: collection.getPreviousEmittedDeltasArray(),\n        });\n      }\n\n      const states: Array<DeltaNetV01InitialCheckoutState> = [];\n      for (const [stateId, collection] of this.states) {\n        states.push({\n          stateId,\n          values: collection.values,\n        });\n      }\n\n      const initialCheckout = {\n        type: \"initialCheckout\",\n        components,\n        states,\n        indicesCount: this.nextIndex,\n        serverTime: this.getServerTime(),\n      } satisfies DeltaNetV01InitialCheckoutMessage;\n\n      const writer = new BufferWriter(this.nextIndex * this.components.size + 128); // Try to avoid needing to resize\n      encodeInitialCheckout(initialCheckout, writer);\n      const v01EncodedInitialCheckout = writer.getBuffer();\n\n      for (const deltaNetV01Connection of this.preTickData.newJoinerConnections) {\n        deltaNetV01Connection.sendEncodedBytes(v01EncodedInitialCheckout);\n      }\n    }\n\n    for (const deltaNetV01Connection of this.preTickData.newJoinerConnections) {\n      this.authenticatedDeltaNetV01Connections.add(deltaNetV01Connection);\n      deltaNetV01Connection.setAuthenticated();\n    }\n\n    this.preTickData.unoccupyingIndices.clear();\n    this.preTickData.newJoinerConnections.clear();\n    this.preTickData.newJoinerCallbacks.clear();\n\n    return {\n      removedIds,\n      addedIds,\n    };\n  }\n\n  public getServerTime(): number {\n    return Date.now() - this.documentEffectiveStartTime;\n  }\n\n  public setUserComponents(\n    deltaNetV01Connection: DeltaNetV01Connection,\n    internalConnectionId: number,\n    components: Array<[number, bigint]>,\n  ): { success: true } | { success: false; error: string } {\n    if (this.disposed) {\n      console.error(\"Cannot dispatch remote event after dispose\");\n      return { success: false, error: \"This DeltaNetServer has been disposed\" };\n    }\n\n    // Observers cannot send component updates\n    if (deltaNetV01Connection.isObserver) {\n      return { success: false, error: \"Observers cannot send component updates\" };\n    }\n\n    // Call onComponentsUpdate callback if provided\n    if (this.opts.onComponentsUpdate) {\n      try {\n        const result = this.opts.onComponentsUpdate({\n          deltaNetV01Connection,\n          internalConnectionId,\n          components,\n        });\n\n        if (result instanceof DeltaNetServerError) {\n          return { success: false, error: result.message };\n        }\n        if (result instanceof Error) {\n          return { success: false, error: result.message };\n        }\n      } catch (error) {\n        console.warn(\"Error in onComponentsUpdate callback:\", error);\n        if (error instanceof DeltaNetServerError) {\n          return { success: false, error: error.message };\n        }\n        if (error instanceof Error) {\n          return { success: false, error: error.message };\n        }\n        return { success: false, error: \"Component update failed\" };\n      }\n    }\n\n    // Apply component updates immediately (components don't have async validation)\n    this.applyComponentUpdates(deltaNetV01Connection, internalConnectionId, components);\n\n    return { success: true };\n  }\n\n  public setComponentValue(componentId: number, index: number, value: bigint): void {\n    this.preTickData.componentsUpdated++;\n    let collection = this.components.get(componentId);\n    if (!collection) {\n      collection = new ComponentCollection();\n      this.components.set(componentId, collection);\n    }\n    collection.setValue(index, value);\n  }\n\n  private applyComponentUpdates(\n    deltaNetV01Connection: DeltaNetV01Connection,\n    internalConnectionId: number,\n    components: Array<[number, bigint]>,\n  ): void {\n    if (this.preTickData.newJoinerConnections.has(deltaNetV01Connection)) {\n      for (const [componentId, componentValue] of components) {\n        deltaNetV01Connection.components.set(componentId, componentValue);\n      }\n      return;\n    }\n\n    const index = this.connectionIdToComponentIndex.get(internalConnectionId);\n    if (index === undefined) {\n      // Connection was likely removed - this is expected behavior\n      return;\n    }\n\n    for (const [componentId, componentValue] of components) {\n      this.setComponentValue(componentId, index, componentValue);\n    }\n  }\n\n  public overrideUserStates(\n    deltaNetV01Connection: DeltaNetV01Connection | null,\n    internalConnectionId: number,\n    states: Array<[number, Uint8Array]>,\n  ) {\n    this.applyStateUpdates(deltaNetV01Connection, internalConnectionId, states);\n  }\n\n  public setUserState(index: number, stateId: number, stateValue: Uint8Array) {\n    let collection = this.states.get(stateId);\n    if (!collection) {\n      collection = new StateCollection();\n      this.states.set(stateId, collection);\n    }\n    collection.setValue(index, stateValue);\n  }\n\n  private applyStateUpdates(\n    deltaNetV01Connection: DeltaNetV01Connection | null,\n    internalConnectionId: number,\n    states: Array<[number, Uint8Array]>,\n  ): void {\n    if (\n      deltaNetV01Connection !== null &&\n      this.preTickData.newJoinerConnections.has(deltaNetV01Connection)\n    ) {\n      for (const [stateId, stateValue] of states) {\n        deltaNetV01Connection.states.set(stateId, stateValue);\n      }\n      return;\n    }\n\n    const index = this.connectionIdToComponentIndex.get(internalConnectionId);\n    if (index === undefined) {\n      // Connection was likely removed while async validation was pending\n      // This is expected behavior and not an error\n      return;\n    }\n\n    for (const [stateId, stateValue] of states) {\n      this.setUserState(index, stateId, stateValue);\n    }\n  }\n\n  public handleCustomMessage(\n    deltaNetV01Connection: DeltaNetV01Connection,\n    internalConnectionId: number,\n    customType: number,\n    contents: string,\n  ): void {\n    if (this.disposed) {\n      return;\n    }\n\n    // Call custom message callback if provided\n    if (this.opts.onCustomMessage) {\n      try {\n        this.opts.onCustomMessage({\n          deltaNetV01Connection,\n          internalConnectionId,\n          customType,\n          contents,\n        });\n      } catch (error) {\n        console.warn(\"Error in onCustomMessage callback:\", error);\n      }\n    }\n  }\n\n  public broadcastCustomMessage(customType: number, contents: string): void {\n    if (this.disposed) {\n      return;\n    }\n\n    const writer = new BufferWriter(contents.length + 16);\n    const message = {\n      type: \"serverCustom\" as const,\n      customType,\n      contents,\n    };\n\n    const encodedMessage = encodeServerMessage(message, writer);\n    const messageBytes = encodedMessage.getBuffer();\n\n    // Broadcast to all authenticated connections\n    this.authenticatedDeltaNetV01Connections.forEach((connection) => {\n      try {\n        connection.sendEncodedBytes(messageBytes);\n      } catch (error) {\n        console.warn(\"Failed to send custom message to connection:\", error);\n      }\n    });\n  }\n\n  public dispose(): void {\n    this.disposed = true;\n\n    // Close all active connections\n    const connectionsToClose = Array.from(this.allDeltaNetV01Connections);\n    for (const connection of connectionsToClose) {\n      try {\n        connection.webSocket.close(1001, \"Server shutting down\");\n      } catch (error) {\n        console.warn(\"Failed to close connection during disposal:\", error);\n      }\n    }\n\n    // Clear all internal data structures\n    this.allDeltaNetV01Connections.clear();\n    this.authenticatedDeltaNetV01Connections.clear();\n    this.observerConnections.clear();\n    this.webSocketToDeltaNetServerConnection.clear();\n    this.connectionIdToDeltaNetServerConnection.clear();\n    this.connectionIdToComponentIndex.clear();\n    this.componentIndexToConnectionId.clear();\n    this.components.clear();\n    this.states.clear();\n    this.preTickData.newJoinerConnections.clear();\n    this.preTickData.unoccupyingIndices.clear();\n  }\n}\n", "export class ComponentCollection {\n  // Internal storage using bigint arrays for unlimited precision\n  private targetValues: bigint[];\n  private pendingDeltas: bigint[];\n  private previousEmittedDeltas: bigint[];\n  // Track the current observable value (what existing connections see)\n  private currentObservableValues: bigint[];\n\n  // Constants for int64 range\n  private static readonly MIN_INT64 = -9223372036854775808n;\n  private static readonly MAX_INT64 = 9223372036854775807n;\n\n  public constructor(initialLength: number = 128) {\n    this.targetValues = new Array(initialLength).fill(BigInt(0));\n    this.pendingDeltas = new Array(initialLength).fill(BigInt(0));\n    this.previousEmittedDeltas = new Array(initialLength).fill(BigInt(0));\n    this.currentObservableValues = new Array(initialLength).fill(BigInt(0));\n  }\n\n  public setLength(length: number): void {\n    if (length > this.targetValues.length) {\n      // Expand arrays\n      while (this.targetValues.length < length) {\n        this.targetValues.push(BigInt(0));\n        this.pendingDeltas.push(BigInt(0));\n        this.previousEmittedDeltas.push(BigInt(0));\n        this.currentObservableValues.push(BigInt(0));\n      }\n    } else if (length < this.targetValues.length) {\n      // Truncate arrays\n      this.targetValues = this.targetValues.slice(0, length);\n      this.pendingDeltas = this.pendingDeltas.slice(0, length);\n      this.previousEmittedDeltas = this.previousEmittedDeltas.slice(0, length);\n      this.currentObservableValues = this.currentObservableValues.slice(0, length);\n    }\n  }\n\n  public setValue(index: number, value: bigint): void {\n    if (index >= this.targetValues.length) {\n      // Work out which power of two would contain the index\n      const newLength = Math.pow(2, Math.ceil(Math.log2(index + 1)));\n      this.setLength(newLength);\n    }\n\n    // Clamp the target value to int64 range for consistency\n    const clampedValue = this.clampToInt64(value);\n\n    // Calculate the total delta needed to reach the target value\n    const currentValue = this.targetValues[index];\n    const totalDelta = clampedValue - currentValue;\n\n    // Add this delta to pending deltas\n    this.pendingDeltas[index] += totalDelta;\n\n    // Update target value\n    this.targetValues[index] = clampedValue;\n  }\n\n  private clampToInt64(value: bigint): bigint {\n    if (value > ComponentCollection.MAX_INT64) {\n      return ComponentCollection.MAX_INT64;\n    }\n    if (value < ComponentCollection.MIN_INT64) {\n      return ComponentCollection.MIN_INT64;\n    }\n    return value;\n  }\n\n  public tick(): { delta: BigInt64Array; deltaDeltas: BigInt64Array } {\n    const length = this.targetValues.length;\n    const delta = new BigInt64Array(length);\n    const deltaDeltas = new BigInt64Array(length);\n\n    for (let i = 0; i < length; i++) {\n      // Determine how much delta we can emit this tick (clamped to int64 range)\n      const pendingDelta = this.pendingDeltas[i];\n      const emittableDelta = this.clampToInt64(pendingDelta);\n\n      // Store the emitted delta\n      delta[i] = emittableDelta;\n\n      // Calculate delta delta (change in delta from previous tick)\n      // We need to be careful here to avoid overflow in BigInt64Array\n      const deltaDelta = emittableDelta - this.previousEmittedDeltas[i];\n      const clampedDeltaDelta = this.clampToInt64(deltaDelta);\n      deltaDeltas[i] = clampedDeltaDelta;\n\n      // Update previous emitted delta\n      this.previousEmittedDeltas[i] = emittableDelta;\n\n      // Update current observable value (what existing connections see)\n      // Clamp to int64 range to ensure consistency with serialization\n      this.currentObservableValues[i] = this.clampToInt64(\n        this.currentObservableValues[i] + emittableDelta,\n      );\n\n      // Reduce pending delta by what we emitted\n      this.pendingDeltas[i] -= emittableDelta;\n    }\n\n    return { delta, deltaDeltas };\n  }\n\n  public removeIndices(sortedUnoccupyingIndices: Array<number>) {\n    // If there are no indices to remove, return early\n    if (sortedUnoccupyingIndices.length === 0) {\n      return;\n    }\n\n    let writeIndex = 0;\n    let skipIndex = 0;\n\n    // Process each element in the array\n    for (let readIndex = 0; readIndex < this.targetValues.length; readIndex++) {\n      // Skip indices that should be removed\n      if (\n        skipIndex < sortedUnoccupyingIndices.length &&\n        readIndex === sortedUnoccupyingIndices[skipIndex]\n      ) {\n        skipIndex++;\n        continue;\n      }\n\n      // Shift values to the left (in-place)\n      if (writeIndex !== readIndex) {\n        this.targetValues[writeIndex] = this.targetValues[readIndex];\n        this.pendingDeltas[writeIndex] = this.pendingDeltas[readIndex];\n        this.previousEmittedDeltas[writeIndex] = this.previousEmittedDeltas[readIndex];\n        this.currentObservableValues[writeIndex] = this.currentObservableValues[readIndex];\n      }\n\n      writeIndex++;\n    }\n\n    // Zero out the remaining elements\n    for (let i = writeIndex; i < this.targetValues.length; i++) {\n      this.targetValues[i] = BigInt(0);\n      this.pendingDeltas[i] = BigInt(0);\n      this.previousEmittedDeltas[i] = BigInt(0);\n      this.currentObservableValues[i] = BigInt(0);\n    }\n  }\n\n  // Getter for current target values (for testing)\n  public getTargetValue(index: number): bigint {\n    return this.targetValues[index] || BigInt(0);\n  }\n\n  // Getter for pending deltas (for testing)\n  public getPendingDelta(index: number): bigint {\n    return this.pendingDeltas[index] || BigInt(0);\n  }\n\n  // Getter for length (for testing)\n  public get length(): number {\n    return this.targetValues.length;\n  }\n\n  // Get target values as BigInt64Array for serialization\n  public getCurrentValuesArray(): BigInt64Array {\n    const result = new BigInt64Array(this.targetValues.length);\n    for (let i = 0; i < this.targetValues.length; i++) {\n      // Clamp to int64 range for BigInt64Array compatibility\n      result[i] = this.currentObservableValues[i];\n    }\n    return result;\n  }\n\n  // Get previous emitted deltas as BigInt64Array for serialization\n  public getPreviousEmittedDeltasArray(): BigInt64Array {\n    const result = new BigInt64Array(this.previousEmittedDeltas.length);\n    for (let i = 0; i < this.previousEmittedDeltas.length; i++) {\n      result[i] = this.previousEmittedDeltas[i];\n    }\n    return result;\n  }\n}\n", "import {\n  deltaNetProtocolSubProtocol_v0_1,\n  DeltaNetV01ServerMessage,\n} from \"@mml-io/delta-net-protocol\";\n\nimport { DeltaNetServer } from \"./DeltaNetServer\";\nimport { DeltaNetV01Connection } from \"./DeltaNetV01Connection\";\n\n// First to last in order of preference\nexport const SupportedWebsocketSubProtocolsPreferenceOrder = [\n  deltaNetProtocolSubProtocol_v0_1,\n] as const;\n\nfunction IsRecognizedWebsocketSubProtocol(\n  protocol: string,\n): protocol is (typeof SupportedWebsocketSubProtocolsPreferenceOrder)[number] {\n  return SupportedWebsocketSubProtocolsPreferenceOrder.includes(protocol as any);\n}\n\nexport function createDeltaNetServerConnectionForWebsocket(\n  webSocket: WebSocket,\n  deltaNetServer: DeltaNetServer,\n): DeltaNetV01Connection | null {\n  if (!webSocket.protocol || !IsRecognizedWebsocketSubProtocol(webSocket.protocol)) {\n    const errorMessageString = `Unsupported websocket subprotocol: ${webSocket.protocol}`;\n    const errorMessage: Array<DeltaNetV01ServerMessage> = [\n      {\n        type: \"error\",\n        errorType: \"UNSUPPORTED_WEBSOCKET_SUBPROTOCOL\",\n        message: errorMessageString,\n        retryable: false,\n      },\n    ];\n    webSocket.send(JSON.stringify(errorMessage));\n    webSocket.close();\n    return null;\n  }\n\n  return new DeltaNetV01Connection(webSocket, deltaNetServer);\n}\n", "import {\n  DeltaNetV01ServerErrors,\n  BufferReader,\n  decodeClientMessages,\n  DeltaNetV01ClientMessage,\n  DeltaNetV01ServerErrorType,\n  DeltaNetV01ServerMessage,\n  encodeServerMessage,\n} from \"@mml-io/delta-net-protocol\";\n\nimport { DeltaNetServer, DeltaNetServerError } from \"./DeltaNetServer\";\n\nexport class DeltaNetV01Connection {\n  private websocketListener: (messageEvent: MessageEvent) => void;\n\n  public readonly internalConnectionId: number;\n  public isObserver: boolean = false; // Track observer mode\n\n  // Pending state for new joiners (before they're authenticated)\n  public components = new Map<number, bigint>();\n  public states = new Map<number, Uint8Array>();\n\n  // Track pending async state validations per state\n  private pendingStateValidations = new Map<\n    number,\n    { validationId: number; abortController: AbortController }\n  >();\n  private nextValidationId = 1;\n\n  // Track authentication state\n  private isAuthenticated = false;\n  private isAuthenticating = false;\n  private authenticationAbortController: AbortController | null = null;\n\n  public constructor(\n    public readonly webSocket: WebSocket,\n    public readonly deltaNetServer: DeltaNetServer,\n  ) {\n    // Get connection ID immediately upon creation\n    this.internalConnectionId = deltaNetServer.getNextConnectionId();\n\n    this.websocketListener = (messageEvent: MessageEvent) => {\n      const buffer = new Uint8Array(messageEvent.data as ArrayBuffer);\n\n      // Check message size before attempting to decode\n      const maxMessageSize = this.deltaNetServer.getMaxMessageSize();\n      if (buffer.length > maxMessageSize) {\n        this.disconnectWithError(\n          new Error(\n            `Message size ${buffer.length} bytes exceeds maximum allowed size of ${maxMessageSize} bytes`,\n          ),\n          DeltaNetV01ServerErrors.USER_NETWORKING_UNKNOWN_ERROR_TYPE,\n          false,\n        );\n        return;\n      }\n\n      try {\n        const messages = decodeClientMessages(new BufferReader(buffer));\n        for (const parsed of messages) {\n          this.handleClientMessage(parsed);\n        }\n      } catch (error) {\n        this.disconnectWithError(\n          new Error(\n            `Failed to decode client messages: ${error instanceof Error ? error.message : error}`,\n          ),\n          DeltaNetV01ServerErrors.USER_NETWORKING_UNKNOWN_ERROR_TYPE,\n          false,\n        );\n        return;\n      }\n    };\n    webSocket.addEventListener(\"message\", this.websocketListener);\n    this.deltaNetServer = deltaNetServer;\n  }\n\n  public sendMessage(message: DeltaNetV01ServerMessage) {\n    this.sendEncodedBytes(encodeServerMessage(message).getBuffer());\n  }\n\n  public sendEncodedBytes(bytes: Uint8Array) {\n    this.webSocket.send(bytes);\n  }\n\n  public dispose() {\n    this.webSocket.removeEventListener(\"message\", this.websocketListener);\n    // Cancel all pending validations\n    for (const [, validation] of this.pendingStateValidations) {\n      validation.abortController.abort();\n    }\n    this.pendingStateValidations.clear();\n\n    // Cancel pending authentication\n    if (this.authenticationAbortController) {\n      this.authenticationAbortController.abort();\n      this.authenticationAbortController = null;\n    }\n  }\n\n  public setAuthenticated() {\n    this.isAuthenticated = true;\n  }\n\n  private disconnectWithError(\n    error: Error,\n    errorType: DeltaNetV01ServerErrorType,\n    retryable: boolean = true,\n  ): void {\n    try {\n      this.sendMessage({\n        type: \"error\",\n        errorType,\n        message: error.message,\n        retryable,\n      });\n    } catch (sendError) {\n      console.warn(\"Failed to send error message to client:\", sendError);\n    }\n\n    try {\n      this.webSocket.close(1008, error.message);\n    } catch (closeError) {\n      console.warn(\"Failed to close websocket connection:\", closeError);\n    }\n  }\n\n  private async handleConnectUser(\n    token: string,\n    observer: boolean,\n    components: Array<[number, bigint]>,\n    states: Array<[number, Uint8Array]>,\n  ): Promise<void> {\n    // Reject if already authenticated or currently authenticating\n    if (this.isAuthenticated) {\n      this.disconnectWithError(\n        new Error(\"User is already authenticated\"),\n        DeltaNetV01ServerErrors.USER_ALREADY_AUTHENTICATED_ERROR_TYPE,\n        false,\n      );\n      return;\n    }\n\n    if (this.isAuthenticating) {\n      this.disconnectWithError(\n        new Error(\"Authentication already in progress\"),\n        DeltaNetV01ServerErrors.AUTHENTICATION_IN_PROGRESS_ERROR_TYPE,\n        false,\n      );\n      return;\n    }\n\n    this.isAuthenticating = true;\n    this.authenticationAbortController = new AbortController();\n\n    // Set observer mode\n    this.isObserver = observer;\n\n    // Store the pending data\n    this.components = new Map(components);\n    this.states = new Map(states);\n\n    let result:\n      | { success: boolean; error?: string; stateOverrides?: Array<[number, Uint8Array]> }\n      | DeltaNetServerError\n      | Error;\n    try {\n      const rawResult = this.deltaNetServer.validateJoiner(this, token, components, states);\n      if (rawResult instanceof Promise) {\n        result = await rawResult;\n\n        // Check if authentication was canceled while we were waiting\n        if (this.authenticationAbortController?.signal.aborted) {\n          // Authentication was canceled (connection disposed), silently return\n          return;\n        }\n\n        // Check if connection is still tracked by the server\n        if (!this.deltaNetServer.hasWebSocket(this.webSocket)) {\n          // Connection was removed while authentication was pending, silently return\n          return;\n        }\n      } else {\n        result = rawResult;\n      }\n    } catch (error) {\n      // Check if authentication was canceled\n      if (this.authenticationAbortController?.signal.aborted) {\n        return;\n      }\n      result = error;\n    }\n\n    // Clear the abort controller since authentication is complete\n    this.authenticationAbortController = null;\n\n    if (result instanceof DeltaNetServerError) {\n      this.disconnectWithError(result, result.errorType, result.retryable);\n    } else if (result instanceof Error) {\n      this.disconnectWithError(\n        result,\n        DeltaNetV01ServerErrors.USER_NETWORKING_UNKNOWN_ERROR_TYPE,\n        false,\n      );\n    } else if (typeof result !== \"object\") {\n      this.disconnectWithError(\n        new Error(\"Invalid authentication result\"),\n        DeltaNetV01ServerErrors.USER_NETWORKING_UNKNOWN_ERROR_TYPE,\n        false,\n      );\n    } else {\n      if (result.success) {\n        // Apply state overrides if provided\n        if (result.stateOverrides) {\n          for (const [stateId, stateValue] of result.stateOverrides) {\n            this.states.set(stateId, stateValue);\n          }\n        }\n\n        this.deltaNetServer.addAuthenticatedConnection(this);\n      } else {\n        this.disconnectWithError(\n          new Error(result.error || \"Authentication failed\"),\n          DeltaNetV01ServerErrors.USER_NETWORKING_UNKNOWN_ERROR_TYPE,\n          false,\n        );\n      }\n    }\n    this.isAuthenticating = false;\n  }\n\n  public async handleStateUpdate(stateId: number, stateValue: Uint8Array): Promise<void> {\n    if (!this.isAuthenticated) {\n      console.error(\"State update received before authentication completed\");\n      return;\n    }\n\n    // Cancel any existing pending validation for this state\n    const existingValidation = this.pendingStateValidations.get(stateId);\n    if (existingValidation) {\n      existingValidation.abortController.abort();\n      this.pendingStateValidations.delete(stateId);\n    }\n\n    const result = this.deltaNetServer.validateAndApplyStateUpdate(\n      this,\n      this.internalConnectionId,\n      stateId,\n      stateValue,\n    );\n\n    if (result instanceof Promise) {\n      const validationId = this.nextValidationId++;\n      const abortController = new AbortController();\n\n      this.pendingStateValidations.set(stateId, { validationId, abortController });\n\n      try {\n        const asyncResult = await result;\n\n        // Check if this validation is still current\n        const currentValidation = this.pendingStateValidations.get(stateId);\n        if (!currentValidation || currentValidation.validationId !== validationId) {\n          return; // Validation was superseded\n        }\n\n        this.pendingStateValidations.delete(stateId);\n\n        if (asyncResult instanceof DeltaNetServerError) {\n          this.disconnectWithError(asyncResult, asyncResult.errorType, asyncResult.retryable);\n          return;\n        }\n        if (asyncResult instanceof Error) {\n          this.disconnectWithError(\n            asyncResult,\n            DeltaNetV01ServerErrors.USER_NETWORKING_UNKNOWN_ERROR_TYPE,\n            false,\n          );\n          return;\n        }\n\n        return;\n      } catch (error) {\n        // Check if validation is still current\n        const currentValidation = this.pendingStateValidations.get(stateId);\n        if (currentValidation && currentValidation.validationId === validationId) {\n          this.pendingStateValidations.delete(stateId);\n\n          if (error instanceof DeltaNetServerError) {\n            this.disconnectWithError(error, error.errorType, error.retryable);\n          } else if (error instanceof Error) {\n            this.disconnectWithError(\n              error,\n              DeltaNetV01ServerErrors.USER_NETWORKING_UNKNOWN_ERROR_TYPE,\n              false,\n            );\n          } else {\n            this.disconnectWithError(\n              new Error(\"State validation failed\"),\n              DeltaNetV01ServerErrors.USER_NETWORKING_UNKNOWN_ERROR_TYPE,\n              false,\n            );\n          }\n        }\n        return;\n      }\n    } else {\n      // Synchronous result\n      if (result instanceof DeltaNetServerError) {\n        this.disconnectWithError(result, result.errorType, result.retryable);\n        return;\n      }\n      if (result instanceof Error) {\n        this.disconnectWithError(\n          result,\n          DeltaNetV01ServerErrors.USER_NETWORKING_UNKNOWN_ERROR_TYPE,\n          false,\n        );\n        return;\n      }\n      return;\n    }\n  }\n\n  private handleClientMessage(parsed: DeltaNetV01ClientMessage) {\n    switch (parsed.type) {\n      case \"connectUser\": {\n        if (this.deltaNetServer !== null) {\n          // Handle async connection\n          this.handleConnectUser(parsed.token, parsed.observer, parsed.components, parsed.states);\n        }\n        return;\n      }\n      case \"pong\":\n        // Ignore pongs\n        return;\n      case \"setUserComponents\": {\n        if (!this.deltaNetServer) {\n          console.error(\"DeltaNetServer not set on connection that received event\", this);\n          return;\n        }\n        if (!this.isAuthenticated) {\n          this.sendMessage({\n            type: \"error\",\n            errorType: \"USER_NOT_AUTHENTICATED\",\n            message: `Event sent, but user has not been authenticated yet.`,\n            retryable: false,\n          });\n          console.error(\"Event sent, but user has not been authenticated yet.\");\n          this.webSocket.close(1000, \"User has not been authenticated yet\");\n          return;\n        }\n\n        // Handle component updates immediately\n        const result = this.deltaNetServer.setUserComponents(\n          this,\n          this.internalConnectionId,\n          parsed.components,\n        );\n\n        // Check if component update was rejected\n        if (!result.success) {\n          this.disconnectWithError(\n            new Error(result.error),\n            DeltaNetV01ServerErrors.USER_NETWORKING_UNKNOWN_ERROR_TYPE,\n            true,\n          );\n          return;\n        }\n\n        // Handle state updates individually with async validation\n        for (const [stateId, stateValue] of parsed.states) {\n          this.handleStateUpdate(stateId, stateValue);\n        }\n        return;\n      }\n      case \"clientCustom\": {\n        if (!this.deltaNetServer) {\n          console.error(\"DeltaNetServer not set on connection that received custom message\", this);\n          return;\n        }\n        if (!this.isAuthenticated) {\n          this.sendMessage({\n            type: \"error\",\n            errorType: \"USER_NOT_AUTHENTICATED\",\n            message: `Custom message sent, but user has not been authenticated yet.`,\n            retryable: false,\n          });\n          console.error(\"Custom message sent, but user has not been authenticated yet.\");\n          this.webSocket.close(1000, \"User has not been authenticated yet\");\n          return;\n        }\n\n        // Handle custom message\n        this.deltaNetServer.handleCustomMessage(\n          this,\n          this.internalConnectionId,\n          parsed.customType,\n          parsed.contents,\n        );\n        return;\n      }\n      default:\n        console.error(\"Unknown message type from client\", parsed);\n    }\n  }\n}\n", "const emptyUint8Array = new Uint8Array(0);\n\nexport class StateCollection {\n  public values: Array<Uint8Array>;\n  private modifiedIndices = new Set<number>();\n\n  public constructor() {\n    this.values = new Array<Uint8Array>();\n  }\n\n  public setValue(index: number, value: Uint8Array | null): void {\n    if (value === null) {\n      value = emptyUint8Array;\n    }\n    this.modifiedIndices.add(index);\n    this.values[index] = value;\n  }\n\n  public tick(): Array<[number, Uint8Array]> {\n    const states: Array<[number, Uint8Array]> = [];\n    for (const index of this.modifiedIndices) {\n      const value = this.values[index];\n      if (value === null) {\n        states.push([index, new Uint8Array(0)]);\n      } else {\n        states.push([index, value]);\n      }\n    }\n    this.modifiedIndices.clear();\n    return states;\n  }\n\n  public removeIndices(sortedUnoccupyingIndices: Array<number>) {\n    // If there are no indices to remove, return early\n    if (sortedUnoccupyingIndices.length === 0) {\n      return;\n    }\n\n    let writeIndex = 0;\n    let skipIndex = 0;\n\n    // Process each element in the array\n    for (let readIndex = 0; readIndex < this.values.length; readIndex++) {\n      // Skip indices that should be removed\n      if (\n        skipIndex < sortedUnoccupyingIndices.length &&\n        readIndex === sortedUnoccupyingIndices[skipIndex]\n      ) {\n        // Remove from modified indices if present\n        this.modifiedIndices.delete(readIndex);\n        skipIndex++;\n        continue;\n      }\n\n      // If we're going to shift this element, update the modified indices\n      if (writeIndex !== readIndex && this.modifiedIndices.has(readIndex)) {\n        this.modifiedIndices.delete(readIndex);\n        this.modifiedIndices.add(writeIndex);\n      }\n\n      // Shift values to the left (in-place)\n      if (writeIndex !== readIndex) {\n        this.values[writeIndex] = this.values[readIndex];\n      }\n\n      writeIndex++;\n    }\n\n    // Clear the remaining elements\n    for (let i = writeIndex; i < this.values.length; i++) {\n      this.values[i] = emptyUint8Array;\n      this.modifiedIndices.delete(i);\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["encodeServerMessage", "DeltaNetServer", "internalConnectionId", "writer", "encodeServerMessage"]
}
