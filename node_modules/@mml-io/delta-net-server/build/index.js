// src/DeltaNetServer.ts
import {
  BufferWriter,
  encodeInitialCheckout,
  encodePing,
  encodeTick,
  encodeServerMessage as encodeServerMessage2
} from "@mml-io/delta-net-protocol";

// src/ComponentCollection.ts
var ComponentCollection = class _ComponentCollection {
  // Internal storage using bigint arrays for unlimited precision
  targetValues;
  pendingDeltas;
  previousEmittedDeltas;
  // Track the current observable value (what existing connections see)
  currentObservableValues;
  // Constants for int64 range
  static MIN_INT64 = -9223372036854775808n;
  static MAX_INT64 = 9223372036854775807n;
  constructor(initialLength = 128) {
    this.targetValues = new Array(initialLength).fill(BigInt(0));
    this.pendingDeltas = new Array(initialLength).fill(BigInt(0));
    this.previousEmittedDeltas = new Array(initialLength).fill(BigInt(0));
    this.currentObservableValues = new Array(initialLength).fill(BigInt(0));
  }
  setLength(length) {
    if (length > this.targetValues.length) {
      while (this.targetValues.length < length) {
        this.targetValues.push(BigInt(0));
        this.pendingDeltas.push(BigInt(0));
        this.previousEmittedDeltas.push(BigInt(0));
        this.currentObservableValues.push(BigInt(0));
      }
    } else if (length < this.targetValues.length) {
      this.targetValues = this.targetValues.slice(0, length);
      this.pendingDeltas = this.pendingDeltas.slice(0, length);
      this.previousEmittedDeltas = this.previousEmittedDeltas.slice(0, length);
      this.currentObservableValues = this.currentObservableValues.slice(0, length);
    }
  }
  setValue(index, value) {
    if (index >= this.targetValues.length) {
      const newLength = Math.pow(2, Math.ceil(Math.log2(index + 1)));
      this.setLength(newLength);
    }
    const clampedValue = this.clampToInt64(value);
    const currentValue = this.targetValues[index];
    const totalDelta = clampedValue - currentValue;
    this.pendingDeltas[index] += totalDelta;
    this.targetValues[index] = clampedValue;
  }
  clampToInt64(value) {
    if (value > _ComponentCollection.MAX_INT64) {
      return _ComponentCollection.MAX_INT64;
    }
    if (value < _ComponentCollection.MIN_INT64) {
      return _ComponentCollection.MIN_INT64;
    }
    return value;
  }
  tick() {
    const length = this.targetValues.length;
    const delta = new BigInt64Array(length);
    const deltaDeltas = new BigInt64Array(length);
    for (let i = 0; i < length; i++) {
      const pendingDelta = this.pendingDeltas[i];
      const emittableDelta = this.clampToInt64(pendingDelta);
      delta[i] = emittableDelta;
      const deltaDelta = emittableDelta - this.previousEmittedDeltas[i];
      const clampedDeltaDelta = this.clampToInt64(deltaDelta);
      deltaDeltas[i] = clampedDeltaDelta;
      this.previousEmittedDeltas[i] = emittableDelta;
      this.currentObservableValues[i] = this.clampToInt64(
        this.currentObservableValues[i] + emittableDelta
      );
      this.pendingDeltas[i] -= emittableDelta;
    }
    return { delta, deltaDeltas };
  }
  removeIndices(sortedUnoccupyingIndices) {
    if (sortedUnoccupyingIndices.length === 0) {
      return;
    }
    let writeIndex = 0;
    let skipIndex = 0;
    for (let readIndex = 0; readIndex < this.targetValues.length; readIndex++) {
      if (skipIndex < sortedUnoccupyingIndices.length && readIndex === sortedUnoccupyingIndices[skipIndex]) {
        skipIndex++;
        continue;
      }
      if (writeIndex !== readIndex) {
        this.targetValues[writeIndex] = this.targetValues[readIndex];
        this.pendingDeltas[writeIndex] = this.pendingDeltas[readIndex];
        this.previousEmittedDeltas[writeIndex] = this.previousEmittedDeltas[readIndex];
        this.currentObservableValues[writeIndex] = this.currentObservableValues[readIndex];
      }
      writeIndex++;
    }
    for (let i = writeIndex; i < this.targetValues.length; i++) {
      this.targetValues[i] = BigInt(0);
      this.pendingDeltas[i] = BigInt(0);
      this.previousEmittedDeltas[i] = BigInt(0);
      this.currentObservableValues[i] = BigInt(0);
    }
  }
  // Getter for current target values (for testing)
  getTargetValue(index) {
    return this.targetValues[index] || BigInt(0);
  }
  // Getter for pending deltas (for testing)
  getPendingDelta(index) {
    return this.pendingDeltas[index] || BigInt(0);
  }
  // Getter for length (for testing)
  get length() {
    return this.targetValues.length;
  }
  // Get target values as BigInt64Array for serialization
  getCurrentValuesArray() {
    const result = new BigInt64Array(this.targetValues.length);
    for (let i = 0; i < this.targetValues.length; i++) {
      result[i] = this.currentObservableValues[i];
    }
    return result;
  }
  // Get previous emitted deltas as BigInt64Array for serialization
  getPreviousEmittedDeltasArray() {
    const result = new BigInt64Array(this.previousEmittedDeltas.length);
    for (let i = 0; i < this.previousEmittedDeltas.length; i++) {
      result[i] = this.previousEmittedDeltas[i];
    }
    return result;
  }
};

// src/createDeltaNetServerConnectionForWebsocket.ts
import {
  deltaNetProtocolSubProtocol_v0_1
} from "@mml-io/delta-net-protocol";

// src/DeltaNetV01Connection.ts
import {
  DeltaNetV01ServerErrors,
  BufferReader,
  decodeClientMessages,
  encodeServerMessage
} from "@mml-io/delta-net-protocol";
var DeltaNetV01Connection = class {
  constructor(webSocket, deltaNetServer) {
    this.webSocket = webSocket;
    this.deltaNetServer = deltaNetServer;
    this.internalConnectionId = deltaNetServer.getNextConnectionId();
    this.websocketListener = (messageEvent) => {
      const buffer = new Uint8Array(messageEvent.data);
      const maxMessageSize = this.deltaNetServer.getMaxMessageSize();
      if (buffer.length > maxMessageSize) {
        this.disconnectWithError(
          new Error(
            `Message size ${buffer.length} bytes exceeds maximum allowed size of ${maxMessageSize} bytes`
          ),
          DeltaNetV01ServerErrors.USER_NETWORKING_UNKNOWN_ERROR_TYPE,
          false
        );
        return;
      }
      try {
        const messages = decodeClientMessages(new BufferReader(buffer));
        for (const parsed of messages) {
          this.handleClientMessage(parsed);
        }
      } catch (error) {
        this.disconnectWithError(
          new Error(
            `Failed to decode client messages: ${error instanceof Error ? error.message : error}`
          ),
          DeltaNetV01ServerErrors.USER_NETWORKING_UNKNOWN_ERROR_TYPE,
          false
        );
        return;
      }
    };
    webSocket.addEventListener("message", this.websocketListener);
    this.deltaNetServer = deltaNetServer;
  }
  websocketListener;
  internalConnectionId;
  isObserver = false;
  // Track observer mode
  // Pending state for new joiners (before they're authenticated)
  components = /* @__PURE__ */ new Map();
  states = /* @__PURE__ */ new Map();
  // Track pending async state validations per state
  pendingStateValidations = /* @__PURE__ */ new Map();
  nextValidationId = 1;
  // Track authentication state
  isAuthenticated = false;
  isAuthenticating = false;
  authenticationAbortController = null;
  sendMessage(message) {
    this.sendEncodedBytes(encodeServerMessage(message).getBuffer());
  }
  sendEncodedBytes(bytes) {
    this.webSocket.send(bytes);
  }
  dispose() {
    this.webSocket.removeEventListener("message", this.websocketListener);
    for (const [, validation] of this.pendingStateValidations) {
      validation.abortController.abort();
    }
    this.pendingStateValidations.clear();
    if (this.authenticationAbortController) {
      this.authenticationAbortController.abort();
      this.authenticationAbortController = null;
    }
  }
  setAuthenticated() {
    this.isAuthenticated = true;
  }
  disconnectWithError(error, errorType, retryable = true) {
    try {
      this.sendMessage({
        type: "error",
        errorType,
        message: error.message,
        retryable
      });
    } catch (sendError) {
      console.warn("Failed to send error message to client:", sendError);
    }
    try {
      this.webSocket.close(1008, error.message);
    } catch (closeError) {
      console.warn("Failed to close websocket connection:", closeError);
    }
  }
  async handleConnectUser(token, observer, components, states) {
    var _a, _b;
    if (this.isAuthenticated) {
      this.disconnectWithError(
        new Error("User is already authenticated"),
        DeltaNetV01ServerErrors.USER_ALREADY_AUTHENTICATED_ERROR_TYPE,
        false
      );
      return;
    }
    if (this.isAuthenticating) {
      this.disconnectWithError(
        new Error("Authentication already in progress"),
        DeltaNetV01ServerErrors.AUTHENTICATION_IN_PROGRESS_ERROR_TYPE,
        false
      );
      return;
    }
    this.isAuthenticating = true;
    this.authenticationAbortController = new AbortController();
    this.isObserver = observer;
    this.components = new Map(components);
    this.states = new Map(states);
    let result;
    try {
      const rawResult = this.deltaNetServer.validateJoiner(this, token, components, states);
      if (rawResult instanceof Promise) {
        result = await rawResult;
        if ((_a = this.authenticationAbortController) == null ? void 0 : _a.signal.aborted) {
          return;
        }
        if (!this.deltaNetServer.hasWebSocket(this.webSocket)) {
          return;
        }
      } else {
        result = rawResult;
      }
    } catch (error) {
      if ((_b = this.authenticationAbortController) == null ? void 0 : _b.signal.aborted) {
        return;
      }
      result = error;
    }
    this.authenticationAbortController = null;
    if (result instanceof DeltaNetServerError) {
      this.disconnectWithError(result, result.errorType, result.retryable);
    } else if (result instanceof Error) {
      this.disconnectWithError(
        result,
        DeltaNetV01ServerErrors.USER_NETWORKING_UNKNOWN_ERROR_TYPE,
        false
      );
    } else if (typeof result !== "object") {
      this.disconnectWithError(
        new Error("Invalid authentication result"),
        DeltaNetV01ServerErrors.USER_NETWORKING_UNKNOWN_ERROR_TYPE,
        false
      );
    } else {
      if (result.success) {
        if (result.stateOverrides) {
          for (const [stateId, stateValue] of result.stateOverrides) {
            this.states.set(stateId, stateValue);
          }
        }
        this.deltaNetServer.addAuthenticatedConnection(this);
      } else {
        this.disconnectWithError(
          new Error(result.error || "Authentication failed"),
          DeltaNetV01ServerErrors.USER_NETWORKING_UNKNOWN_ERROR_TYPE,
          false
        );
      }
    }
    this.isAuthenticating = false;
  }
  async handleStateUpdate(stateId, stateValue) {
    if (!this.isAuthenticated) {
      console.error("State update received before authentication completed");
      return;
    }
    const existingValidation = this.pendingStateValidations.get(stateId);
    if (existingValidation) {
      existingValidation.abortController.abort();
      this.pendingStateValidations.delete(stateId);
    }
    const result = this.deltaNetServer.validateAndApplyStateUpdate(
      this,
      this.internalConnectionId,
      stateId,
      stateValue
    );
    if (result instanceof Promise) {
      const validationId = this.nextValidationId++;
      const abortController = new AbortController();
      this.pendingStateValidations.set(stateId, { validationId, abortController });
      try {
        const asyncResult = await result;
        const currentValidation = this.pendingStateValidations.get(stateId);
        if (!currentValidation || currentValidation.validationId !== validationId) {
          return;
        }
        this.pendingStateValidations.delete(stateId);
        if (asyncResult instanceof DeltaNetServerError) {
          this.disconnectWithError(asyncResult, asyncResult.errorType, asyncResult.retryable);
          return;
        }
        if (asyncResult instanceof Error) {
          this.disconnectWithError(
            asyncResult,
            DeltaNetV01ServerErrors.USER_NETWORKING_UNKNOWN_ERROR_TYPE,
            false
          );
          return;
        }
        return;
      } catch (error) {
        const currentValidation = this.pendingStateValidations.get(stateId);
        if (currentValidation && currentValidation.validationId === validationId) {
          this.pendingStateValidations.delete(stateId);
          if (error instanceof DeltaNetServerError) {
            this.disconnectWithError(error, error.errorType, error.retryable);
          } else if (error instanceof Error) {
            this.disconnectWithError(
              error,
              DeltaNetV01ServerErrors.USER_NETWORKING_UNKNOWN_ERROR_TYPE,
              false
            );
          } else {
            this.disconnectWithError(
              new Error("State validation failed"),
              DeltaNetV01ServerErrors.USER_NETWORKING_UNKNOWN_ERROR_TYPE,
              false
            );
          }
        }
        return;
      }
    } else {
      if (result instanceof DeltaNetServerError) {
        this.disconnectWithError(result, result.errorType, result.retryable);
        return;
      }
      if (result instanceof Error) {
        this.disconnectWithError(
          result,
          DeltaNetV01ServerErrors.USER_NETWORKING_UNKNOWN_ERROR_TYPE,
          false
        );
        return;
      }
      return;
    }
  }
  handleClientMessage(parsed) {
    switch (parsed.type) {
      case "connectUser": {
        if (this.deltaNetServer !== null) {
          this.handleConnectUser(parsed.token, parsed.observer, parsed.components, parsed.states);
        }
        return;
      }
      case "pong":
        return;
      case "setUserComponents": {
        if (!this.deltaNetServer) {
          console.error("DeltaNetServer not set on connection that received event", this);
          return;
        }
        if (!this.isAuthenticated) {
          this.sendMessage({
            type: "error",
            errorType: "USER_NOT_AUTHENTICATED",
            message: `Event sent, but user has not been authenticated yet.`,
            retryable: false
          });
          console.error("Event sent, but user has not been authenticated yet.");
          this.webSocket.close(1e3, "User has not been authenticated yet");
          return;
        }
        const result = this.deltaNetServer.setUserComponents(
          this,
          this.internalConnectionId,
          parsed.components
        );
        if (!result.success) {
          this.disconnectWithError(
            new Error(result.error),
            DeltaNetV01ServerErrors.USER_NETWORKING_UNKNOWN_ERROR_TYPE,
            true
          );
          return;
        }
        for (const [stateId, stateValue] of parsed.states) {
          this.handleStateUpdate(stateId, stateValue);
        }
        return;
      }
      case "clientCustom": {
        if (!this.deltaNetServer) {
          console.error("DeltaNetServer not set on connection that received custom message", this);
          return;
        }
        if (!this.isAuthenticated) {
          this.sendMessage({
            type: "error",
            errorType: "USER_NOT_AUTHENTICATED",
            message: `Custom message sent, but user has not been authenticated yet.`,
            retryable: false
          });
          console.error("Custom message sent, but user has not been authenticated yet.");
          this.webSocket.close(1e3, "User has not been authenticated yet");
          return;
        }
        this.deltaNetServer.handleCustomMessage(
          this,
          this.internalConnectionId,
          parsed.customType,
          parsed.contents
        );
        return;
      }
      default:
        console.error("Unknown message type from client", parsed);
    }
  }
};

// src/createDeltaNetServerConnectionForWebsocket.ts
var SupportedWebsocketSubProtocolsPreferenceOrder = [
  deltaNetProtocolSubProtocol_v0_1
];
function IsRecognizedWebsocketSubProtocol(protocol) {
  return SupportedWebsocketSubProtocolsPreferenceOrder.includes(protocol);
}
function createDeltaNetServerConnectionForWebsocket(webSocket, deltaNetServer) {
  if (!webSocket.protocol || !IsRecognizedWebsocketSubProtocol(webSocket.protocol)) {
    const errorMessageString = `Unsupported websocket subprotocol: ${webSocket.protocol}`;
    const errorMessage = [
      {
        type: "error",
        errorType: "UNSUPPORTED_WEBSOCKET_SUBPROTOCOL",
        message: errorMessageString,
        retryable: false
      }
    ];
    webSocket.send(JSON.stringify(errorMessage));
    webSocket.close();
    return null;
  }
  return new DeltaNetV01Connection(webSocket, deltaNetServer);
}

// src/StateCollection.ts
var emptyUint8Array = new Uint8Array(0);
var StateCollection = class {
  values;
  modifiedIndices = /* @__PURE__ */ new Set();
  constructor() {
    this.values = new Array();
  }
  setValue(index, value) {
    if (value === null) {
      value = emptyUint8Array;
    }
    this.modifiedIndices.add(index);
    this.values[index] = value;
  }
  tick() {
    const states = [];
    for (const index of this.modifiedIndices) {
      const value = this.values[index];
      if (value === null) {
        states.push([index, new Uint8Array(0)]);
      } else {
        states.push([index, value]);
      }
    }
    this.modifiedIndices.clear();
    return states;
  }
  removeIndices(sortedUnoccupyingIndices) {
    if (sortedUnoccupyingIndices.length === 0) {
      return;
    }
    let writeIndex = 0;
    let skipIndex = 0;
    for (let readIndex = 0; readIndex < this.values.length; readIndex++) {
      if (skipIndex < sortedUnoccupyingIndices.length && readIndex === sortedUnoccupyingIndices[skipIndex]) {
        this.modifiedIndices.delete(readIndex);
        skipIndex++;
        continue;
      }
      if (writeIndex !== readIndex && this.modifiedIndices.has(readIndex)) {
        this.modifiedIndices.delete(readIndex);
        this.modifiedIndices.add(writeIndex);
      }
      if (writeIndex !== readIndex) {
        this.values[writeIndex] = this.values[readIndex];
      }
      writeIndex++;
    }
    for (let i = writeIndex; i < this.values.length; i++) {
      this.values[i] = emptyUint8Array;
      this.modifiedIndices.delete(i);
    }
  }
};

// src/DeltaNetServer.ts
var DeltaNetServerError = class extends Error {
  constructor(errorType, message, retryable) {
    super(message);
    this.errorType = errorType;
    this.retryable = retryable;
  }
};
var DeltaNetServer2 = class {
  constructor(opts = {}) {
    this.opts = opts;
    if (opts.serverConnectionIdStateId !== void 0) {
      this.states.set(opts.serverConnectionIdStateId, new StateCollection());
    }
    this.maxStateValueSize = opts.maxStateValueSize ?? 1024 * 1024;
    this.maxMessageSize = opts.maxMessageSize ?? 10 * 1024 * 1024;
  }
  currentConnectionId = 1;
  nextIndex = 0;
  preTickData = {
    // This is state that will be flushed to clients in the next tick, but messages handled before the tick could change it
    unoccupyingIndices: /* @__PURE__ */ new Set(),
    newJoinerConnections: /* @__PURE__ */ new Set(),
    // Allows for arbitrary processes to be run that can imitate a new joiner connection (currently used for legacy adapter)
    newJoinerCallbacks: /* @__PURE__ */ new Set(),
    componentsUpdated: 0
  };
  connectionIdToComponentIndex = /* @__PURE__ */ new Map();
  componentIndexToConnectionId = /* @__PURE__ */ new Map();
  connectionIdToDeltaNetServerConnection = /* @__PURE__ */ new Map();
  allDeltaNetV01Connections = /* @__PURE__ */ new Set();
  authenticatedDeltaNetV01Connections = /* @__PURE__ */ new Set();
  observerConnections = /* @__PURE__ */ new Set();
  // Track observer connections separately
  webSocketToDeltaNetServerConnection = /* @__PURE__ */ new Map();
  components = /* @__PURE__ */ new Map();
  states = /* @__PURE__ */ new Map();
  documentEffectiveStartTime = Date.now();
  pingCounter = 1;
  disposed = false;
  maxStateValueSize;
  maxMessageSize;
  static handleWebsocketSubprotocol(protocols) {
    const protocolsSet = new Set(protocols);
    for (const protocol of SupportedWebsocketSubProtocolsPreferenceOrder) {
      if (protocolsSet.has(protocol)) {
        return protocol;
      }
    }
    return false;
  }
  addWebSocket(webSocket) {
    if (this.disposed) {
      throw new Error("This DeltaNetServer has been disposed");
    }
    const deltaNetV01Connection = createDeltaNetServerConnectionForWebsocket(webSocket, this);
    if (deltaNetV01Connection === null) {
      return;
    }
    this.allDeltaNetV01Connections.add(deltaNetV01Connection);
    this.webSocketToDeltaNetServerConnection.set(
      deltaNetV01Connection.webSocket,
      deltaNetV01Connection
    );
  }
  removeWebSocket(webSocket) {
    const deltaNetV01Connection = this.webSocketToDeltaNetServerConnection.get(webSocket);
    if (deltaNetV01Connection === void 0) {
      return;
    }
    if (!this.allDeltaNetV01Connections.has(deltaNetV01Connection)) {
      return;
    }
    deltaNetV01Connection.dispose();
    if (!this.disposed && this.opts.onLeave) {
      const internalConnectionId2 = deltaNetV01Connection.internalConnectionId;
      const index = this.connectionIdToComponentIndex.get(internalConnectionId2);
      if (index !== void 0) {
        const components = [];
        for (const [componentId, collection] of this.components) {
          const value = collection.getTargetValue(index);
          if (value !== 0n) {
            components.push([componentId, Number(value)]);
          }
        }
        const states = [];
        for (const [stateId, collection] of this.states) {
          const value = collection.values[index];
          if (value !== void 0 && value.length > 0) {
            states.push([stateId, value]);
          }
        }
        try {
          this.opts.onLeave({
            deltaNetV01Connection,
            internalConnectionId: internalConnectionId2,
            components,
            states
          });
        } catch (error) {
          console.warn("Error in onLeave callback:", error);
        }
      }
    }
    const internalConnectionId = deltaNetV01Connection.internalConnectionId;
    this.connectionIdToDeltaNetServerConnection.delete(internalConnectionId);
    if (this.preTickData.newJoinerConnections.has(deltaNetV01Connection)) {
      this.preTickData.newJoinerConnections.delete(deltaNetV01Connection);
    } else {
      const index = this.connectionIdToComponentIndex.get(internalConnectionId);
      if (index !== void 0) {
        this.clearInternalConnectionId(internalConnectionId);
      }
    }
    this.authenticatedDeltaNetV01Connections.delete(deltaNetV01Connection);
    this.observerConnections.delete(deltaNetV01Connection);
    this.allDeltaNetV01Connections.delete(deltaNetV01Connection);
    this.webSocketToDeltaNetServerConnection.delete(deltaNetV01Connection.webSocket);
  }
  hasWebSocket(webSocket) {
    return this.webSocketToDeltaNetServerConnection.has(webSocket);
  }
  dangerouslyGetConnectionsToComponentIndex() {
    return this.connectionIdToComponentIndex;
  }
  dangerouslyAddNewJoinerCallback(callback) {
    this.preTickData.newJoinerCallbacks.add(callback);
  }
  disconnectWithError(deltaNetV01Connection, error, errorType, retryable = true) {
    try {
      deltaNetV01Connection.sendMessage({
        type: "error",
        errorType,
        message: error.message,
        retryable
      });
    } catch (sendError) {
      console.warn("Failed to send error message to client:", sendError);
    }
    try {
      deltaNetV01Connection.webSocket.close(1008, error.message);
    } catch (closeError) {
      console.warn("Failed to close websocket connection:", closeError);
    }
    try {
      this.removeWebSocket(deltaNetV01Connection.webSocket);
    } catch (cleanupError) {
      console.warn("Failed to clean up connection state:", cleanupError);
    }
  }
  getComponentValue(componentId, componentIndex) {
    const componentCollection = this.components.get(componentId);
    if (componentCollection === void 0) {
      return null;
    }
    return Number(componentCollection.getTargetValue(componentIndex));
  }
  getNextConnectionId() {
    return this.currentConnectionId++;
  }
  getMaxMessageSize() {
    return this.maxMessageSize;
  }
  validateJoiner(deltaNetV01Connection, token, components, states) {
    if (this.disposed) {
      return { success: false, error: "This DeltaNetServer has been disposed" };
    }
    for (const [stateId, stateValue] of states) {
      if (stateValue.length > this.maxStateValueSize) {
        return {
          success: false,
          error: `State value for state ${stateId} has size ${stateValue.length} bytes which exceeds maximum allowed size of ${this.maxStateValueSize} bytes`
        };
      }
    }
    function resultToReturn(result) {
      if (result instanceof DeltaNetServerError) {
        return { success: false, error: result.message };
      }
      if (result instanceof Error) {
        return { success: false, error: result.message };
      }
      if (result === true || result === void 0) {
        return { success: true };
      }
      if (typeof result === "object" && result.success === true) {
        return result;
      }
      return { success: false, error: "Joiner validation failed" };
    }
    if (this.opts.onJoiner) {
      const rawResult = this.opts.onJoiner({
        deltaNetV01Connection,
        components,
        states,
        token,
        internalConnectionId: deltaNetV01Connection.internalConnectionId
      });
      if (rawResult instanceof Promise) {
        return rawResult.then((resolvedResult) => {
          return resultToReturn(resolvedResult);
        }).catch((error) => {
          console.warn("Error in async onJoiner callback:", error);
          return resultToReturn(error);
        });
      } else {
        return resultToReturn(rawResult);
      }
    }
    return { success: true };
  }
  addAuthenticatedConnection(deltaNetV01Connection) {
    if (deltaNetV01Connection.internalConnectionId === null) {
      throw new Error("Connection ID must be set before adding to authenticated connections");
    }
    this.connectionIdToDeltaNetServerConnection.set(
      deltaNetV01Connection.internalConnectionId,
      deltaNetV01Connection
    );
    if (deltaNetV01Connection.isObserver) {
      this.observerConnections.add(deltaNetV01Connection);
      this.preTickData.newJoinerConnections.add(deltaNetV01Connection);
    } else {
      this.preTickData.newJoinerConnections.add(deltaNetV01Connection);
    }
  }
  validateAndApplyStateUpdate(deltaNetV01Connection, internalConnectionId, stateId, stateValue) {
    if (this.disposed) {
      return new Error("This DeltaNetServer has been disposed");
    }
    if (stateValue.length > this.maxStateValueSize) {
      return new DeltaNetServerError(
        "USER_NETWORKING_UNKNOWN_ERROR",
        `State value for state ${stateId} has size ${stateValue.length} bytes which exceeds maximum allowed size of ${this.maxStateValueSize} bytes`,
        false
      );
    }
    if (deltaNetV01Connection.isObserver) {
      return new DeltaNetServerError(
        "OBSERVER_CANNOT_SEND_STATE_UPDATES",
        "Observers cannot send state updates",
        false
      );
    }
    if (this.opts.onStatesUpdate) {
      try {
        const result = this.opts.onStatesUpdate({
          deltaNetV01Connection,
          internalConnectionId,
          states: [[stateId, stateValue]]
        });
        if (result instanceof Promise) {
          return result.then((asyncResult) => {
            if (!this.connectionIdToDeltaNetServerConnection.has(internalConnectionId)) {
              return;
            }
            if (asyncResult instanceof DeltaNetServerError || asyncResult instanceof Error) {
              return asyncResult;
            }
            if (asyncResult === true || asyncResult === void 0) {
              this.applyStateUpdates(deltaNetV01Connection, internalConnectionId, [
                [stateId, stateValue]
              ]);
              return true;
            }
            if (asyncResult.success) {
              if (asyncResult.stateOverrides) {
                this.applyStateUpdates(
                  deltaNetV01Connection,
                  internalConnectionId,
                  asyncResult.stateOverrides
                );
              }
              return true;
            } else {
              return new DeltaNetServerError(
                "USER_NETWORKING_UNKNOWN_ERROR",
                "State validation failed",
                false
              );
            }
          }).catch((error) => {
            console.warn("Error in async onStatesUpdate callback:", error);
            if (error instanceof DeltaNetServerError) {
              return error;
            }
            if (error instanceof Error) {
              return error;
            }
            return new Error("State validation failed");
          });
        } else {
          if (result instanceof DeltaNetServerError || result instanceof Error) {
            return result;
          }
          if (result === true || result === void 0) {
            this.applyStateUpdates(deltaNetV01Connection, internalConnectionId, [
              [stateId, stateValue]
            ]);
            return true;
          }
          if (result.success) {
            if (result.stateOverrides) {
              this.applyStateUpdates(
                deltaNetV01Connection,
                internalConnectionId,
                result.stateOverrides
              );
            }
            return true;
          } else {
            return new DeltaNetServerError(
              "USER_NETWORKING_UNKNOWN_ERROR",
              "State validation failed",
              false
            );
          }
        }
      } catch (error) {
        console.warn("Error in onStatesUpdate callback:", error);
        if (error instanceof DeltaNetServerError) {
          return error;
        }
        if (error instanceof Error) {
          return error;
        }
        return new Error("State validation failed");
      }
    } else {
      this.applyStateUpdates(deltaNetV01Connection, internalConnectionId, [[stateId, stateValue]]);
      return true;
    }
  }
  clearInternalConnectionId(internalConnectionId) {
    const index = this.connectionIdToComponentIndex.get(internalConnectionId);
    if (index === void 0) {
      throw new Error("Index for removing user is undefined");
    }
    for (const [, collection] of this.components) {
      collection.setValue(index, 0n);
    }
    for (const [, collection] of this.states) {
      collection.setValue(index, null);
    }
    this.preTickData.unoccupyingIndices.add(index);
  }
  sendPings() {
    const ping = this.pingCounter++;
    if (this.pingCounter > 1e3) {
      this.pingCounter = 1;
    }
    const v01PingMessage = {
      type: "ping",
      ping
    };
    const writer = new BufferWriter(8);
    encodePing(v01PingMessage, writer);
    const v01Encoded = writer.getBuffer();
    this.allDeltaNetV01Connections.forEach((deltaNetV01Connection) => {
      deltaNetV01Connection.sendEncodedBytes(v01Encoded);
    });
  }
  tick() {
    if (this.disposed) {
      return { removedIds: /* @__PURE__ */ new Set(), addedIds: /* @__PURE__ */ new Set() };
    }
    this.preTickData.componentsUpdated = 0;
    const removedIds = /* @__PURE__ */ new Set();
    const addedIds = /* @__PURE__ */ new Set();
    const sortedUnoccupyingIndices = Array.from(this.preTickData.unoccupyingIndices);
    sortedUnoccupyingIndices.sort((a, b) => a - b);
    for (const componentCollection of this.components.values()) {
      componentCollection.removeIndices(sortedUnoccupyingIndices);
    }
    for (const stateCollection of this.states.values()) {
      stateCollection.removeIndices(sortedUnoccupyingIndices);
    }
    for (const index of sortedUnoccupyingIndices) {
      const connectionId = this.componentIndexToConnectionId.get(index);
      if (connectionId === void 0) {
        throw new Error("Connection id not found for index " + index);
      }
      removedIds.add(connectionId);
      this.connectionIdToComponentIndex.delete(connectionId);
      this.componentIndexToConnectionId.delete(index);
    }
    let writeIndex = 0;
    let skipIndex = 0;
    for (let i = 0; i < this.nextIndex; i++) {
      const connectionId = this.componentIndexToConnectionId.get(i);
      if (skipIndex < sortedUnoccupyingIndices.length && i === sortedUnoccupyingIndices[skipIndex]) {
        skipIndex++;
        continue;
      }
      if (writeIndex !== i) {
        if (connectionId === void 0) {
          throw new Error("Connection id not found for index " + i);
        }
        this.componentIndexToConnectionId.set(writeIndex, connectionId);
        this.connectionIdToComponentIndex.set(connectionId, writeIndex);
      }
      writeIndex++;
    }
    this.nextIndex -= sortedUnoccupyingIndices.length;
    for (const deltaNetV01Connection of this.preTickData.newJoinerConnections) {
      const internalConnectionId = deltaNetV01Connection.internalConnectionId;
      if (deltaNetV01Connection.isObserver) {
      } else {
        const index = this.nextIndex++;
        this.connectionIdToComponentIndex.set(internalConnectionId, index);
        this.componentIndexToConnectionId.set(index, internalConnectionId);
        addedIds.add(internalConnectionId);
        for (const [componentId] of deltaNetV01Connection.components) {
          if (!this.components.has(componentId)) {
            this.components.set(componentId, new ComponentCollection());
          }
        }
        for (const [stateId] of deltaNetV01Connection.states) {
          if (!this.states.has(stateId)) {
            this.states.set(stateId, new StateCollection());
          }
        }
        for (const [componentId, collection] of this.components) {
          const value = deltaNetV01Connection.components.get(componentId);
          if (value === void 0) {
            collection.setValue(index, 0n);
          } else {
            collection.setValue(index, BigInt(value));
          }
        }
        for (const [stateId, collection] of this.states) {
          const value = deltaNetV01Connection.states.get(stateId);
          if (this.opts.serverConnectionIdStateId !== void 0 && stateId === this.opts.serverConnectionIdStateId) {
            const writer2 = new BufferWriter(8);
            writer2.writeUVarint(internalConnectionId);
            const buffer = writer2.getBuffer();
            collection.setValue(index, buffer);
          } else {
            if (value === void 0) {
              collection.setValue(index, null);
            } else {
              collection.setValue(index, value);
            }
          }
        }
        deltaNetV01Connection.sendMessage({
          type: "userIndex",
          index
        });
      }
    }
    for (const callback of this.preTickData.newJoinerCallbacks) {
      const index = this.nextIndex++;
      const result = callback(index);
      if (result === null) {
        this.nextIndex--;
      } else {
        const { id, afterAddCallback } = result;
        this.connectionIdToComponentIndex.set(id, index);
        this.componentIndexToConnectionId.set(index, id);
        addedIds.add(id);
        if (this.opts.serverConnectionIdStateId !== void 0) {
          const writer2 = new BufferWriter(8);
          writer2.writeUVarint(id);
          const buffer = writer2.getBuffer();
          this.setUserState(index, this.opts.serverConnectionIdStateId, buffer);
        }
        if (afterAddCallback) {
          afterAddCallback();
        }
      }
    }
    const componentDeltas = [];
    for (const [componentId, collection] of this.components) {
      const { deltaDeltas } = collection.tick();
      componentDeltas.push({ componentId, deltaDeltas });
    }
    const stateDeltas = [];
    for (const [stateId, collection] of this.states) {
      const updatedStates = collection.tick();
      if (updatedStates.length === 0) {
        continue;
      }
      stateDeltas.push({
        stateId,
        updatedStates
      });
    }
    const tickMessage = {
      type: "tick",
      serverTime: this.getServerTime(),
      removedIndices: sortedUnoccupyingIndices,
      indicesCount: this.nextIndex,
      componentDeltaDeltas: componentDeltas,
      states: stateDeltas
    };
    const writer = new BufferWriter(this.nextIndex * this.components.size + 128);
    encodeTick(tickMessage, writer);
    const v01EncodedComponentsChanged = writer.getBuffer();
    this.authenticatedDeltaNetV01Connections.forEach((deltaNetV01Connection) => {
      deltaNetV01Connection.sendEncodedBytes(v01EncodedComponentsChanged);
    });
    if (this.preTickData.newJoinerConnections.size > 0) {
      const components = [];
      for (const [componentId, collection] of this.components) {
        components.push({
          componentId,
          values: collection.getCurrentValuesArray(),
          deltas: collection.getPreviousEmittedDeltasArray()
        });
      }
      const states = [];
      for (const [stateId, collection] of this.states) {
        states.push({
          stateId,
          values: collection.values
        });
      }
      const initialCheckout = {
        type: "initialCheckout",
        components,
        states,
        indicesCount: this.nextIndex,
        serverTime: this.getServerTime()
      };
      const writer2 = new BufferWriter(this.nextIndex * this.components.size + 128);
      encodeInitialCheckout(initialCheckout, writer2);
      const v01EncodedInitialCheckout = writer2.getBuffer();
      for (const deltaNetV01Connection of this.preTickData.newJoinerConnections) {
        deltaNetV01Connection.sendEncodedBytes(v01EncodedInitialCheckout);
      }
    }
    for (const deltaNetV01Connection of this.preTickData.newJoinerConnections) {
      this.authenticatedDeltaNetV01Connections.add(deltaNetV01Connection);
      deltaNetV01Connection.setAuthenticated();
    }
    this.preTickData.unoccupyingIndices.clear();
    this.preTickData.newJoinerConnections.clear();
    this.preTickData.newJoinerCallbacks.clear();
    return {
      removedIds,
      addedIds
    };
  }
  getServerTime() {
    return Date.now() - this.documentEffectiveStartTime;
  }
  setUserComponents(deltaNetV01Connection, internalConnectionId, components) {
    if (this.disposed) {
      console.error("Cannot dispatch remote event after dispose");
      return { success: false, error: "This DeltaNetServer has been disposed" };
    }
    if (deltaNetV01Connection.isObserver) {
      return { success: false, error: "Observers cannot send component updates" };
    }
    if (this.opts.onComponentsUpdate) {
      try {
        const result = this.opts.onComponentsUpdate({
          deltaNetV01Connection,
          internalConnectionId,
          components
        });
        if (result instanceof DeltaNetServerError) {
          return { success: false, error: result.message };
        }
        if (result instanceof Error) {
          return { success: false, error: result.message };
        }
      } catch (error) {
        console.warn("Error in onComponentsUpdate callback:", error);
        if (error instanceof DeltaNetServerError) {
          return { success: false, error: error.message };
        }
        if (error instanceof Error) {
          return { success: false, error: error.message };
        }
        return { success: false, error: "Component update failed" };
      }
    }
    this.applyComponentUpdates(deltaNetV01Connection, internalConnectionId, components);
    return { success: true };
  }
  setComponentValue(componentId, index, value) {
    this.preTickData.componentsUpdated++;
    let collection = this.components.get(componentId);
    if (!collection) {
      collection = new ComponentCollection();
      this.components.set(componentId, collection);
    }
    collection.setValue(index, value);
  }
  applyComponentUpdates(deltaNetV01Connection, internalConnectionId, components) {
    if (this.preTickData.newJoinerConnections.has(deltaNetV01Connection)) {
      for (const [componentId, componentValue] of components) {
        deltaNetV01Connection.components.set(componentId, componentValue);
      }
      return;
    }
    const index = this.connectionIdToComponentIndex.get(internalConnectionId);
    if (index === void 0) {
      return;
    }
    for (const [componentId, componentValue] of components) {
      this.setComponentValue(componentId, index, componentValue);
    }
  }
  overrideUserStates(deltaNetV01Connection, internalConnectionId, states) {
    this.applyStateUpdates(deltaNetV01Connection, internalConnectionId, states);
  }
  setUserState(index, stateId, stateValue) {
    let collection = this.states.get(stateId);
    if (!collection) {
      collection = new StateCollection();
      this.states.set(stateId, collection);
    }
    collection.setValue(index, stateValue);
  }
  applyStateUpdates(deltaNetV01Connection, internalConnectionId, states) {
    if (deltaNetV01Connection !== null && this.preTickData.newJoinerConnections.has(deltaNetV01Connection)) {
      for (const [stateId, stateValue] of states) {
        deltaNetV01Connection.states.set(stateId, stateValue);
      }
      return;
    }
    const index = this.connectionIdToComponentIndex.get(internalConnectionId);
    if (index === void 0) {
      return;
    }
    for (const [stateId, stateValue] of states) {
      this.setUserState(index, stateId, stateValue);
    }
  }
  handleCustomMessage(deltaNetV01Connection, internalConnectionId, customType, contents) {
    if (this.disposed) {
      return;
    }
    if (this.opts.onCustomMessage) {
      try {
        this.opts.onCustomMessage({
          deltaNetV01Connection,
          internalConnectionId,
          customType,
          contents
        });
      } catch (error) {
        console.warn("Error in onCustomMessage callback:", error);
      }
    }
  }
  broadcastCustomMessage(customType, contents) {
    if (this.disposed) {
      return;
    }
    const writer = new BufferWriter(contents.length + 16);
    const message = {
      type: "serverCustom",
      customType,
      contents
    };
    const encodedMessage = encodeServerMessage2(message, writer);
    const messageBytes = encodedMessage.getBuffer();
    this.authenticatedDeltaNetV01Connections.forEach((connection) => {
      try {
        connection.sendEncodedBytes(messageBytes);
      } catch (error) {
        console.warn("Failed to send custom message to connection:", error);
      }
    });
  }
  dispose() {
    this.disposed = true;
    const connectionsToClose = Array.from(this.allDeltaNetV01Connections);
    for (const connection of connectionsToClose) {
      try {
        connection.webSocket.close(1001, "Server shutting down");
      } catch (error) {
        console.warn("Failed to close connection during disposal:", error);
      }
    }
    this.allDeltaNetV01Connections.clear();
    this.authenticatedDeltaNetV01Connections.clear();
    this.observerConnections.clear();
    this.webSocketToDeltaNetServerConnection.clear();
    this.connectionIdToDeltaNetServerConnection.clear();
    this.connectionIdToComponentIndex.clear();
    this.componentIndexToConnectionId.clear();
    this.components.clear();
    this.states.clear();
    this.preTickData.newJoinerConnections.clear();
    this.preTickData.unoccupyingIndices.clear();
  }
};
export {
  DeltaNetServer2 as DeltaNetServer,
  DeltaNetServerError,
  DeltaNetV01Connection
};
//# sourceMappingURL=index.js.map
