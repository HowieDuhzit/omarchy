import { EulXYZ, Vect3, AnimationState, AnimationWeights } from "@mml-io/3d-web-client-core";
import { Color, Object3D, Quaternion, Vector3 } from "three";
import { ThreeJSCameraManager } from "../../camera/ThreeJSCameraManager";
import { LoadedAnimations } from "../Character";
import { ColorPartName } from "../CharacterModel";
import { CharacterModelLoader } from "../loading/CharacterModelLoader";
export type CharacterInstancesConfig = {
    animationsPromise: Promise<LoadedAnimations>;
    characterModelLoader: CharacterModelLoader;
    cameraManager: ThreeJSCameraManager;
    debug?: boolean;
};
export type InstanceData = {
    characterId: number;
    instanceId: number;
    isActive: boolean;
    isShadowed: boolean;
    time: number;
    speed: number;
    offset: number;
    currentAnimationState: string;
    animationTime: number;
    targetPosition: Vector3;
    targetQuaternion: Quaternion;
    lerpSpeed: number;
    hasNewTarget: boolean;
};
export declare class CharacterInstances {
    private config;
    private mixer;
    private action;
    private instancedMesh;
    private skinnedMesh;
    private clonedMaterials;
    private propertyBindings;
    private interpolants;
    private propertyBindingsLOD;
    private interpolantsLOD;
    private invMatrixWorld;
    private cameraLocalPosition;
    private delta;
    private characterScale;
    private currentBindingMode;
    private debug;
    private animationClip;
    private animationSegments;
    private characterIdToInstanceIdMap;
    private animationStateToSegmentName;
    /**
     * Apply colors to an instance at the given index
     * @param instanceIndex The index of the instance to apply colors to
     * @param colors Optional specific colors to apply, if not provided, random colors will be used
     */
    private applyInstanceColors;
    constructor(config: CharacterInstancesConfig);
    initialize(): Promise<Object3D | null>;
    spawnInstance(characterId: number, colors: Map<ColorPartName, Color>, position: Vect3, rotation: EulXYZ, animationState: AnimationState): void;
    despawnInstance(characterId: number): void;
    /**
     * Shadows an instance instead of fully despawning it. This keeps the instance data
     * intact (including colors) while hiding it when a real character is promoted.
     * This avoids texture updates when the character is later demoted back to an instance.
     */
    shadowInstance(characterId: number): void;
    /**
     * Reactivates a previously shadowed instance. This is used when a real character
     * is demoted back to an instance, allowing us to reuse the existing instance data
     * and avoid texture updates from creating a new instance.
     */
    unshadowInstance(characterId: number, position: Vect3, rotation: EulXYZ, animationState: AnimationState): void;
    updateInstance(characterId: number, position: Vect3, rotation: EulXYZ, animationState: AnimationState, animationWeights?: AnimationWeights): void;
    updateInstanceColors(characterId: number, colors: Map<string, Color>): void;
    private updateInstancedMeshBounds;
    private setMainMesh;
    private loadAnimation;
    private createInstancedMesh;
    private setupAnimationOptimization;
    private initializeSkeletonData;
    hasInstance(characterId: number): boolean;
    getPositionForInstance(characterId: number): Vect3 | null;
    private updateAllInstanceLerping;
    update(deltaTime: number): void;
    setupFrustumCulling(): void;
    clear(): void;
    dispose(): void;
    /**
     * Immediately sets an instance position without lerping. Used when unshadowing
     * instances to position them at the real character's last known position.
     */
    setInstancePositionImmediate(characterId: number, position: Vect3, rotation: EulXYZ, animationState: AnimationState): boolean;
}
//# sourceMappingURL=CharacterInstances.d.ts.map