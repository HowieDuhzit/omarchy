import { IVect3, RenderState } from "@mml-io/3d-web-client-core";
import { Group, Vector3 } from "three";
import { ThreeJSCameraManager } from "../camera/ThreeJSCameraManager";
import { Composer } from "../composer";
import { LoadedAnimations } from "./Character";
import { CharacterModelLoader } from "./loading/CharacterModelLoader";
export declare class ThreeJSCharacterManager {
    private threeJSCameraManager;
    private composer;
    private characterGroup;
    private characterModelLoader;
    private animationsPromise;
    private characterInstances;
    private characterInstancesReady;
    private pendingInstanceCharacters;
    private loadedCharacters;
    private loadingCharacters;
    private charactersReadyForScene;
    private readonly MAX_SCENE_ADDITIONS_PER_FRAME;
    private readonly MAX_REAL_REMOTE_CHARACTERS;
    private readonly LOD_CHANGE_COOLDOWN_MS;
    private lastLODEvaluation;
    private cachedHeadPosition;
    constructor(characterGroup: Group, animationsPromise: Promise<LoadedAnimations>, characterModelLoader: CharacterModelLoader, threeJSCameraManager: ThreeJSCameraManager, composer: Composer);
    update(state: RenderState, deltaTimeSeconds: number): void;
    despawnCharacter(characterId: number): void;
    getLocalCharacterPosition(localCharacterId: number | null): IVect3 | null;
    getCharacterHeadPosition(characterId: number): Vector3 | null;
    addChatBubble(characterId: number, message: string): void;
    getLocalCharacterForMML(localCharacterId: number | null): {
        position: {
            x: number;
            y: number;
            z: number;
        };
        rotation: {
            x: number;
            y: number;
            z: number;
        };
    } | null;
    dispose(): void;
    private spawnCharacter;
    private spawnCharacterInstance;
    private updateCharacterTransform;
    private updateCharacterDescription;
    private evaluateLOD;
    private promoteToReal;
    private demoteToInstance;
}
//# sourceMappingURL=ThreeJSCharacterManager.d.ts.map